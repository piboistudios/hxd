# Generated by Haxe 4.0.0-rc.2+77068e10c
# coding: utf-8

from os import path as python_lib_os_Path
import inspect as python_lib_Inspect
import os as python_lib_Os
import sys as python_lib_Sys
import subprocess as python_lib_Subprocess
from subprocess import Popen as python_lib_subprocess_Popen
from io import BufferedReader as python_lib_io_BufferedReader
from io import TextIOWrapper as python_lib_io_TextIOWrapper
from io import BufferedWriter as python_lib_io_BufferedWriter
import math as python_lib_Math
import math as Math
from datetime import datetime as python_lib_datetime_Datetime
import builtins as python_lib_Builtins
import functools as python_lib_Functools
import json as python_lib_Json
import random as python_lib_Random
import re as python_lib_Re
import socket as python_lib_Socket
import ssl as python_lib_Ssl
import time as python_lib_Time
import timeit as python_lib_Timeit
import traceback as python_lib_Traceback
from io import StringIO as python_lib_io_StringIO
from socket import socket as python_lib_socket_Socket
from ssl import SSLContext as python_lib_ssl_SSLContext
import urllib.parse as python_lib_urllib_Parse


class _hx_AnonObject:
    def __init__(self, fields):
        self.__dict__ = fields
    def __repr__(self):
        return repr(self.__dict__)


_hx_classes = {}


class Enum:
    _hx_class_name = "Enum"
    __slots__ = ("tag", "index", "params")
    _hx_fields = ["tag", "index", "params"]
    _hx_methods = ["__str__"]

    def __init__(self,tag,index,params):
        self.tag = tag
        self.index = index
        self.params = params

    def __str__(self):
        if (self.params is None):
            return self.tag
        else:
            _this = self.params
            return (((HxOverrides.stringOrNull(self.tag) + "(") + HxOverrides.stringOrNull(",".join([python_Boot.toString1(x1,'') for x1 in _this]))) + ")")

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.tag = None
        _hx_o.index = None
        _hx_o.params = None
Enum._hx_class = Enum
_hx_classes["Enum"] = Enum

class Attribute(Enum):
    __slots__ = ()
    _hx_class_name = "Attribute"
    _hx_constructs = ["Off", "Bold", "Underline", "Blink", "ReverseVideo", "Concealed", "BoldOff", "UnderlineOff", "BlinkOff", "NormalVideo", "ConcealedOff", "Black", "Red", "Green", "Yellow", "Blue", "Magenta", "Cyan", "White", "DefaultForeground", "BlackBack", "RedBack", "GreenBack", "YellowBack", "BlueBack", "MagentaBack", "CyanBack", "WhiteBack", "DefaultBackground"]
Attribute.Off = Attribute("Off", 0, list())
Attribute.Bold = Attribute("Bold", 1, list())
Attribute.Underline = Attribute("Underline", 2, list())
Attribute.Blink = Attribute("Blink", 3, list())
Attribute.ReverseVideo = Attribute("ReverseVideo", 4, list())
Attribute.Concealed = Attribute("Concealed", 5, list())
Attribute.BoldOff = Attribute("BoldOff", 6, list())
Attribute.UnderlineOff = Attribute("UnderlineOff", 7, list())
Attribute.BlinkOff = Attribute("BlinkOff", 8, list())
Attribute.NormalVideo = Attribute("NormalVideo", 9, list())
Attribute.ConcealedOff = Attribute("ConcealedOff", 10, list())
Attribute.Black = Attribute("Black", 11, list())
Attribute.Red = Attribute("Red", 12, list())
Attribute.Green = Attribute("Green", 13, list())
Attribute.Yellow = Attribute("Yellow", 14, list())
Attribute.Blue = Attribute("Blue", 15, list())
Attribute.Magenta = Attribute("Magenta", 16, list())
Attribute.Cyan = Attribute("Cyan", 17, list())
Attribute.White = Attribute("White", 18, list())
Attribute.DefaultForeground = Attribute("DefaultForeground", 19, list())
Attribute.BlackBack = Attribute("BlackBack", 20, list())
Attribute.RedBack = Attribute("RedBack", 21, list())
Attribute.GreenBack = Attribute("GreenBack", 22, list())
Attribute.YellowBack = Attribute("YellowBack", 23, list())
Attribute.BlueBack = Attribute("BlueBack", 24, list())
Attribute.MagentaBack = Attribute("MagentaBack", 25, list())
Attribute.CyanBack = Attribute("CyanBack", 26, list())
Attribute.WhiteBack = Attribute("WhiteBack", 27, list())
Attribute.DefaultBackground = Attribute("DefaultBackground", 28, list())
Attribute._hx_class = Attribute
_hx_classes["Attribute"] = Attribute


class sys_FileSystem:
    _hx_class_name = "sys.FileSystem"
    __slots__ = ()
    _hx_statics = ["exists", "stat", "createDirectory"]

    @staticmethod
    def exists(path):
        return python_lib_os_Path.exists(path)

    @staticmethod
    def stat(path):
        s = python_lib_Os.stat(path)
        return _hx_AnonObject({'gid': s.st_gid, 'uid': s.st_uid, 'atime': Date.fromTime((1000 * s.st_atime)), 'mtime': Date.fromTime((1000 * s.st_mtime)), 'ctime': Date.fromTime((1000 * s.st_ctime)), 'size': s.st_size, 'dev': s.st_dev, 'ino': s.st_ino, 'nlink': s.st_nlink, 'rdev': getattr(s,"st_rdev",0), 'mode': s.st_mode})

    @staticmethod
    def createDirectory(path):
        python_lib_Os.makedirs(path,511,True)
sys_FileSystem._hx_class = sys_FileSystem
_hx_classes["sys.FileSystem"] = sys_FileSystem


class haxe_IMap:
    _hx_class_name = "haxe.IMap"
    __slots__ = ()
haxe_IMap._hx_class = haxe_IMap
_hx_classes["haxe.IMap"] = haxe_IMap


class haxe_ds_StringMap:
    _hx_class_name = "haxe.ds.StringMap"
    __slots__ = ("h",)
    _hx_fields = ["h"]
    _hx_methods = ["keys"]
    _hx_interfaces = [haxe_IMap]

    def __init__(self):
        self.h = dict()

    def keys(self):
        return python_HaxeIterator(iter(self.h.keys()))

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.h = None
haxe_ds_StringMap._hx_class = haxe_ds_StringMap
_hx_classes["haxe.ds.StringMap"] = haxe_ds_StringMap


class python_HaxeIterator:
    _hx_class_name = "python.HaxeIterator"
    __slots__ = ("it", "x", "has", "checked")
    _hx_fields = ["it", "x", "has", "checked"]
    _hx_methods = ["next", "hasNext"]

    def __init__(self,it):
        self.checked = False
        self.has = False
        self.x = None
        self.it = it

    def next(self):
        if (not self.checked):
            self.hasNext()
        self.checked = False
        return self.x

    def hasNext(self):
        if (not self.checked):
            try:
                self.x = self.it.__next__()
                self.has = True
            except Exception as _hx_e:
                _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                if isinstance(_hx_e1, StopIteration):
                    s = _hx_e1
                    self.has = False
                    self.x = None
                else:
                    raise _hx_e
            self.checked = True
        return self.has

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.it = None
        _hx_o.x = None
        _hx_o.has = None
        _hx_o.checked = None
python_HaxeIterator._hx_class = python_HaxeIterator
_hx_classes["python.HaxeIterator"] = python_HaxeIterator


class Sys:
    _hx_class_name = "Sys"
    __slots__ = ()
    _hx_statics = ["environ", "exit", "getEnv", "systemName"]

    @staticmethod
    def exit(code):
        python_lib_Sys.exit(code)

    @staticmethod
    def getEnv(s):
        return Sys.environ.h.get(s,None)

    @staticmethod
    def systemName():
        _g = python_lib_Sys.platform
        if _g.startswith("linux"):
            return "Linux"
        else:
            _hx_local_0 = len(_g)
            if (_hx_local_0 == 5):
                if (_g == "win32"):
                    return "Windows"
                else:
                    raise _HxException("not supported platform")
            elif (_hx_local_0 == 6):
                if (_g == "cygwin"):
                    return "Windows"
                elif (_g == "darwin"):
                    return "Mac"
                else:
                    raise _HxException("not supported platform")
            else:
                raise _HxException("not supported platform")
Sys._hx_class = Sys
_hx_classes["Sys"] = Sys


class sys_io_Process:
    _hx_class_name = "sys.io.Process"
    __slots__ = ("stdout", "stderr", "stdin", "p")
    _hx_fields = ["stdout", "stderr", "stdin", "p"]
    _hx_methods = ["exitCode", "close"]

    def __init__(self,cmd,args = None,detached = None):
        self.stdin = None
        self.stderr = None
        self.stdout = None
        if detached:
            raise _HxException("Detached process is not supported on this platform")
        args1 = (cmd if ((args is None)) else ([cmd] + args))
        o = _hx_AnonObject({'shell': (args is None), 'stdin': python_lib_Subprocess.PIPE, 'stdout': python_lib_Subprocess.PIPE, 'stderr': python_lib_Subprocess.PIPE})
        Reflect.setField(o,"bufsize",(Reflect.field(o,"bufsize") if (hasattr(o,(("_hx_" + "bufsize") if (("bufsize" in python_Boot.keywords)) else (("_hx_" + "bufsize") if (((((len("bufsize") > 2) and ((ord("bufsize"[0]) == 95))) and ((ord("bufsize"[1]) == 95))) and ((ord("bufsize"[(len("bufsize") - 1)]) != 95)))) else "bufsize")))) else 0))
        Reflect.setField(o,"executable",(Reflect.field(o,"executable") if (hasattr(o,(("_hx_" + "executable") if (("executable" in python_Boot.keywords)) else (("_hx_" + "executable") if (((((len("executable") > 2) and ((ord("executable"[0]) == 95))) and ((ord("executable"[1]) == 95))) and ((ord("executable"[(len("executable") - 1)]) != 95)))) else "executable")))) else None))
        Reflect.setField(o,"stdin",(Reflect.field(o,"stdin") if (hasattr(o,(("_hx_" + "stdin") if (("stdin" in python_Boot.keywords)) else (("_hx_" + "stdin") if (((((len("stdin") > 2) and ((ord("stdin"[0]) == 95))) and ((ord("stdin"[1]) == 95))) and ((ord("stdin"[(len("stdin") - 1)]) != 95)))) else "stdin")))) else None))
        Reflect.setField(o,"stdout",(Reflect.field(o,"stdout") if (hasattr(o,(("_hx_" + "stdout") if (("stdout" in python_Boot.keywords)) else (("_hx_" + "stdout") if (((((len("stdout") > 2) and ((ord("stdout"[0]) == 95))) and ((ord("stdout"[1]) == 95))) and ((ord("stdout"[(len("stdout") - 1)]) != 95)))) else "stdout")))) else None))
        Reflect.setField(o,"stderr",(Reflect.field(o,"stderr") if (hasattr(o,(("_hx_" + "stderr") if (("stderr" in python_Boot.keywords)) else (("_hx_" + "stderr") if (((((len("stderr") > 2) and ((ord("stderr"[0]) == 95))) and ((ord("stderr"[1]) == 95))) and ((ord("stderr"[(len("stderr") - 1)]) != 95)))) else "stderr")))) else None))
        Reflect.setField(o,"preexec_fn",(Reflect.field(o,"preexec_fn") if (hasattr(o,(("_hx_" + "preexec_fn") if (("preexec_fn" in python_Boot.keywords)) else (("_hx_" + "preexec_fn") if (((((len("preexec_fn") > 2) and ((ord("preexec_fn"[0]) == 95))) and ((ord("preexec_fn"[1]) == 95))) and ((ord("preexec_fn"[(len("preexec_fn") - 1)]) != 95)))) else "preexec_fn")))) else None))
        Reflect.setField(o,"close_fds",(Reflect.field(o,"close_fds") if (hasattr(o,(("_hx_" + "close_fds") if (("close_fds" in python_Boot.keywords)) else (("_hx_" + "close_fds") if (((((len("close_fds") > 2) and ((ord("close_fds"[0]) == 95))) and ((ord("close_fds"[1]) == 95))) and ((ord("close_fds"[(len("close_fds") - 1)]) != 95)))) else "close_fds")))) else None))
        Reflect.setField(o,"shell",(Reflect.field(o,"shell") if (hasattr(o,(("_hx_" + "shell") if (("shell" in python_Boot.keywords)) else (("_hx_" + "shell") if (((((len("shell") > 2) and ((ord("shell"[0]) == 95))) and ((ord("shell"[1]) == 95))) and ((ord("shell"[(len("shell") - 1)]) != 95)))) else "shell")))) else None))
        Reflect.setField(o,"cwd",(Reflect.field(o,"cwd") if (hasattr(o,(("_hx_" + "cwd") if (("cwd" in python_Boot.keywords)) else (("_hx_" + "cwd") if (((((len("cwd") > 2) and ((ord("cwd"[0]) == 95))) and ((ord("cwd"[1]) == 95))) and ((ord("cwd"[(len("cwd") - 1)]) != 95)))) else "cwd")))) else None))
        Reflect.setField(o,"env",(Reflect.field(o,"env") if (hasattr(o,(("_hx_" + "env") if (("env" in python_Boot.keywords)) else (("_hx_" + "env") if (((((len("env") > 2) and ((ord("env"[0]) == 95))) and ((ord("env"[1]) == 95))) and ((ord("env"[(len("env") - 1)]) != 95)))) else "env")))) else None))
        Reflect.setField(o,"universal_newlines",(Reflect.field(o,"universal_newlines") if (hasattr(o,(("_hx_" + "universal_newlines") if (("universal_newlines" in python_Boot.keywords)) else (("_hx_" + "universal_newlines") if (((((len("universal_newlines") > 2) and ((ord("universal_newlines"[0]) == 95))) and ((ord("universal_newlines"[1]) == 95))) and ((ord("universal_newlines"[(len("universal_newlines") - 1)]) != 95)))) else "universal_newlines")))) else None))
        Reflect.setField(o,"startupinfo",(Reflect.field(o,"startupinfo") if (hasattr(o,(("_hx_" + "startupinfo") if (("startupinfo" in python_Boot.keywords)) else (("_hx_" + "startupinfo") if (((((len("startupinfo") > 2) and ((ord("startupinfo"[0]) == 95))) and ((ord("startupinfo"[1]) == 95))) and ((ord("startupinfo"[(len("startupinfo") - 1)]) != 95)))) else "startupinfo")))) else None))
        Reflect.setField(o,"creationflags",(Reflect.field(o,"creationflags") if (hasattr(o,(("_hx_" + "creationflags") if (("creationflags" in python_Boot.keywords)) else (("_hx_" + "creationflags") if (((((len("creationflags") > 2) and ((ord("creationflags"[0]) == 95))) and ((ord("creationflags"[1]) == 95))) and ((ord("creationflags"[(len("creationflags") - 1)]) != 95)))) else "creationflags")))) else 0))
        self.p = (python_lib_subprocess_Popen(args1,Reflect.field(o,"bufsize"),Reflect.field(o,"executable"),Reflect.field(o,"stdin"),Reflect.field(o,"stdout"),Reflect.field(o,"stderr"),Reflect.field(o,"preexec_fn"),Reflect.field(o,"close_fds"),Reflect.field(o,"shell"),Reflect.field(o,"cwd"),Reflect.field(o,"env"),Reflect.field(o,"universal_newlines"),Reflect.field(o,"startupinfo"),Reflect.field(o,"creationflags")) if ((Sys.systemName() == "Windows")) else python_lib_subprocess_Popen(args1,Reflect.field(o,"bufsize"),Reflect.field(o,"executable"),Reflect.field(o,"stdin"),Reflect.field(o,"stdout"),Reflect.field(o,"stderr"),Reflect.field(o,"preexec_fn"),Reflect.field(o,"close_fds"),Reflect.field(o,"shell"),Reflect.field(o,"cwd"),Reflect.field(o,"env"),Reflect.field(o,"universal_newlines"),Reflect.field(o,"startupinfo")))
        self.stdout = python_io_IoTools.createFileInputFromText(python_lib_io_TextIOWrapper(python_lib_io_BufferedReader(self.p.stdout)))
        self.stderr = python_io_IoTools.createFileInputFromText(python_lib_io_TextIOWrapper(python_lib_io_BufferedReader(self.p.stderr)))
        self.stdin = python_io_IoTools.createFileOutputFromText(python_lib_io_TextIOWrapper(python_lib_io_BufferedWriter(self.p.stdin)))

    def exitCode(self,block = True):
        if (block is None):
            block = True
        if (block == False):
            return self.p.poll()
        return self.p.wait()

    def close(self):
        ver = python_lib_Sys.version_info
        if ((ver[0] > 3) or (((ver[0] == 3) and ((ver[1] >= 3))))):
            try:
                self.p.terminate()
            except Exception as _hx_e:
                _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                if isinstance(_hx_e1, ProcessLookupError):
                        pass
                else:
                    raise _hx_e
        else:
            try:
                self.p.terminate()
            except Exception as _hx_e:
                _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                if isinstance(_hx_e1, OSError):
                        pass
                else:
                    raise _hx_e

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.stdout = None
        _hx_o.stderr = None
        _hx_o.stdin = None
        _hx_o.p = None
sys_io_Process._hx_class = sys_io_Process
_hx_classes["sys.io.Process"] = sys_io_Process


class python_Boot:
    _hx_class_name = "python.Boot"
    __slots__ = ()
    _hx_statics = ["keywords", "toString1", "fields", "simpleField", "field", "getInstanceFields", "getSuperClass", "getClassFields", "prefixLength", "unhandleKeywords"]

    @staticmethod
    def toString1(o,s):
        if (o is None):
            return "null"
        if isinstance(o,str):
            return o
        if (s is None):
            s = ""
        if (len(s) >= 5):
            return "<...>"
        if isinstance(o,bool):
            if o:
                return "true"
            else:
                return "false"
        if (isinstance(o,int) and (not isinstance(o,bool))):
            return str(o)
        if isinstance(o,float):
            try:
                if (o == int(o)):
                    return str(Math.floor((o + 0.5)))
                else:
                    return str(o)
            except Exception as _hx_e:
                _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                e = _hx_e1
                return str(o)
        if isinstance(o,list):
            o1 = o
            l = len(o1)
            st = "["
            s = (("null" if s is None else s) + "\t")
            _g = 0
            _g1 = l
            while (_g < _g1):
                i = _g
                _g = (_g + 1)
                prefix = ""
                if (i > 0):
                    prefix = ","
                st = (("null" if st is None else st) + HxOverrides.stringOrNull(((("null" if prefix is None else prefix) + HxOverrides.stringOrNull(python_Boot.toString1((o1[i] if i >= 0 and i < len(o1) else None),s))))))
            st = (("null" if st is None else st) + "]")
            return st
        try:
            if hasattr(o,"toString"):
                return o.toString()
        except Exception as _hx_e:
            _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
            pass
        if (python_lib_Inspect.isfunction(o) or python_lib_Inspect.ismethod(o)):
            return "<function>"
        if hasattr(o,"__class__"):
            if isinstance(o,_hx_AnonObject):
                toStr = None
                try:
                    fields = python_Boot.fields(o)
                    _g2 = []
                    _g11 = 0
                    while (_g11 < len(fields)):
                        f = (fields[_g11] if _g11 >= 0 and _g11 < len(fields) else None)
                        _g11 = (_g11 + 1)
                        x = ((("" + ("null" if f is None else f)) + " : ") + HxOverrides.stringOrNull(python_Boot.toString1(python_Boot.simpleField(o,f),(("null" if s is None else s) + "\t"))))
                        _g2.append(x)
                    fieldsStr = _g2
                    toStr = (("{ " + HxOverrides.stringOrNull(", ".join([x1 for x1 in fieldsStr]))) + " }")
                except Exception as _hx_e:
                    _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                    e2 = _hx_e1
                    return "{ ... }"
                if (toStr is None):
                    return "{ ... }"
                else:
                    return toStr
            if isinstance(o,Enum):
                o2 = o
                l1 = len(o2.params)
                hasParams = (l1 > 0)
                if hasParams:
                    paramsStr = ""
                    _g3 = 0
                    _g12 = l1
                    while (_g3 < _g12):
                        i1 = _g3
                        _g3 = (_g3 + 1)
                        prefix1 = ""
                        if (i1 > 0):
                            prefix1 = ","
                        paramsStr = (("null" if paramsStr is None else paramsStr) + HxOverrides.stringOrNull(((("null" if prefix1 is None else prefix1) + HxOverrides.stringOrNull(python_Boot.toString1((o2.params[i1] if i1 >= 0 and i1 < len(o2.params) else None),s))))))
                    return (((HxOverrides.stringOrNull(o2.tag) + "(") + ("null" if paramsStr is None else paramsStr)) + ")")
                else:
                    return o2.tag
            if hasattr(o,"_hx_class_name"):
                if (o.__class__.__name__ != "type"):
                    fields1 = python_Boot.getInstanceFields(o)
                    _g4 = []
                    _g13 = 0
                    while (_g13 < len(fields1)):
                        f1 = (fields1[_g13] if _g13 >= 0 and _g13 < len(fields1) else None)
                        _g13 = (_g13 + 1)
                        x1 = ((("" + ("null" if f1 is None else f1)) + " : ") + HxOverrides.stringOrNull(python_Boot.toString1(python_Boot.simpleField(o,f1),(("null" if s is None else s) + "\t"))))
                        _g4.append(x1)
                    fieldsStr1 = _g4
                    toStr1 = (((HxOverrides.stringOrNull(o._hx_class_name) + "( ") + HxOverrides.stringOrNull(", ".join([x1 for x1 in fieldsStr1]))) + " )")
                    return toStr1
                else:
                    fields2 = python_Boot.getClassFields(o)
                    _g5 = []
                    _g14 = 0
                    while (_g14 < len(fields2)):
                        f2 = (fields2[_g14] if _g14 >= 0 and _g14 < len(fields2) else None)
                        _g14 = (_g14 + 1)
                        x2 = ((("" + ("null" if f2 is None else f2)) + " : ") + HxOverrides.stringOrNull(python_Boot.toString1(python_Boot.simpleField(o,f2),(("null" if s is None else s) + "\t"))))
                        _g5.append(x2)
                    fieldsStr2 = _g5
                    toStr2 = (((("#" + HxOverrides.stringOrNull(o._hx_class_name)) + "( ") + HxOverrides.stringOrNull(", ".join([x1 for x1 in fieldsStr2]))) + " )")
                    return toStr2
            if (o == str):
                return "#String"
            if (o == list):
                return "#Array"
            if callable(o):
                return "function"
            try:
                if hasattr(o,"__repr__"):
                    return o.__repr__()
            except Exception as _hx_e:
                _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                pass
            if hasattr(o,"__str__"):
                return o.__str__([])
            if hasattr(o,"__name__"):
                return o.__name__
            return "???"
        else:
            return str(o)

    @staticmethod
    def fields(o):
        a = []
        if (o is not None):
            if hasattr(o,"_hx_fields"):
                return list(o._hx_fields)
            if isinstance(o,_hx_AnonObject):
                d = o.__dict__
                keys = d.keys()
                handler = python_Boot.unhandleKeywords
                for k in keys:
                    a.append(handler(k))
            elif hasattr(o,"__dict__"):
                d1 = o.__dict__
                keys1 = d1.keys()
                for k in keys1:
                    a.append(k)
        return a

    @staticmethod
    def simpleField(o,field):
        if (field is None):
            return None
        field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
        if hasattr(o,field1):
            return getattr(o,field1)
        else:
            return None

    @staticmethod
    def field(o,field):
        if (field is None):
            return None
        if isinstance(o,str):
            _hx_local_0 = len(field)
            if (_hx_local_0 == 10):
                if (field == "charCodeAt"):
                    return python_internal_MethodClosure(o,HxString.charCodeAt)
                else:
                    field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    return (getattr(o,field1) if (hasattr(o,field1)) else None)
            elif (_hx_local_0 == 11):
                if (field == "lastIndexOf"):
                    return python_internal_MethodClosure(o,HxString.lastIndexOf)
                elif (field == "toLowerCase"):
                    return python_internal_MethodClosure(o,HxString.toLowerCase)
                elif (field == "toUpperCase"):
                    return python_internal_MethodClosure(o,HxString.toUpperCase)
                else:
                    field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    return (getattr(o,field1) if (hasattr(o,field1)) else None)
            elif (_hx_local_0 == 9):
                if (field == "substring"):
                    return python_internal_MethodClosure(o,HxString.substring)
                else:
                    field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    return (getattr(o,field1) if (hasattr(o,field1)) else None)
            elif (_hx_local_0 == 5):
                if (field == "split"):
                    return python_internal_MethodClosure(o,HxString.split)
                else:
                    field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    return (getattr(o,field1) if (hasattr(o,field1)) else None)
            elif (_hx_local_0 == 7):
                if (field == "indexOf"):
                    return python_internal_MethodClosure(o,HxString.indexOf)
                else:
                    field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    return (getattr(o,field1) if (hasattr(o,field1)) else None)
            elif (_hx_local_0 == 8):
                if (field == "toString"):
                    return python_internal_MethodClosure(o,HxString.toString)
                else:
                    field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    return (getattr(o,field1) if (hasattr(o,field1)) else None)
            elif (_hx_local_0 == 6):
                if (field == "charAt"):
                    return python_internal_MethodClosure(o,HxString.charAt)
                elif (field == "length"):
                    return len(o)
                elif (field == "substr"):
                    return python_internal_MethodClosure(o,HxString.substr)
                else:
                    field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    return (getattr(o,field1) if (hasattr(o,field1)) else None)
            else:
                field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                return (getattr(o,field1) if (hasattr(o,field1)) else None)
        elif isinstance(o,list):
            _hx_local_1 = len(field)
            if (_hx_local_1 == 11):
                if (field == "lastIndexOf"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.lastIndexOf)
                else:
                    field2 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    return (getattr(o,field2) if (hasattr(o,field2)) else None)
            elif (_hx_local_1 == 4):
                if (field == "copy"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.copy)
                elif (field == "join"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.join)
                elif (field == "push"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.push)
                elif (field == "sort"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.sort)
                else:
                    field2 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    return (getattr(o,field2) if (hasattr(o,field2)) else None)
            elif (_hx_local_1 == 5):
                if (field == "shift"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.shift)
                elif (field == "slice"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.slice)
                else:
                    field2 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    return (getattr(o,field2) if (hasattr(o,field2)) else None)
            elif (_hx_local_1 == 7):
                if (field == "indexOf"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.indexOf)
                elif (field == "reverse"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.reverse)
                elif (field == "unshift"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.unshift)
                else:
                    field2 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    return (getattr(o,field2) if (hasattr(o,field2)) else None)
            elif (_hx_local_1 == 3):
                if (field == "map"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.map)
                elif (field == "pop"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.pop)
                else:
                    field2 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    return (getattr(o,field2) if (hasattr(o,field2)) else None)
            elif (_hx_local_1 == 8):
                if (field == "iterator"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.iterator)
                elif (field == "toString"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.toString)
                else:
                    field2 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    return (getattr(o,field2) if (hasattr(o,field2)) else None)
            elif (_hx_local_1 == 6):
                if (field == "concat"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.concat)
                elif (field == "filter"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.filter)
                elif (field == "insert"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.insert)
                elif (field == "length"):
                    return len(o)
                elif (field == "remove"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.remove)
                elif (field == "splice"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.splice)
                else:
                    field2 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    return (getattr(o,field2) if (hasattr(o,field2)) else None)
            else:
                field2 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                return (getattr(o,field2) if (hasattr(o,field2)) else None)
        else:
            field3 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
            return (getattr(o,field3) if (hasattr(o,field3)) else None)

    @staticmethod
    def getInstanceFields(c):
        f = (list(c._hx_fields) if (hasattr(c,"_hx_fields")) else [])
        if hasattr(c,"_hx_methods"):
            f = (f + c._hx_methods)
        sc = python_Boot.getSuperClass(c)
        if (sc is None):
            return f
        else:
            scArr = python_Boot.getInstanceFields(sc)
            scMap = set(scArr)
            _g = 0
            while (_g < len(f)):
                f1 = (f[_g] if _g >= 0 and _g < len(f) else None)
                _g = (_g + 1)
                if (not (f1 in scMap)):
                    scArr.append(f1)
            return scArr

    @staticmethod
    def getSuperClass(c):
        if (c is None):
            return None
        try:
            if hasattr(c,"_hx_super"):
                return c._hx_super
            return None
        except Exception as _hx_e:
            _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
            pass
        return None

    @staticmethod
    def getClassFields(c):
        if hasattr(c,"_hx_statics"):
            x = c._hx_statics
            return list(x)
        else:
            return []

    @staticmethod
    def unhandleKeywords(name):
        if (HxString.substr(name,0,python_Boot.prefixLength) == "_hx_"):
            real = HxString.substr(name,python_Boot.prefixLength,None)
            if (real in python_Boot.keywords):
                return real
        return name
python_Boot._hx_class = python_Boot
_hx_classes["python.Boot"] = python_Boot


class python_io_IoTools:
    _hx_class_name = "python.io.IoTools"
    __slots__ = ()
    _hx_statics = ["createFileInputFromText", "createFileInputFromBytes", "createFileOutputFromText", "createFileOutputFromBytes", "seekInTextMode", "seekInBinaryMode"]

    @staticmethod
    def createFileInputFromText(t):
        return sys_io_FileInput(python_io_FileTextInput(t))

    @staticmethod
    def createFileInputFromBytes(t):
        return sys_io_FileInput(python_io_FileBytesInput(t))

    @staticmethod
    def createFileOutputFromText(t):
        return sys_io_FileOutput(python_io_FileTextOutput(t))

    @staticmethod
    def createFileOutputFromBytes(t):
        return sys_io_FileOutput(python_io_FileBytesOutput(t))

    @staticmethod
    def seekInTextMode(stream,tell,p,pos):
        pos1 = None
        pos2 = pos.index
        if (pos2 == 0):
            pos1 = 0
        elif (pos2 == 1):
            p = (tell() + p)
            pos1 = 0
        elif (pos2 == 2):
            stream.seek(0,2)
            p = (tell() + p)
            pos1 = 0
        else:
            pass
        stream.seek(p,pos1)

    @staticmethod
    def seekInBinaryMode(stream,p,pos):
        pos1 = None
        pos2 = pos.index
        if (pos2 == 0):
            pos1 = 0
        elif (pos2 == 1):
            pos1 = 1
        elif (pos2 == 2):
            pos1 = 2
        else:
            pass
        stream.seek(p,pos1)
python_io_IoTools._hx_class = python_io_IoTools
_hx_classes["python.io.IoTools"] = python_io_IoTools


class haxe_io_Input:
    _hx_class_name = "haxe.io.Input"
    __slots__ = ("bigEndian",)
    _hx_fields = ["bigEndian"]
    _hx_methods = ["readByte", "readBytes", "set_bigEndian", "read", "readInt16", "readUInt16"]

    def readByte(self):
        raise _HxException("Not implemented")

    def readBytes(self,s,pos,_hx_len):
        k = _hx_len
        b = s.b
        if (((pos < 0) or ((_hx_len < 0))) or (((pos + _hx_len) > s.length))):
            raise _HxException(haxe_io_Error.OutsideBounds)
        try:
            while (k > 0):
                b[pos] = self.readByte()
                pos = (pos + 1)
                k = (k - 1)
        except Exception as _hx_e:
            _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
            if isinstance(_hx_e1, haxe_io_Eof):
                    pass
            else:
                raise _hx_e
        return (_hx_len - k)

    def set_bigEndian(self,b):
        self.bigEndian = b
        return b

    def read(self,nbytes):
        s = haxe_io_Bytes.alloc(nbytes)
        p = 0
        while (nbytes > 0):
            k = self.readBytes(s,p,nbytes)
            if (k == 0):
                raise _HxException(haxe_io_Error.Blocked)
            p = (p + k)
            nbytes = (nbytes - k)
        return s

    def readInt16(self):
        ch1 = self.readByte()
        ch2 = self.readByte()
        n = ((ch2 | ((ch1 << 8))) if (self.bigEndian) else (ch1 | ((ch2 << 8))))
        if (((n & 32768)) != 0):
            return (n - 65536)
        return n

    def readUInt16(self):
        ch1 = self.readByte()
        ch2 = self.readByte()
        if self.bigEndian:
            return (ch2 | ((ch1 << 8)))
        else:
            return (ch1 | ((ch2 << 8)))

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.bigEndian = None
haxe_io_Input._hx_class = haxe_io_Input
_hx_classes["haxe.io.Input"] = haxe_io_Input


class python_io_NativeInput(haxe_io_Input):
    _hx_class_name = "python.io.NativeInput"
    __slots__ = ("stream", "wasEof")
    _hx_fields = ["stream", "wasEof"]
    _hx_methods = ["tell", "throwEof", "readinto", "readBytes"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = haxe_io_Input


    def __init__(self,s):
        self.wasEof = None
        self.stream = s
        self.set_bigEndian(False)
        self.wasEof = False
        if (not self.stream.readable()):
            raise _HxException("Write-only stream")

    def tell(self):
        return self.stream.tell()

    def throwEof(self):
        self.wasEof = True
        raise _HxException(haxe_io_Eof())

    def readinto(self,b):
        raise _HxException("abstract method, should be overridden")

    def readBytes(self,s,pos,_hx_len):
        if (((pos < 0) or ((_hx_len < 0))) or (((pos + _hx_len) > s.length))):
            raise _HxException(haxe_io_Error.OutsideBounds)
        ba = bytearray(_hx_len)
        ret = self.readinto(ba)
        if (ret == 0):
            self.throwEof()
        s.blit(pos,haxe_io_Bytes.ofData(ba),0,_hx_len)
        return ret

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.stream = None
        _hx_o.wasEof = None
        _hx_o.canSeek = None
python_io_NativeInput._hx_class = python_io_NativeInput
_hx_classes["python.io.NativeInput"] = python_io_NativeInput


class python_io_IInput:
    _hx_class_name = "python.io.IInput"
    __slots__ = ()
    _hx_methods = ["set_bigEndian", "readByte", "readBytes", "read", "readInt16", "readUInt16"]
python_io_IInput._hx_class = python_io_IInput
_hx_classes["python.io.IInput"] = python_io_IInput


class python_io_NativeTextInput(python_io_NativeInput):
    _hx_class_name = "python.io.NativeTextInput"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = ["readByte", "seek", "readinto"]
    _hx_statics = []
    _hx_interfaces = [python_io_IInput]
    _hx_super = python_io_NativeInput


    def __init__(self,stream):
        super().__init__(stream)

    def readByte(self):
        ret = self.stream.read(1)
        if (len(ret) == 0):
            self.throwEof()
        return HxString.charCodeAt(ret,0)

    def seek(self,p,pos):
        self.wasEof = False
        python_io_IoTools.seekInTextMode(self.stream,self.tell,p,pos)

    def readinto(self,b):
        return self.stream.buffer.readinto(b)

    @staticmethod
    def _hx_empty_init(_hx_o):        pass
python_io_NativeTextInput._hx_class = python_io_NativeTextInput
_hx_classes["python.io.NativeTextInput"] = python_io_NativeTextInput


class python_io_IFileInput:
    _hx_class_name = "python.io.IFileInput"
    __slots__ = ()
    _hx_methods = ["seek"]
    _hx_interfaces = [python_io_IInput]
python_io_IFileInput._hx_class = python_io_IFileInput
_hx_classes["python.io.IFileInput"] = python_io_IFileInput


class python_io_FileTextInput(python_io_NativeTextInput):
    _hx_class_name = "python.io.FileTextInput"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = []
    _hx_statics = []
    _hx_interfaces = [python_io_IFileInput]
    _hx_super = python_io_NativeTextInput


    def __init__(self,stream):
        super().__init__(stream)
python_io_FileTextInput._hx_class = python_io_FileTextInput
_hx_classes["python.io.FileTextInput"] = python_io_FileTextInput


class sys_io_FileInput(haxe_io_Input):
    _hx_class_name = "sys.io.FileInput"
    __slots__ = ("impl",)
    _hx_fields = ["impl"]
    _hx_methods = ["set_bigEndian", "seek", "readByte", "readBytes", "read", "readInt16", "readUInt16"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = haxe_io_Input


    def __init__(self,impl):
        self.impl = impl

    def set_bigEndian(self,b):
        return self.impl.set_bigEndian(b)

    def seek(self,p,pos):
        self.impl.seek(p,pos)
        return

    def readByte(self):
        return self.impl.readByte()

    def readBytes(self,s,pos,_hx_len):
        return self.impl.readBytes(s,pos,_hx_len)

    def read(self,nbytes):
        return self.impl.read(nbytes)

    def readInt16(self):
        return self.impl.readInt16()

    def readUInt16(self):
        return self.impl.readUInt16()

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.impl = None
sys_io_FileInput._hx_class = sys_io_FileInput
_hx_classes["sys.io.FileInput"] = sys_io_FileInput


class haxe_io_Output:
    _hx_class_name = "haxe.io.Output"
    __slots__ = ("bigEndian",)
    _hx_fields = ["bigEndian"]
    _hx_methods = ["writeByte", "writeBytes", "close", "set_bigEndian", "write", "writeFullBytes", "writeInt16", "writeUInt16", "prepare", "writeString"]

    def writeByte(self,c):
        raise _HxException("Not implemented")

    def writeBytes(self,s,pos,_hx_len):
        if (((pos < 0) or ((_hx_len < 0))) or (((pos + _hx_len) > s.length))):
            raise _HxException(haxe_io_Error.OutsideBounds)
        b = s.b
        k = _hx_len
        while (k > 0):
            self.writeByte(b[pos])
            pos = (pos + 1)
            k = (k - 1)
        return _hx_len

    def close(self):
        pass

    def set_bigEndian(self,b):
        self.bigEndian = b
        return b

    def write(self,s):
        l = s.length
        p = 0
        while (l > 0):
            k = self.writeBytes(s,p,l)
            if (k == 0):
                raise _HxException(haxe_io_Error.Blocked)
            p = (p + k)
            l = (l - k)

    def writeFullBytes(self,s,pos,_hx_len):
        while (_hx_len > 0):
            k = self.writeBytes(s,pos,_hx_len)
            pos = (pos + k)
            _hx_len = (_hx_len - k)

    def writeInt16(self,x):
        if ((x < -32768) or ((x >= 32768))):
            raise _HxException(haxe_io_Error.Overflow)
        self.writeUInt16((x & 65535))

    def writeUInt16(self,x):
        if ((x < 0) or ((x >= 65536))):
            raise _HxException(haxe_io_Error.Overflow)
        if self.bigEndian:
            self.writeByte((x >> 8))
            self.writeByte((x & 255))
        else:
            self.writeByte((x & 255))
            self.writeByte((x >> 8))

    def prepare(self,nbytes):
        pass

    def writeString(self,s,encoding = None):
        b = haxe_io_Bytes.ofString(s,encoding)
        self.writeFullBytes(b,0,b.length)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.bigEndian = None
haxe_io_Output._hx_class = haxe_io_Output
_hx_classes["haxe.io.Output"] = haxe_io_Output


class python_io_NativeOutput(haxe_io_Output):
    _hx_class_name = "python.io.NativeOutput"
    __slots__ = ("stream",)
    _hx_fields = ["stream"]
    _hx_methods = ["close", "prepare", "flush", "tell"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = haxe_io_Output


    def __init__(self,stream):
        self.stream = None
        self.set_bigEndian(False)
        self.stream = stream
        if (not stream.writable()):
            raise _HxException("Read only stream")

    def close(self):
        self.stream.close()

    def prepare(self,nbytes):
        self.stream.truncate(nbytes)

    def flush(self):
        self.stream.flush()

    def tell(self):
        return self.stream.tell()

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.stream = None
        _hx_o.canSeek = None
python_io_NativeOutput._hx_class = python_io_NativeOutput
_hx_classes["python.io.NativeOutput"] = python_io_NativeOutput


class python_io_NativeTextOutput(python_io_NativeOutput):
    _hx_class_name = "python.io.NativeTextOutput"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = ["seek", "writeByte"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = python_io_NativeOutput


    def __init__(self,stream):
        super().__init__(stream)
        if (not stream.writable()):
            raise _HxException("Read only stream")

    def seek(self,p,pos):
        python_io_IoTools.seekInTextMode(self.stream,self.tell,p,pos)

    def writeByte(self,c):
        self.stream.write("".join(map(chr,[c])))

    @staticmethod
    def _hx_empty_init(_hx_o):        pass
python_io_NativeTextOutput._hx_class = python_io_NativeTextOutput
_hx_classes["python.io.NativeTextOutput"] = python_io_NativeTextOutput


class python_io_IOutput:
    _hx_class_name = "python.io.IOutput"
    __slots__ = ()
    _hx_methods = ["set_bigEndian", "writeByte", "writeBytes", "flush", "close", "write", "writeFullBytes", "writeInt16", "writeUInt16", "prepare", "writeString"]
python_io_IOutput._hx_class = python_io_IOutput
_hx_classes["python.io.IOutput"] = python_io_IOutput


class python_io_IFileOutput:
    _hx_class_name = "python.io.IFileOutput"
    __slots__ = ()
    _hx_methods = ["seek"]
    _hx_interfaces = [python_io_IOutput]
python_io_IFileOutput._hx_class = python_io_IFileOutput
_hx_classes["python.io.IFileOutput"] = python_io_IFileOutput


class python_io_FileTextOutput(python_io_NativeTextOutput):
    _hx_class_name = "python.io.FileTextOutput"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = []
    _hx_statics = []
    _hx_interfaces = [python_io_IFileOutput]
    _hx_super = python_io_NativeTextOutput


    def __init__(self,stream):
        super().__init__(stream)
python_io_FileTextOutput._hx_class = python_io_FileTextOutput
_hx_classes["python.io.FileTextOutput"] = python_io_FileTextOutput


class sys_io_FileOutput(haxe_io_Output):
    _hx_class_name = "sys.io.FileOutput"
    __slots__ = ("impl",)
    _hx_fields = ["impl"]
    _hx_methods = ["seek", "set_bigEndian", "writeByte", "writeBytes", "flush", "close", "write", "writeFullBytes", "writeInt16", "writeUInt16", "prepare", "writeString"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = haxe_io_Output


    def __init__(self,impl):
        self.impl = impl

    def seek(self,p,pos):
        self.impl.seek(p,pos)
        return

    def set_bigEndian(self,b):
        return self.impl.set_bigEndian(b)

    def writeByte(self,c):
        self.impl.writeByte(c)

    def writeBytes(self,s,pos,_hx_len):
        return self.impl.writeBytes(s,pos,_hx_len)

    def flush(self):
        self.impl.flush()

    def close(self):
        self.impl.close()

    def write(self,s):
        self.impl.write(s)

    def writeFullBytes(self,s,pos,_hx_len):
        self.impl.writeFullBytes(s,pos,_hx_len)

    def writeInt16(self,x):
        self.impl.writeInt16(x)

    def writeUInt16(self,x):
        self.impl.writeUInt16(x)

    def prepare(self,nbytes):
        self.impl.prepare(nbytes)

    def writeString(self,s,encoding = None):
        self.impl.writeString(s)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.impl = None
sys_io_FileOutput._hx_class = sys_io_FileOutput
_hx_classes["sys.io.FileOutput"] = sys_io_FileOutput


class Reflect:
    _hx_class_name = "Reflect"
    __slots__ = ()
    _hx_statics = ["field", "setField", "callMethod", "isFunction", "compare", "isEnumValue", "makeVarArgs"]

    @staticmethod
    def field(o,field):
        return python_Boot.field(o,field)

    @staticmethod
    def setField(o,field,value):
        setattr(o,(("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field)),value)

    @staticmethod
    def callMethod(o,func,args):
        if callable(func):
            return func(*args)
        else:
            return None

    @staticmethod
    def isFunction(f):
        if (not ((python_lib_Inspect.isfunction(f) or python_lib_Inspect.ismethod(f)))):
            return hasattr(f,"func_code")
        else:
            return True

    @staticmethod
    def compare(a,b):
        if ((a is None) and ((b is None))):
            return 0
        if (a is None):
            return 1
        elif (b is None):
            return -1
        elif HxOverrides.eq(a,b):
            return 0
        elif (a > b):
            return 1
        else:
            return -1

    @staticmethod
    def isEnumValue(v):
        if not HxOverrides.eq(v,Enum):
            return isinstance(v,Enum)
        else:
            return False

    @staticmethod
    def makeVarArgs(f):
        def _hx_local_0(*v):
            this1 = v
            tmp = (list(this1) if ((not Std._hx_is(this1,list))) else this1)
            return f(tmp)
        return _hx_local_0
Reflect._hx_class = Reflect
_hx_classes["Reflect"] = Reflect


class Std:
    _hx_class_name = "Std"
    __slots__ = ()
    _hx_statics = ["is", "string", "parseInt", "shortenPossibleNumber", "parseFloat"]

    @staticmethod
    def _hx_is(v,t):
        if ((v is None) and ((t is None))):
            return False
        if (t is None):
            return False
        if (t == Dynamic):
            return (v is not None)
        isBool = isinstance(v,bool)
        if ((t == Bool) and isBool):
            return True
        if ((((not isBool) and (not (t == Bool))) and (t == Int)) and isinstance(v,int)):
            return True
        vIsFloat = isinstance(v,float)
        tmp = None
        tmp1 = None
        if (((not isBool) and vIsFloat) and (t == Int)):
            f = v
            tmp1 = (((f != Math.POSITIVE_INFINITY) and ((f != Math.NEGATIVE_INFINITY))) and (not python_lib_Math.isnan(f)))
        else:
            tmp1 = False
        if tmp1:
            tmp2 = None
            try:
                tmp2 = int(v)
            except Exception as _hx_e:
                _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                e = _hx_e1
                tmp2 = None
            tmp = (v == tmp2)
        else:
            tmp = False
        if ((tmp and ((v <= 2147483647))) and ((v >= -2147483648))):
            return True
        if (((not isBool) and (t == Float)) and isinstance(v,(float, int))):
            return True
        if (t == str):
            return isinstance(v,str)
        isEnumType = (t == Enum)
        if ((isEnumType and python_lib_Inspect.isclass(v)) and hasattr(v,"_hx_constructs")):
            return True
        if isEnumType:
            return False
        isClassType = (t == Class)
        if ((((isClassType and (not isinstance(v,Enum))) and python_lib_Inspect.isclass(v)) and hasattr(v,"_hx_class_name")) and (not hasattr(v,"_hx_constructs"))):
            return True
        if isClassType:
            return False
        tmp3 = None
        try:
            tmp3 = isinstance(v,t)
        except Exception as _hx_e:
            _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
            e1 = _hx_e1
            tmp3 = False
        if tmp3:
            return True
        if python_lib_Inspect.isclass(t):
            loop = None
            def _hx_local_1(intf):
                f1 = (intf._hx_interfaces if (hasattr(intf,"_hx_interfaces")) else [])
                if (f1 is not None):
                    _g = 0
                    while (_g < len(f1)):
                        i = (f1[_g] if _g >= 0 and _g < len(f1) else None)
                        _g = (_g + 1)
                        if HxOverrides.eq(i,t):
                            return True
                        else:
                            l = loop(i)
                            if l:
                                return True
                    return False
                else:
                    return False
            loop = _hx_local_1
            currentClass = v.__class__
            while (currentClass is not None):
                if loop(currentClass):
                    return True
                currentClass = python_Boot.getSuperClass(currentClass)
            return False
        else:
            return False

    @staticmethod
    def string(s):
        return python_Boot.toString1(s,"")

    @staticmethod
    def parseInt(x):
        if (x is None):
            return None
        try:
            return int(x)
        except Exception as _hx_e:
            _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
            e = _hx_e1
            try:
                if (HxString.substr(x,0,2).lower() == "0x"):
                    return int(x,16)
                raise _HxException("fail")
            except Exception as _hx_e:
                _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                e1 = _hx_e1
                x1 = Std.parseFloat(x)
                r = None
                try:
                    r = int(x1)
                except Exception as _hx_e:
                    _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                    e2 = _hx_e1
                    r = None
                if (r is None):
                    r1 = Std.shortenPossibleNumber(x)
                    if (r1 != x):
                        return Std.parseInt(r1)
                    else:
                        return None
                return r

    @staticmethod
    def shortenPossibleNumber(x):
        r = ""
        _g = 0
        _g1 = len(x)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            c = ("" if (((i < 0) or ((i >= len(x))))) else x[i])
            _g2 = HxString.charCodeAt(c,0)
            if (_g2 is None):
                break
            elif (((((((((((_g2 == 57) or ((_g2 == 56))) or ((_g2 == 55))) or ((_g2 == 54))) or ((_g2 == 53))) or ((_g2 == 52))) or ((_g2 == 51))) or ((_g2 == 50))) or ((_g2 == 49))) or ((_g2 == 48))) or ((_g2 == 46))):
                r = (("null" if r is None else r) + ("null" if c is None else c))
            else:
                break
        return r

    @staticmethod
    def parseFloat(x):
        try:
            return float(x)
        except Exception as _hx_e:
            _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
            e = _hx_e1
            if (x is not None):
                r1 = Std.shortenPossibleNumber(x)
                if (r1 != x):
                    return Std.parseFloat(r1)
            return Math.NaN
Std._hx_class = Std
_hx_classes["Std"] = Std


class Dynamic: pass


class Bool: pass


class Int: pass


class Float: pass


class Class: pass


class HxString:
    _hx_class_name = "HxString"
    __slots__ = ()
    _hx_statics = ["split", "charCodeAt", "charAt", "lastIndexOf", "toUpperCase", "toLowerCase", "indexOf", "toString", "substring", "substr"]

    @staticmethod
    def split(s,d):
        if (d == ""):
            return list(s)
        else:
            return s.split(d)

    @staticmethod
    def charCodeAt(s,index):
        if ((((s is None) or ((len(s) == 0))) or ((index < 0))) or ((index >= len(s)))):
            return None
        else:
            return ord(s[index])

    @staticmethod
    def charAt(s,index):
        if ((index < 0) or ((index >= len(s)))):
            return ""
        else:
            return s[index]

    @staticmethod
    def lastIndexOf(s,_hx_str,startIndex = None):
        if (startIndex is None):
            return s.rfind(_hx_str, 0, len(s))
        else:
            i = s.rfind(_hx_str, 0, (startIndex + 1))
            startLeft = (max(0,((startIndex + 1) - len(_hx_str))) if ((i == -1)) else (i + 1))
            check = s.find(_hx_str, startLeft, len(s))
            if ((check > i) and ((check <= startIndex))):
                return check
            else:
                return i

    @staticmethod
    def toUpperCase(s):
        return s.upper()

    @staticmethod
    def toLowerCase(s):
        return s.lower()

    @staticmethod
    def indexOf(s,_hx_str,startIndex = None):
        if (startIndex is None):
            return s.find(_hx_str)
        else:
            return s.find(_hx_str, startIndex)

    @staticmethod
    def toString(s):
        return s

    @staticmethod
    def substring(s,startIndex,endIndex = None):
        if (startIndex < 0):
            startIndex = 0
        if (endIndex is None):
            return s[startIndex:]
        else:
            if (endIndex < 0):
                endIndex = 0
            if (endIndex < startIndex):
                return s[endIndex:startIndex]
            else:
                return s[startIndex:endIndex]

    @staticmethod
    def substr(s,startIndex,_hx_len = None):
        if (_hx_len is None):
            return s[startIndex:]
        else:
            if (_hx_len == 0):
                return ""
            if (startIndex < 0):
                startIndex = (len(s) + startIndex)
                if (startIndex < 0):
                    startIndex = 0
            return s[startIndex:(startIndex + _hx_len)]
HxString._hx_class = HxString
_hx_classes["HxString"] = HxString


class ANSI:
    _hx_class_name = "ANSI"
    __slots__ = ()
    _hx_statics = ["ESCAPE", "BELL", "CSI", "attr", "values", "set", "available", "strip", "stripIfUnavailable", "aset", "detectSupport", "title", "sequences", "showCursor", "setY", "setXY", "setX", "saveCursor", "resetY", "reset", "moveUpReset", "moveUp", "moveRight", "moveLeft", "moveDownReset", "moveDown", "loadCursor", "insertLines", "insertLine", "insertChars", "insertChar", "hideCursor", "eraseLineToEnd", "eraseLineToCursor", "eraseLine", "eraseDisplayToEnd", "eraseDisplayToCursor", "eraseDisplay", "eraseChars", "eraseChar", "deleteLines", "deleteLine", "deleteChars", "deleteChar"]

    @staticmethod
    def aset(attributes):
        if (ANSI.strip or ((ANSI.stripIfUnavailable and (not ANSI.available)))):
            return ""
        tmp = ("\x1B" + "[")
        _g = []
        _g1 = 0
        while (_g1 < len(attributes)):
            arg = (attributes[_g1] if _g1 >= 0 and _g1 < len(attributes) else None)
            _g1 = (_g1 + 1)
            if (not Std._hx_is(arg,Attribute)):
                raise _HxException(("Set argument is not an Attribute: " + Std.string(arg)))
            x = ANSI.values.get(arg)
            _g.append(x)
        return ((("null" if tmp is None else tmp) + HxOverrides.stringOrNull(";".join([python_Boot.toString1(x1,'') for x1 in _g]))) + "m")

    @staticmethod
    def detectSupport():
        if (Sys.systemName().lower().find("window") == -1):
            result = -1
            try:
                process = sys_io_Process("tput",["colors"])
                result = process.exitCode()
                process.close()
            except Exception as _hx_e:
                _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                pass
            return (result == 0)
        else:
            return (Sys.getEnv("ANSICON") is not None)

    @staticmethod
    def title(_hx_str):
        if (ANSI.strip or ((ANSI.stripIfUnavailable and (not ANSI.available)))):
            return ""
        return ((("\x1B" + "]0;") + ("null" if _hx_str is None else _hx_str)) + "\x07")

    @staticmethod
    def showCursor():
        if (ANSI.strip or ((ANSI.stripIfUnavailable and (not ANSI.available)))):
            return ""
        return "\x1B[?25h"

    @staticmethod
    def setY(num = 1):
        if (num is None):
            num = 1
        if (ANSI.strip or ((ANSI.stripIfUnavailable and (not ANSI.available)))):
            return ""
        return (("\x1B[" + Std.string(num)) + "d")

    @staticmethod
    def setXY(column,line):
        if (ANSI.strip or ((ANSI.stripIfUnavailable and (not ANSI.available)))):
            return ""
        return (((("\x1B[" + Std.string(line)) + ";") + Std.string(column)) + "H")

    @staticmethod
    def setX(num = 1):
        if (num is None):
            num = 1
        if (ANSI.strip or ((ANSI.stripIfUnavailable and (not ANSI.available)))):
            return ""
        return (("\x1B[" + Std.string(num)) + "G")

    @staticmethod
    def saveCursor():
        if (ANSI.strip or ((ANSI.stripIfUnavailable and (not ANSI.available)))):
            return ""
        return "\x1B[s"

    @staticmethod
    def resetY(num = 1):
        if (num is None):
            num = 1
        if (ANSI.strip or ((ANSI.stripIfUnavailable and (not ANSI.available)))):
            return ""
        return (("\x1B[" + Std.string(num)) + "H")

    @staticmethod
    def reset():
        if (ANSI.strip or ((ANSI.stripIfUnavailable and (not ANSI.available)))):
            return ""
        return "\x1B[H"

    @staticmethod
    def moveUpReset(num = 1):
        if (num is None):
            num = 1
        if (ANSI.strip or ((ANSI.stripIfUnavailable and (not ANSI.available)))):
            return ""
        return (("\x1B[" + Std.string(num)) + "F")

    @staticmethod
    def moveUp(num = 1):
        if (num is None):
            num = 1
        if (ANSI.strip or ((ANSI.stripIfUnavailable and (not ANSI.available)))):
            return ""
        return (("\x1B[" + Std.string(num)) + "A")

    @staticmethod
    def moveRight(num = 1):
        if (num is None):
            num = 1
        if (ANSI.strip or ((ANSI.stripIfUnavailable and (not ANSI.available)))):
            return ""
        return (("\x1B[" + Std.string(num)) + "C")

    @staticmethod
    def moveLeft(num = 1):
        if (num is None):
            num = 1
        if (ANSI.strip or ((ANSI.stripIfUnavailable and (not ANSI.available)))):
            return ""
        return (("\x1B[" + Std.string(num)) + "D")

    @staticmethod
    def moveDownReset(num = 1):
        if (num is None):
            num = 1
        if (ANSI.strip or ((ANSI.stripIfUnavailable and (not ANSI.available)))):
            return ""
        return (("\x1B[" + Std.string(num)) + "E")

    @staticmethod
    def moveDown(num = 1):
        if (num is None):
            num = 1
        if (ANSI.strip or ((ANSI.stripIfUnavailable and (not ANSI.available)))):
            return ""
        return (("\x1B[" + Std.string(num)) + "B")

    @staticmethod
    def loadCursor():
        if (ANSI.strip or ((ANSI.stripIfUnavailable and (not ANSI.available)))):
            return ""
        return "\x1B[u"

    @staticmethod
    def insertLines(num = 1):
        if (num is None):
            num = 1
        if (ANSI.strip or ((ANSI.stripIfUnavailable and (not ANSI.available)))):
            return ""
        return (("\x1B[" + Std.string(num)) + "L")

    @staticmethod
    def insertLine():
        if (ANSI.strip or ((ANSI.stripIfUnavailable and (not ANSI.available)))):
            return ""
        return "\x1B[L"

    @staticmethod
    def insertChars(num = 1):
        if (num is None):
            num = 1
        if (ANSI.strip or ((ANSI.stripIfUnavailable and (not ANSI.available)))):
            return ""
        return (("\x1B[" + Std.string(num)) + "@")

    @staticmethod
    def insertChar():
        if (ANSI.strip or ((ANSI.stripIfUnavailable and (not ANSI.available)))):
            return ""
        return "\x1B[@"

    @staticmethod
    def hideCursor():
        if (ANSI.strip or ((ANSI.stripIfUnavailable and (not ANSI.available)))):
            return ""
        return "\x1B[?25l"

    @staticmethod
    def eraseLineToEnd():
        if (ANSI.strip or ((ANSI.stripIfUnavailable and (not ANSI.available)))):
            return ""
        return "\x1B[K"

    @staticmethod
    def eraseLineToCursor():
        if (ANSI.strip or ((ANSI.stripIfUnavailable and (not ANSI.available)))):
            return ""
        return "\x1B[1K"

    @staticmethod
    def eraseLine():
        if (ANSI.strip or ((ANSI.stripIfUnavailable and (not ANSI.available)))):
            return ""
        return "\x1B[2K"

    @staticmethod
    def eraseDisplayToEnd():
        if (ANSI.strip or ((ANSI.stripIfUnavailable and (not ANSI.available)))):
            return ""
        return "\x1B[J"

    @staticmethod
    def eraseDisplayToCursor():
        if (ANSI.strip or ((ANSI.stripIfUnavailable and (not ANSI.available)))):
            return ""
        return "\x1B[1J"

    @staticmethod
    def eraseDisplay():
        if (ANSI.strip or ((ANSI.stripIfUnavailable and (not ANSI.available)))):
            return ""
        return "\x1B[2J"

    @staticmethod
    def eraseChars(num = 1):
        if (num is None):
            num = 1
        if (ANSI.strip or ((ANSI.stripIfUnavailable and (not ANSI.available)))):
            return ""
        return (("\x1B[" + Std.string(num)) + "X")

    @staticmethod
    def eraseChar():
        if (ANSI.strip or ((ANSI.stripIfUnavailable and (not ANSI.available)))):
            return ""
        return "\x1B[X"

    @staticmethod
    def deleteLines(num = 1):
        if (num is None):
            num = 1
        if (ANSI.strip or ((ANSI.stripIfUnavailable and (not ANSI.available)))):
            return ""
        return (("\x1B[" + Std.string(num)) + "M")

    @staticmethod
    def deleteLine():
        if (ANSI.strip or ((ANSI.stripIfUnavailable and (not ANSI.available)))):
            return ""
        return "\x1B[M"

    @staticmethod
    def deleteChars(num = 1):
        if (num is None):
            num = 1
        if (ANSI.strip or ((ANSI.stripIfUnavailable and (not ANSI.available)))):
            return ""
        return (("\x1B[" + Std.string(num)) + "P")

    @staticmethod
    def deleteChar():
        if (ANSI.strip or ((ANSI.stripIfUnavailable and (not ANSI.available)))):
            return ""
        return "\x1B[P"
ANSI._hx_class = ANSI
_hx_classes["ANSI"] = ANSI


class Date:
    _hx_class_name = "Date"
    __slots__ = ("date",)
    _hx_fields = ["date"]
    _hx_methods = ["toString"]
    _hx_statics = ["fromTime", "fromString"]

    def __init__(self,year,month,day,hour,_hx_min,sec):
        if (year < python_lib_datetime_Datetime.min.year):
            year = python_lib_datetime_Datetime.min.year
        if (day == 0):
            day = 1
        self.date = python_lib_datetime_Datetime(year,(month + 1),day,hour,_hx_min,sec,0)

    def toString(self):
        m = ((self.date.month - 1) + 1)
        d = self.date.day
        h = self.date.hour
        mi = self.date.minute
        s = self.date.second
        return ((((((((((Std.string(self.date.year) + "-") + HxOverrides.stringOrNull(((("0" + Std.string(m)) if ((m < 10)) else ("" + Std.string(m)))))) + "-") + HxOverrides.stringOrNull(((("0" + Std.string(d)) if ((d < 10)) else ("" + Std.string(d)))))) + " ") + HxOverrides.stringOrNull(((("0" + Std.string(h)) if ((h < 10)) else ("" + Std.string(h)))))) + ":") + HxOverrides.stringOrNull(((("0" + Std.string(mi)) if ((mi < 10)) else ("" + Std.string(mi)))))) + ":") + HxOverrides.stringOrNull(((("0" + Std.string(s)) if ((s < 10)) else ("" + Std.string(s))))))

    @staticmethod
    def fromTime(t):
        d = Date(1970,0,1,0,0,0)
        d.date = python_lib_datetime_Datetime.fromtimestamp((t / 1000.0))
        return d

    @staticmethod
    def fromString(s):
        _g = len(s)
        if (_g == 8):
            k = s.split(":")
            return Date(0,0,0,Std.parseInt((k[0] if 0 < len(k) else None)),Std.parseInt((k[1] if 1 < len(k) else None)),Std.parseInt((k[2] if 2 < len(k) else None)))
        elif (_g == 10):
            k1 = s.split("-")
            return Date(Std.parseInt((k1[0] if 0 < len(k1) else None)),(Std.parseInt((k1[1] if 1 < len(k1) else None)) - 1),Std.parseInt((k1[2] if 2 < len(k1) else None)),0,0,0)
        elif (_g == 19):
            k2 = s.split(" ")
            y = (k2[0] if 0 < len(k2) else None).split("-")
            t = (k2[1] if 1 < len(k2) else None).split(":")
            return Date(Std.parseInt((y[0] if 0 < len(y) else None)),(Std.parseInt((y[1] if 1 < len(y) else None)) - 1),Std.parseInt((y[2] if 2 < len(y) else None)),Std.parseInt((t[0] if 0 < len(t) else None)),Std.parseInt((t[1] if 1 < len(t) else None)),Std.parseInt((t[2] if 2 < len(t) else None)))
        else:
            raise _HxException(("Invalid date format : " + ("null" if s is None else s)))

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.date = None
Date._hx_class = Date
_hx_classes["Date"] = Date


class EReg:
    _hx_class_name = "EReg"
    __slots__ = ("pattern", "matchObj", "_hx_global")
    _hx_fields = ["pattern", "matchObj", "global"]

    def __init__(self,r,opt):
        self.matchObj = None
        self._hx_global = False
        options = 0
        _g = 0
        _g1 = len(opt)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            c = (-1 if ((i >= len(opt))) else ord(opt[i]))
            if (c == 109):
                options = (options | python_lib_Re.M)
            if (c == 105):
                options = (options | python_lib_Re.I)
            if (c == 115):
                options = (options | python_lib_Re.S)
            if (c == 117):
                options = (options | python_lib_Re.U)
            if (c == 103):
                self._hx_global = True
        self.pattern = python_lib_Re.compile(r,options)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.pattern = None
        _hx_o.matchObj = None
        _hx_o._hx_global = None
EReg._hx_class = EReg
_hx_classes["EReg"] = EReg


class Lambda:
    _hx_class_name = "Lambda"
    __slots__ = ()
    _hx_statics = ["array", "exists", "iter", "filter", "fold", "count"]

    @staticmethod
    def array(it):
        a = list()
        i = HxOverrides.iterator(it)
        while i.hasNext():
            i1 = i.next()
            a.append(i1)
        return a

    @staticmethod
    def exists(it,f):
        x = HxOverrides.iterator(it)
        while x.hasNext():
            if f(x.next()):
                return True
        return False

    @staticmethod
    def iter(it,f):
        x = HxOverrides.iterator(it)
        while x.hasNext():
            f(x.next())

    @staticmethod
    def filter(it,f):
        _g = []
        x = HxOverrides.iterator(it)
        while x.hasNext():
            x1 = x.next()
            if f(x1):
                _g.append(x1)
        return _g

    @staticmethod
    def fold(it,f,first):
        x = HxOverrides.iterator(it)
        while x.hasNext():
            first = f(x.next(),first)
        return first

    @staticmethod
    def count(it,pred = None):
        n = 0
        if (pred is None):
            _ = HxOverrides.iterator(it)
            while _.hasNext():
                _.next()
                n = (n + 1)
        else:
            x = HxOverrides.iterator(it)
            while x.hasNext():
                if pred(x.next()):
                    n = (n + 1)
        return n
Lambda._hx_class = Lambda
_hx_classes["Lambda"] = Lambda


class Main:
    _hx_class_name = "Main"
    __slots__ = ()
    _hx_statics = ["main"]

    @staticmethod
    def main():
        def _hx_local_0():
            tink_testrunner_Runner.run([tink_unit_TestSuiteBuilder0(TestStorage(),None)]).handle(tink_testrunner_Runner.exit)
        tink_RunLoop.create(_hx_local_0)
Main._hx_class = Main
_hx_classes["Main"] = Main


class TestStorage:
    _hx_class_name = "TestStorage"
    __slots__ = ()
    _hx_methods = ["test_create", "request", "test_http"]

    def __init__(self):
        pass

    def test_create(self,count,asserts):
        hxd_sys_Engine.start(_hx_AnonObject({'path': "test"}))
        book = hxd_storage_Book.open("test")
        def _hx_local_0(s):
            return haxe_zip_Compress.run(s,1)
        def _hx_local_1(src):
            return haxe_zip_Uncompress.run(src,None)
        book.addStoragePlan(_hx_local_0,_hx_local_1)
        _g = []
        _g1 = 0
        _g2 = count
        while (_g1 < _g2):
            _g1 = (_g1 + 1)
            x = hxd_storage_Record("DATA HERE")
            _g.append(x)
        expecting = 0
        log = []
        hits = 0
        sum = 0
        def _hx_local_10(result):
            nonlocal sum
            nonlocal hits
            nonlocal expecting
            handler = result.index
            if (handler == 0):
                records = result.params[1]
                hits = (hits + 1)
                x1 = _hx_AnonObject({'page': result.params[0].number, 'count': len(records)})
                log.append(x1)
                sum = (sum + len(records))
            elif (handler == 1):
                expecting = result.params[0]
            else:
                pass
            return tink_core__Future_SyncFuture(tink_core__Lazy_LazyConst(tink_streams_Handled.Resume))
        def _hx_local_7(result1):
            def _hx_local_6():
                def _hx_local_5():
                    def _hx_local_4():
                        def _hx_local_3(total):
                            lh = book.calculatePadding().percentage
                            data = tink_streams_Yield.Data(tink_testrunner_Assertion(tink_testrunner__Assertion_AssertionResult_Impl_.ofBool((lh < 0.3)),((((((("padding.percentage < 0.3" + " (") + HxOverrides.stringOrNull(tink_unit_Assert.stringify(lh))) + " ") + "<") + " ") + HxOverrides.stringOrNull(tink_unit_Assert.stringify(0.3))) + ")"),_hx_AnonObject({'fileName': "src/Main.hx", 'lineNumber': 63, 'className': "TestStorage", 'methodName': "test_create"})))
                            tink_core__Callback_CallbackList_Impl_.invoke(asserts.trigger.handlers,data)
                            lh1 = result1
                            rh = tink_streams_Conclusion.Depleted
                            data1 = tink_streams_Yield.Data(tink_testrunner_Assertion(tink_testrunner__Assertion_AssertionResult_Impl_.ofBool((lh1 == rh)),((((((("result == Depleted" + " (") + HxOverrides.stringOrNull(tink_unit_Assert.stringify(lh1))) + " ") + "==") + " ") + HxOverrides.stringOrNull(tink_unit_Assert.stringify(rh))) + ")"),_hx_AnonObject({'fileName': "src/Main.hx", 'lineNumber': 64, 'className': "TestStorage", 'methodName': "test_create"})))
                            tink_core__Callback_CallbackList_Impl_.invoke(asserts.trigger.handlers,data1)
                            rh1 = count
                            data2 = tink_streams_Yield.Data(tink_testrunner_Assertion(tink_testrunner__Assertion_AssertionResult_Impl_.ofBool((total == rh1)),((((((("total == count" + " (") + HxOverrides.stringOrNull(tink_unit_Assert.stringify(total))) + " ") + "==") + " ") + HxOverrides.stringOrNull(tink_unit_Assert.stringify(rh1))) + ")"),_hx_AnonObject({'fileName': "src/Main.hx", 'lineNumber': 65, 'className': "TestStorage", 'methodName': "test_create"})))
                            tink_core__Callback_CallbackList_Impl_.invoke(asserts.trigger.handlers,data2)
                            lh2 = sum
                            data3 = tink_streams_Yield.Data(tink_testrunner_Assertion(tink_testrunner__Assertion_AssertionResult_Impl_.ofBool((lh2 == total)),((((((("sum == total" + " (") + HxOverrides.stringOrNull(tink_unit_Assert.stringify(lh2))) + " ") + "==") + " ") + HxOverrides.stringOrNull(tink_unit_Assert.stringify(total))) + ")"),_hx_AnonObject({'fileName': "src/Main.hx", 'lineNumber': 66, 'className': "TestStorage", 'methodName': "test_create"})))
                            tink_core__Callback_CallbackList_Impl_.invoke(asserts.trigger.handlers,data3)
                            tink_core__Callback_CallbackList_Impl_.invoke(asserts.trigger.handlers,tink_streams_Yield.End)
                            return asserts
                        return book.count().handle(_hx_local_3)
                    return _hx_local_4()
                return book.commit().handle(tink_core__Callback_Callback_Impl_.fromNiladic(_hx_local_5))
            return _hx_local_6()
        book.create(_g).forEach(tink_streams__Stream_Handler_Impl_.ofSafe(_hx_local_10)).handle(_hx_local_7)
        return asserts

    def request(self,count):
        done = tink_core_FutureTrigger()
        http = sys_Http(("https://randomuser.me/api?results=" + Std.string(count)))
        haxe_Log.trace("Getting random users",_hx_AnonObject({'fileName': "src/Main.hx", 'lineNumber': 78, 'className': "TestStorage", 'methodName': "request"}))
        def _hx_local_0(d):
            tmp = tink_core_Outcome.Success(python_lib_Json.loads(d,**python__KwArgs_KwArgs_Impl_.fromT(_hx_AnonObject({'object_hook': python_Lib.dictToAnon}))))
            done.trigger(tmp)
        http.onData = _hx_local_0
        def _hx_local_1(e):
            done.trigger(tink_core_Outcome.Failure(e))
        http.onError = _hx_local_1
        http.request(False)
        return done.map(tink_core_Outcome.Success).gather()

    def test_http(self,count,apiHits,asserts):
        _g = []
        _g1 = 0
        _g2 = apiHits
        while (_g1 < _g2):
            _g1 = (_g1 + 1)
            x = self.request(count)
            _g.append(x)
        def _hx_local_12(results):
            if (results.index == 0):
                randomUsers = results.params[0]
                hxd_sys_Engine.start(_hx_AnonObject({'path': "http"}))
                book = hxd_storage_Book.open("randomuser.me")
                def _hx_local_11(initialCount):
                    def _hx_local_2(val,aggregate):
                        if (val.index == 0):
                            def _hx_local_1(random):
                                return hxd_storage_Record(random)
                            aggregate = (aggregate + HxOverrides.map(val.params[0].results, _hx_local_1))
                        return aggregate
                    records = Lambda.fold(randomUsers,_hx_local_2,[])
                    expecting = 0
                    log = []
                    hits = 0
                    def _hx_local_10():
                        def _hx_local_9(result):
                            nonlocal expecting
                            nonlocal hits
                            handler = result.index
                            if (handler == 0):
                                hits = (hits + 1)
                                x1 = _hx_AnonObject({'page': result.params[0].number, 'count': len(result.params[1])})
                                log.append(x1)
                            elif (handler == 1):
                                expecting = result.params[0]
                            else:
                                pass
                            return tink_core__Future_SyncFuture(tink_core__Lazy_LazyConst(tink_streams_Handled.Resume))
                        def _hx_local_7(result1):
                            def _hx_local_6():
                                def _hx_local_5():
                                    def _hx_local_4():
                                        def _hx_local_3(total):
                                            padding = book.calculatePadding()
                                            lh = padding.percentage
                                            data = tink_streams_Yield.Data(tink_testrunner_Assertion(tink_testrunner__Assertion_AssertionResult_Impl_.ofBool((lh < 0.3)),((((((("padding.percentage < 0.3" + " (") + HxOverrides.stringOrNull(tink_unit_Assert.stringify(lh))) + " ") + "<") + " ") + HxOverrides.stringOrNull(tink_unit_Assert.stringify(0.3))) + ")"),_hx_AnonObject({'fileName': "src/Main.hx", 'lineNumber': 137, 'className': "TestStorage", 'methodName': "test_http"})))
                                            tink_core__Callback_CallbackList_Impl_.invoke(asserts.trigger.handlers,data)
                                            lh1 = result1
                                            rh = tink_streams_Conclusion.Depleted
                                            data1 = tink_streams_Yield.Data(tink_testrunner_Assertion(tink_testrunner__Assertion_AssertionResult_Impl_.ofBool((lh1 == rh)),((((((("result == Depleted" + " (") + HxOverrides.stringOrNull(tink_unit_Assert.stringify(lh1))) + " ") + "==") + " ") + HxOverrides.stringOrNull(tink_unit_Assert.stringify(rh))) + ")"),_hx_AnonObject({'fileName': "src/Main.hx", 'lineNumber': 138, 'className': "TestStorage", 'methodName': "test_http"})))
                                            tink_core__Callback_CallbackList_Impl_.invoke(asserts.trigger.handlers,data1)
                                            lh2 = (initialCount + ((count * apiHits)))
                                            data2 = tink_streams_Yield.Data(tink_testrunner_Assertion(tink_testrunner__Assertion_AssertionResult_Impl_.ofBool((lh2 == total)),((((((("initialCount + (count * apiHits) == total" + " (") + HxOverrides.stringOrNull(tink_unit_Assert.stringify(lh2))) + " ") + "==") + " ") + HxOverrides.stringOrNull(tink_unit_Assert.stringify(total))) + ")"),_hx_AnonObject({'fileName': "src/Main.hx", 'lineNumber': 139, 'className': "TestStorage", 'methodName': "test_http"})))
                                            tink_core__Callback_CallbackList_Impl_.invoke(asserts.trigger.handlers,data2)
                                            haxe_Log.trace(padding,_hx_AnonObject({'fileName': "src/Main.hx", 'lineNumber': 140, 'className': "TestStorage", 'methodName': "test_http"}))
                                            tink_core__Callback_CallbackList_Impl_.invoke(asserts.trigger.handlers,tink_streams_Yield.End)
                                            return asserts
                                        return book.count().handle(_hx_local_3)
                                    return _hx_local_4()
                                return book.commit().handle(tink_core__Callback_Callback_Impl_.fromNiladic(_hx_local_5))
                            return _hx_local_6()
                        return book.create(records).forEach(tink_streams__Stream_Handler_Impl_.ofSafe(_hx_local_9)).handle(_hx_local_7)
                    return _hx_local_10()
                book.count().handle(_hx_local_11)
            return tink_core_Noise.Noise
        tink_core__Promise_Promise_Impl_.inParallel(_g).handle(_hx_local_12)
        return asserts

    @staticmethod
    def _hx_empty_init(_hx_o):        pass
TestStorage._hx_class = TestStorage
_hx_classes["TestStorage"] = TestStorage


class TestStream:
    _hx_class_name = "TestStream"
    __slots__ = ()
    _hx_methods = ["test", "test_pass_stream", "get_stream", "test_unclog"]

    def __init__(self):
        pass

    def test(self,asserts):
        done = False
        a = tink_core__Signal_Signal_Impl_.trigger()
        stream = tink_streams_SignalStream(a)
        tink_core__Callback_CallbackList_Impl_.invoke(a.handlers,tink_streams_Yield.Data(1))
        tink_core__Callback_CallbackList_Impl_.invoke(a.handlers,tink_streams_Yield.Data(2))
        tink_core__Callback_CallbackList_Impl_.invoke(a.handlers,tink_streams_Yield.Data(3))
        i = 0
        sum = 0
        def _hx_local_3(v):
            nonlocal sum
            def _hx_local_1():
                nonlocal i
                i = (i + 1)
                return i
            lh = _hx_local_1()
            data = tink_streams_Yield.Data(tink_testrunner_Assertion(tink_testrunner__Assertion_AssertionResult_Impl_.ofBool((lh == v)),((((((("++i == v" + " (") + HxOverrides.stringOrNull(tink_unit_Assert.stringify(lh))) + " ") + "==") + " ") + HxOverrides.stringOrNull(tink_unit_Assert.stringify(v))) + ")"),_hx_AnonObject({'fileName': "src/Main.hx", 'lineNumber': 172, 'className': "TestStream", 'methodName': "test"})))
            tink_core__Callback_CallbackList_Impl_.invoke(asserts.trigger.handlers,data)
            sum = (sum + v)
            return tink_core__Future_SyncFuture(tink_core__Lazy_LazyConst(tink_streams_Handled.Resume))
        result = stream.forEach(tink_streams__Stream_Handler_Impl_.ofSafe(_hx_local_3))
        tink_core__Callback_CallbackList_Impl_.invoke(a.handlers,tink_streams_Yield.Data(4))
        tink_core__Callback_CallbackList_Impl_.invoke(a.handlers,tink_streams_Yield.Data(5))
        tink_core__Callback_CallbackList_Impl_.invoke(a.handlers,tink_streams_Yield.End)
        tink_core__Callback_CallbackList_Impl_.invoke(a.handlers,tink_streams_Yield.Data(6))
        tink_core__Callback_CallbackList_Impl_.invoke(a.handlers,tink_streams_Yield.Data(7))
        def _hx_local_4(x):
            lh1 = tink_streams_Conclusion.Depleted
            data1 = tink_streams_Yield.Data(tink_testrunner_Assertion(tink_testrunner__Assertion_AssertionResult_Impl_.ofBool((lh1 == x)),((((((("Depleted == x" + " (") + HxOverrides.stringOrNull(tink_unit_Assert.stringify(lh1))) + " ") + "==") + " ") + HxOverrides.stringOrNull(tink_unit_Assert.stringify(x))) + ")"),_hx_AnonObject({'fileName': "src/Main.hx", 'lineNumber': 184, 'className': "TestStream", 'methodName': "test"})))
            tink_core__Callback_CallbackList_Impl_.invoke(asserts.trigger.handlers,data1)
            rh = sum
            data2 = tink_streams_Yield.Data(tink_testrunner_Assertion(tink_testrunner__Assertion_AssertionResult_Impl_.ofBool((15 == rh)),((((((("15 == sum" + " (") + HxOverrides.stringOrNull(tink_unit_Assert.stringify(15))) + " ") + "==") + " ") + HxOverrides.stringOrNull(tink_unit_Assert.stringify(rh))) + ")"),_hx_AnonObject({'fileName': "src/Main.hx", 'lineNumber': 185, 'className': "TestStream", 'methodName': "test"})))
            tink_core__Callback_CallbackList_Impl_.invoke(asserts.trigger.handlers,data2)
            return
        result.handle(_hx_local_4)
        def _hx_local_6(v1):
            nonlocal sum
            sum = (sum + v1)
            haxe_Log.trace(((("sum: " + Std.string(sum)) + ", ") + Std.string(v1)),_hx_AnonObject({'fileName': "src/Main.hx", 'lineNumber': 189, 'className': "TestStream", 'methodName': "test"}))
            return tink_core__Future_SyncFuture(tink_core__Lazy_LazyConst(tink_streams_Handled.Resume))
        nextResult = stream.forEach(tink_streams__Stream_Handler_Impl_.ofSafe(_hx_local_6))
        tink_core__Callback_CallbackList_Impl_.invoke(a.handlers,tink_streams_Yield.End)
        def _hx_local_7(x1):
            nonlocal done
            lh2 = tink_streams_Conclusion.Depleted
            data3 = tink_streams_Yield.Data(tink_testrunner_Assertion(tink_testrunner__Assertion_AssertionResult_Impl_.ofBool((lh2 == x1)),((((((("Depleted == x" + " (") + HxOverrides.stringOrNull(tink_unit_Assert.stringify(lh2))) + " ") + "==") + " ") + HxOverrides.stringOrNull(tink_unit_Assert.stringify(x1))) + ")"),_hx_AnonObject({'fileName': "src/Main.hx", 'lineNumber': 194, 'className': "TestStream", 'methodName': "test"})))
            tink_core__Callback_CallbackList_Impl_.invoke(asserts.trigger.handlers,data3)
            rh1 = sum
            data4 = tink_streams_Yield.Data(tink_testrunner_Assertion(tink_testrunner__Assertion_AssertionResult_Impl_.ofBool((30 == rh1)),((((((("30 == sum" + " (") + HxOverrides.stringOrNull(tink_unit_Assert.stringify(30))) + " ") + "==") + " ") + HxOverrides.stringOrNull(tink_unit_Assert.stringify(rh1))) + ")"),_hx_AnonObject({'fileName': "src/Main.hx", 'lineNumber': 195, 'className': "TestStream", 'methodName': "test"})))
            tink_core__Callback_CallbackList_Impl_.invoke(asserts.trigger.handlers,data4)
            done = True
            return done
        nextResult.handle(_hx_local_7)
        data5 = tink_streams_Yield.Data(tink_testrunner_Assertion(tink_testrunner__Assertion_AssertionResult_Impl_.ofBool(done),"done",_hx_AnonObject({'fileName': "src/Main.hx", 'lineNumber': 198, 'className': "TestStream", 'methodName': "test"})))
        tink_core__Callback_CallbackList_Impl_.invoke(asserts.trigger.handlers,data5)
        tink_core__Callback_CallbackList_Impl_.invoke(asserts.trigger.handlers,tink_streams_Yield.End)
        return asserts

    def test_pass_stream(self,asserts):
        sum = 0
        def _hx_local_2(v):
            nonlocal sum
            sum = (sum + v)
            return tink_core__Future_SyncFuture(tink_core__Lazy_LazyConst(tink_streams_Handled.Resume))
        def _hx_local_0(handled):
            lh = (sum == 15)
            rh = (handled == tink_streams_Conclusion.Depleted)
            data = tink_streams_Yield.Data(tink_testrunner_Assertion(tink_testrunner__Assertion_AssertionResult_Impl_.ofBool((lh and rh)),((((((("sum == 15 && handled == Depleted" + " (") + HxOverrides.stringOrNull(tink_unit_Assert.stringify(lh))) + " ") + "&&") + " ") + HxOverrides.stringOrNull(tink_unit_Assert.stringify(rh))) + ")"),_hx_AnonObject({'fileName': "src/Main.hx", 'lineNumber': 210, 'className': "TestStream", 'methodName': "test_pass_stream"})))
            tink_core__Callback_CallbackList_Impl_.invoke(asserts.trigger.handlers,data)
            tink_core__Callback_CallbackList_Impl_.invoke(asserts.trigger.handlers,tink_streams_Yield.End)
            return asserts
        self.get_stream().forEach(tink_streams__Stream_Handler_Impl_.ofSafe(_hx_local_2)).handle(_hx_local_0)
        return asserts

    def get_stream(self):
        a = tink_core__Signal_Signal_Impl_.trigger()
        stream = tink_streams_SignalStream(a)
        tink_core__Callback_CallbackList_Impl_.invoke(a.handlers,tink_streams_Yield.Data(1))
        tink_core__Callback_CallbackList_Impl_.invoke(a.handlers,tink_streams_Yield.Data(2))
        tink_core__Callback_CallbackList_Impl_.invoke(a.handlers,tink_streams_Yield.Data(3))
        tink_core__Callback_CallbackList_Impl_.invoke(a.handlers,tink_streams_Yield.Data(4))
        tink_core__Callback_CallbackList_Impl_.invoke(a.handlers,tink_streams_Yield.Data(5))
        tink_core__Callback_CallbackList_Impl_.invoke(a.handlers,tink_streams_Yield.End)
        return stream

    def test_unclog(self,asserts):
        a = tink_core__Signal_Signal_Impl_.trigger()
        stream = tink_streams_SignalStream(a)
        aggregate = []
        tink_core__Callback_CallbackList_Impl_.invoke(a.handlers,tink_streams_Yield.Data(1))
        tink_core__Callback_CallbackList_Impl_.invoke(a.handlers,tink_streams_Yield.Data(2))
        tink_core__Callback_CallbackList_Impl_.invoke(a.handlers,tink_streams_Yield.Data(-1))
        tink_core__Callback_CallbackList_Impl_.invoke(a.handlers,tink_streams_Yield.Data(3))
        tink_core__Callback_CallbackList_Impl_.invoke(a.handlers,tink_streams_Yield.Data(4))
        tink_core__Callback_CallbackList_Impl_.invoke(a.handlers,tink_streams_Yield.End)
        def _hx_local_0(result):
            try:
                if (result == -1):
                    raise _HxException(tink_core_TypedError(500,"Can't perform operation on -1",_hx_AnonObject({'fileName': "src/Main.hx", 'lineNumber': 241, 'className': "TestStream", 'methodName': "test_unclog"})))
                aggregate.append(result)
                return tink_core__Future_SyncFuture(tink_core__Lazy_LazyConst(tink_streams_Handled.Resume))
            except Exception as _hx_e:
                _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                if isinstance(_hx_e1, tink_core_TypedError):
                    e = _hx_e1
                    return tink_core__Future_SyncFuture(tink_core__Lazy_LazyConst(tink_streams_Handled.Clog(e)))
                else:
                    raise _hx_e
        f = tink_streams__Stream_Handler_Impl_.ofUnknown(_hx_local_0)
        def _hx_local_1(result1):
            aggregate.append(result1)
            return tink_core__Future_SyncFuture(tink_core__Lazy_LazyConst(tink_streams_Handled.Resume))
        f2 = tink_streams__Stream_Handler_Impl_.ofUnknown(_hx_local_1)
        def _hx_local_4(conclusion):
            tmp = conclusion.index
            if (tmp == 1):
                haxe_Log.trace((("Threw " + Std.string(conclusion.params[0])) + ", resuming"),_hx_AnonObject({'fileName': "src/Main.hx", 'lineNumber': 256, 'className': "TestStream", 'methodName': "test_unclog"}))
                def _hx_local_3(conclusion1):
                    if (conclusion1.index == 3):
                        haxe_Log.trace("Done",_hx_AnonObject({'fileName': "src/Main.hx", 'lineNumber': 260, 'className': "TestStream", 'methodName': "test_unclog"}))
                        expected = [1, 2, -1, 3, 4]
                        _g = 0
                        while (_g < len(aggregate)):
                            i = (aggregate[_g] if _g >= 0 and _g < len(aggregate) else None)
                            _g = (_g + 1)
                            rh = python_internal_ArrayImpl._get(expected, python_internal_ArrayImpl.indexOf(aggregate,i,None))
                            data = tink_streams_Yield.Data(tink_testrunner_Assertion(tink_testrunner__Assertion_AssertionResult_Impl_.ofBool((i == rh)),((((((("i == expected[aggregate.indexOf(i)]" + " (") + HxOverrides.stringOrNull(tink_unit_Assert.stringify(i))) + " ") + "==") + " ") + HxOverrides.stringOrNull(tink_unit_Assert.stringify(rh))) + ")"),_hx_AnonObject({'fileName': "src/Main.hx", 'lineNumber': 263, 'className': "TestStream", 'methodName': "test_unclog"})))
                            tink_core__Callback_CallbackList_Impl_.invoke(asserts.trigger.handlers,data)
                        tink_core__Callback_CallbackList_Impl_.invoke(asserts.trigger.handlers,tink_streams_Yield.End)
                    return tink_core_Noise.Noise
                conclusion.params[1].forEach(f2).handle(_hx_local_3)
            elif (tmp == 3):
                tink_core__Callback_CallbackList_Impl_.invoke(asserts.trigger.handlers,tink_streams_Yield.End)
            else:
                pass
            return tink_core_Noise.Noise
        stream.forEach(f).handle(_hx_local_4)
        return asserts

    @staticmethod
    def _hx_empty_init(_hx_o):        pass
TestStream._hx_class = TestStream
_hx_classes["TestStream"] = TestStream


class StringBuf:
    _hx_class_name = "StringBuf"
    __slots__ = ("b",)
    _hx_fields = ["b"]
    _hx_methods = ["get_length"]

    def __init__(self):
        self.b = python_lib_io_StringIO()

    def get_length(self):
        pos = self.b.tell()
        self.b.seek(0,2)
        _hx_len = self.b.tell()
        self.b.seek(pos,0)
        return _hx_len

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.b = None
StringBuf._hx_class = StringBuf
_hx_classes["StringBuf"] = StringBuf


class StringTools:
    _hx_class_name = "StringTools"
    __slots__ = ()
    _hx_statics = ["isSpace", "ltrim", "rtrim", "lpad"]

    @staticmethod
    def isSpace(s,pos):
        if (((len(s) == 0) or ((pos < 0))) or ((pos >= len(s)))):
            return False
        c = HxString.charCodeAt(s,pos)
        if (not (((c > 8) and ((c < 14))))):
            return (c == 32)
        else:
            return True

    @staticmethod
    def ltrim(s):
        l = len(s)
        r = 0
        while ((r < l) and StringTools.isSpace(s,r)):
            r = (r + 1)
        if (r > 0):
            return HxString.substr(s,r,(l - r))
        else:
            return s

    @staticmethod
    def rtrim(s):
        l = len(s)
        r = 0
        while ((r < l) and StringTools.isSpace(s,((l - r) - 1))):
            r = (r + 1)
        if (r > 0):
            return HxString.substr(s,0,(l - r))
        else:
            return s

    @staticmethod
    def lpad(s,c,l):
        if (len(c) <= 0):
            return s
        buf = StringBuf()
        l = (l - len(s))
        while (buf.get_length() < l):
            s1 = Std.string(c)
            buf.b.write(s1)
        s2 = Std.string(s)
        buf.b.write(s2)
        return buf.b.getvalue()
StringTools._hx_class = StringTools
_hx_classes["StringTools"] = StringTools

class ValueType(Enum):
    __slots__ = ()
    _hx_class_name = "ValueType"
    _hx_constructs = ["TNull", "TInt", "TFloat", "TBool", "TObject", "TFunction", "TClass", "TEnum", "TUnknown"]

    @staticmethod
    def TClass(c):
        return ValueType("TClass", 6, [c])

    @staticmethod
    def TEnum(e):
        return ValueType("TEnum", 7, [e])
ValueType.TNull = ValueType("TNull", 0, list())
ValueType.TInt = ValueType("TInt", 1, list())
ValueType.TFloat = ValueType("TFloat", 2, list())
ValueType.TBool = ValueType("TBool", 3, list())
ValueType.TObject = ValueType("TObject", 4, list())
ValueType.TFunction = ValueType("TFunction", 5, list())
ValueType.TUnknown = ValueType("TUnknown", 8, list())
ValueType._hx_class = ValueType
_hx_classes["ValueType"] = ValueType


class Type:
    _hx_class_name = "Type"
    __slots__ = ()
    _hx_statics = ["getClass", "getSuperClass", "getClassName", "getEnumName", "resolveClass", "resolveEnum", "createEmptyInstance", "createEnum", "getEnumConstructs", "typeof"]

    @staticmethod
    def getClass(o):
        if (o is None):
            return None
        o1 = o
        if ((o1 is not None) and ((HxOverrides.eq(o1,str) or python_lib_Inspect.isclass(o1)))):
            return None
        if isinstance(o,_hx_AnonObject):
            return None
        if hasattr(o,"_hx_class"):
            return o._hx_class
        if hasattr(o,"__class__"):
            return o.__class__
        else:
            return None

    @staticmethod
    def getSuperClass(c):
        return python_Boot.getSuperClass(c)

    @staticmethod
    def getClassName(c):
        if hasattr(c,"_hx_class_name"):
            return c._hx_class_name
        else:
            if (c == list):
                return "Array"
            if (c == Math):
                return "Math"
            if (c == str):
                return "String"
            try:
                return c.__name__
            except Exception as _hx_e:
                _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                e = _hx_e1
                return None

    @staticmethod
    def getEnumName(e):
        return e._hx_class_name

    @staticmethod
    def resolveClass(name):
        if (name == "Array"):
            return list
        if (name == "Math"):
            return Math
        if (name == "String"):
            return str
        cl = _hx_classes.get(name,None)
        tmp = None
        if (cl is not None):
            o = cl
            tmp = (not (((o is not None) and ((HxOverrides.eq(o,str) or python_lib_Inspect.isclass(o))))))
        else:
            tmp = True
        if tmp:
            return None
        return cl

    @staticmethod
    def resolveEnum(name):
        if (name == "Bool"):
            return Bool
        o = Type.resolveClass(name)
        if hasattr(o,"_hx_constructs"):
            return o
        else:
            return None

    @staticmethod
    def createEmptyInstance(cl):
        i = cl.__new__(cl)
        callInit = None
        def _hx_local_0(cl1):
            sc = Type.getSuperClass(cl1)
            if (sc is not None):
                callInit(sc)
            if hasattr(cl1,"_hx_empty_init"):
                cl1._hx_empty_init(i)
        callInit = _hx_local_0
        callInit(cl)
        return i

    @staticmethod
    def createEnum(e,constr,params = None):
        f = Reflect.field(e,constr)
        if (f is None):
            raise _HxException(("No such constructor " + ("null" if constr is None else constr)))
        if Reflect.isFunction(f):
            if (params is None):
                raise _HxException((("Constructor " + ("null" if constr is None else constr)) + " need parameters"))
            return Reflect.callMethod(e,f,params)
        if ((params is not None) and ((len(params) != 0))):
            raise _HxException((("Constructor " + ("null" if constr is None else constr)) + " does not need parameters"))
        return f

    @staticmethod
    def getEnumConstructs(e):
        if hasattr(e,"_hx_constructs"):
            x = e._hx_constructs
            return list(x)
        else:
            return []

    @staticmethod
    def typeof(v):
        if (v is None):
            return ValueType.TNull
        elif isinstance(v,bool):
            return ValueType.TBool
        elif isinstance(v,int):
            return ValueType.TInt
        elif isinstance(v,float):
            return ValueType.TFloat
        elif isinstance(v,str):
            return ValueType.TClass(str)
        elif isinstance(v,list):
            return ValueType.TClass(list)
        elif (isinstance(v,_hx_AnonObject) or python_lib_Inspect.isclass(v)):
            return ValueType.TObject
        elif isinstance(v,Enum):
            return ValueType.TEnum(v.__class__)
        elif (isinstance(v,type) or hasattr(v,"_hx_class")):
            return ValueType.TClass(v.__class__)
        elif callable(v):
            return ValueType.TFunction
        else:
            return ValueType.TUnknown
Type._hx_class = Type
_hx_classes["Type"] = Type

class haxe_StackItem(Enum):
    __slots__ = ()
    _hx_class_name = "haxe.StackItem"
    _hx_constructs = ["CFunction", "Module", "FilePos", "Method", "LocalFunction"]

    @staticmethod
    def Module(m):
        return haxe_StackItem("Module", 1, [m])

    @staticmethod
    def FilePos(s,file,line,column = None):
        return haxe_StackItem("FilePos", 2, [s,file,line,column])

    @staticmethod
    def Method(classname,method):
        return haxe_StackItem("Method", 3, [classname,method])

    @staticmethod
    def LocalFunction(v = None):
        return haxe_StackItem("LocalFunction", 4, [v])
haxe_StackItem.CFunction = haxe_StackItem("CFunction", 0, list())
haxe_StackItem._hx_class = haxe_StackItem
_hx_classes["haxe.StackItem"] = haxe_StackItem


class haxe_CallStack:
    _hx_class_name = "haxe.CallStack"
    __slots__ = ()
    _hx_statics = ["exceptionStack", "toString", "itemToString"]

    @staticmethod
    def exceptionStack():
        stack = []
        exc = python_lib_Sys.exc_info()
        if (exc[2] is not None):
            infos = python_lib_Traceback.extract_tb(exc[2])
            infos.reverse()
            _g = 0
            while (_g < len(infos)):
                elem = (infos[_g] if _g >= 0 and _g < len(infos) else None)
                _g = (_g + 1)
                x = haxe_StackItem.FilePos(None,elem[0],elem[1])
                stack.append(x)
        return stack

    @staticmethod
    def toString(stack):
        b = StringBuf()
        _g = 0
        while (_g < len(stack)):
            def _hx_local_1():
                nonlocal _g
                _hx_local_0 = _g
                _g = (_g + 1)
                return _hx_local_0
            s = python_internal_ArrayImpl._get(stack, _hx_local_1())
            b.b.write("\nCalled from ")
            haxe_CallStack.itemToString(b,s)
        return b.b.getvalue()

    @staticmethod
    def itemToString(b,s):
        tmp = s.index
        if (tmp == 0):
            b.b.write("a C function")
        elif (tmp == 1):
            b.b.write("module ")
            s1 = Std.string(s.params[0])
            b.b.write(s1)
        elif (tmp == 2):
            col = s.params[3]
            s2 = s.params[0]
            if (s2 is not None):
                haxe_CallStack.itemToString(b,s2)
                b.b.write(" (")
            s3 = Std.string(s.params[1])
            b.b.write(s3)
            b.b.write(" line ")
            s4 = Std.string(s.params[2])
            b.b.write(s4)
            if (col is not None):
                b.b.write(" column ")
                s5 = Std.string(col)
                b.b.write(s5)
            if (s2 is not None):
                b.b.write(")")
        elif (tmp == 3):
            s6 = Std.string(s.params[0])
            b.b.write(s6)
            b.b.write(".")
            s7 = Std.string(s.params[1])
            b.b.write(s7)
        elif (tmp == 4):
            b.b.write("local function #")
            s8 = Std.string(s.params[0])
            b.b.write(s8)
        else:
            pass
haxe_CallStack._hx_class = haxe_CallStack
_hx_classes["haxe.CallStack"] = haxe_CallStack


class haxe_EntryPoint:
    _hx_class_name = "haxe.EntryPoint"
    __slots__ = ()
    _hx_statics = ["pending", "threadCount", "processEvents", "run"]

    @staticmethod
    def processEvents():
        while True:
            _this = haxe_EntryPoint.pending
            f = (None if ((len(_this) == 0)) else _this.pop(0))
            if (f is None):
                break
            f()
        time = haxe_MainLoop.tick()
        if ((not haxe_MainLoop.hasEvents()) and ((haxe_EntryPoint.threadCount == 0))):
            return -1
        return time

    @staticmethod
    def run():
        while (not ((haxe_EntryPoint.processEvents() < 0))):
            pass
haxe_EntryPoint._hx_class = haxe_EntryPoint
_hx_classes["haxe.EntryPoint"] = haxe_EntryPoint


class haxe_Log:
    _hx_class_name = "haxe.Log"
    __slots__ = ()
    _hx_statics = ["formatOutput", "trace"]

    @staticmethod
    def formatOutput(v,infos):
        _hx_str = Std.string(v)
        if (infos is None):
            return _hx_str
        pstr = ((HxOverrides.stringOrNull(infos.fileName) + ":") + Std.string(infos.lineNumber))
        if ((infos is not None) and ((Reflect.field(infos,"customParams") is not None))):
            _g = 0
            _g1 = Reflect.field(infos,"customParams")
            while (_g < len(_g1)):
                def _hx_local_1():
                    nonlocal _g
                    _hx_local_0 = _g
                    _g = (_g + 1)
                    return _hx_local_0
                v1 = python_internal_ArrayImpl._get(_g1, _hx_local_1())
                _hx_str = (("null" if _hx_str is None else _hx_str) + ((", " + Std.string(v1))))
        return ((("null" if pstr is None else pstr) + ": ") + ("null" if _hx_str is None else _hx_str))

    @staticmethod
    def trace(v,infos = None):
        python_Lib.printString((("" + Std.string(haxe_Log.formatOutput(v,infos))) + "\n"))
haxe_Log._hx_class = haxe_Log
_hx_classes["haxe.Log"] = haxe_Log


class haxe_MainEvent:
    _hx_class_name = "haxe.MainEvent"
    __slots__ = ("f", "prev", "next", "isBlocking", "nextRun", "priority")
    _hx_fields = ["f", "prev", "next", "isBlocking", "nextRun", "priority"]
    _hx_methods = ["delay", "stop"]

    def __init__(self,f,p):
        self.next = None
        self.prev = None
        self.isBlocking = True
        self.f = f
        self.priority = p
        self.nextRun = -1

    def delay(self,t):
        self.nextRun = (-1 if ((t is None)) else (python_lib_Timeit.default_timer() + t))

    def stop(self):
        if (self.f is None):
            return
        self.f = None
        self.nextRun = -1
        if (self.prev is None):
            haxe_MainLoop.pending = self.next
        else:
            self.prev.next = self.next
        if (self.next is not None):
            self.next.prev = self.prev

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.f = None
        _hx_o.prev = None
        _hx_o.next = None
        _hx_o.isBlocking = None
        _hx_o.nextRun = None
        _hx_o.priority = None
haxe_MainEvent._hx_class = haxe_MainEvent
_hx_classes["haxe.MainEvent"] = haxe_MainEvent


class haxe_MainLoop:
    _hx_class_name = "haxe.MainLoop"
    __slots__ = ()
    _hx_statics = ["pending", "hasEvents", "add", "sortEvents", "tick"]
    pending = None
    threadCount = None

    @staticmethod
    def hasEvents():
        p = haxe_MainLoop.pending
        while (p is not None):
            if p.isBlocking:
                return True
            p = p.next
        return False

    @staticmethod
    def add(f,priority = 0):
        if (priority is None):
            priority = 0
        if (f is None):
            raise _HxException("Event function is null")
        e = haxe_MainEvent(f,priority)
        head = haxe_MainLoop.pending
        if (head is not None):
            head.prev = e
        e.next = head
        haxe_MainLoop.pending = e
        return e

    @staticmethod
    def sortEvents():
        _hx_list = haxe_MainLoop.pending
        if (_hx_list is None):
            return
        insize = 1
        nmerges = None
        psize = 0
        qsize = 0
        p = None
        q = None
        e = None
        tail = None
        while True:
            p = _hx_list
            _hx_list = None
            tail = None
            nmerges = 0
            while (p is not None):
                nmerges = (nmerges + 1)
                q = p
                psize = 0
                _g = 0
                _g1 = insize
                while (_g < _g1):
                    _g = (_g + 1)
                    psize = (psize + 1)
                    q = q.next
                    if (q is None):
                        break
                qsize = insize
                while ((psize > 0) or (((qsize > 0) and ((q is not None))))):
                    if (psize == 0):
                        e = q
                        q = q.next
                        qsize = (qsize - 1)
                    elif (((qsize == 0) or ((q is None))) or (((p.priority > q.priority) or (((p.priority == q.priority) and ((p.nextRun <= q.nextRun))))))):
                        e = p
                        p = p.next
                        psize = (psize - 1)
                    else:
                        e = q
                        q = q.next
                        qsize = (qsize - 1)
                    if (tail is not None):
                        tail.next = e
                    else:
                        _hx_list = e
                    e.prev = tail
                    tail = e
                p = q
            tail.next = None
            if (nmerges <= 1):
                break
            insize = (insize * 2)
        _hx_list.prev = None
        haxe_MainLoop.pending = _hx_list

    @staticmethod
    def tick():
        haxe_MainLoop.sortEvents()
        e = haxe_MainLoop.pending
        now = python_lib_Timeit.default_timer()
        wait = 1e9
        while (e is not None):
            next = e.next
            wt = (e.nextRun - now)
            if ((e.nextRun < 0) or ((wt <= 0))):
                wait = 0
                if (e.f is not None):
                    e.f()
            elif (wait > wt):
                wait = wt
            e = next
        return wait
haxe_MainLoop._hx_class = haxe_MainLoop
_hx_classes["haxe.MainLoop"] = haxe_MainLoop


class haxe_Serializer:
    _hx_class_name = "haxe.Serializer"
    __slots__ = ("buf", "cache", "shash", "scount", "useCache", "useEnumIndex")
    _hx_fields = ["buf", "cache", "shash", "scount", "useCache", "useEnumIndex"]
    _hx_methods = ["toString", "serializeString", "serializeRef", "serializeFields", "serialize"]
    _hx_statics = ["USE_CACHE", "USE_ENUM_INDEX", "BASE64", "BASE64_CODES", "run"]

    def __init__(self):
        self.buf = StringBuf()
        self.cache = list()
        self.useCache = haxe_Serializer.USE_CACHE
        self.useEnumIndex = haxe_Serializer.USE_ENUM_INDEX
        self.shash = haxe_ds_StringMap()
        self.scount = 0

    def toString(self):
        return self.buf.b.getvalue()

    def serializeString(self,s):
        x = self.shash.h.get(s,None)
        if (x is not None):
            self.buf.b.write("R")
            _this = self.buf
            s1 = Std.string(x)
            _this.b.write(s1)
            return
        value = self.scount
        self.scount = (self.scount + 1)
        self.shash.h[s] = value
        self.buf.b.write("y")
        s = python_lib_urllib_Parse.quote(s,"")
        _this1 = self.buf
        s2 = Std.string(len(s))
        _this1.b.write(s2)
        self.buf.b.write(":")
        _this2 = self.buf
        s3 = Std.string(s)
        _this2.b.write(s3)

    def serializeRef(self,v):
        _g = 0
        _g1 = len(self.cache)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            if HxOverrides.eq((self.cache[i] if i >= 0 and i < len(self.cache) else None),v):
                self.buf.b.write("r")
                _this = self.buf
                s = Std.string(i)
                _this.b.write(s)
                return True
        self.cache.append(v)
        return False

    def serializeFields(self,v):
        _g = 0
        _g1 = python_Boot.fields(v)
        while (_g < len(_g1)):
            f = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            self.serializeString(f)
            self.serialize(Reflect.field(v,f))
        self.buf.b.write("g")

    def serialize(self,v):
        _g = Type.typeof(v)
        tmp = _g.index
        if (tmp == 0):
            self.buf.b.write("n")
        elif (tmp == 1):
            v1 = v
            if (v1 == 0):
                self.buf.b.write("z")
                return
            self.buf.b.write("i")
            _this = self.buf
            s = Std.string(v1)
            _this.b.write(s)
        elif (tmp == 2):
            v2 = v
            if python_lib_Math.isnan(v2):
                self.buf.b.write("k")
            elif (not ((((v2 != Math.POSITIVE_INFINITY) and ((v2 != Math.NEGATIVE_INFINITY))) and (not python_lib_Math.isnan(v2))))):
                self.buf.b.write(("m" if ((v2 < 0)) else "p"))
            else:
                self.buf.b.write("d")
                _this1 = self.buf
                s1 = Std.string(v2)
                _this1.b.write(s1)
        elif (tmp == 3):
            self.buf.b.write(("t" if v else "f"))
        elif (tmp == 4):
            if Std._hx_is(v,Class):
                className = Type.getClassName(v)
                self.buf.b.write("A")
                self.serializeString(className)
            elif Std._hx_is(v,Enum):
                self.buf.b.write("B")
                self.serializeString(Type.getEnumName(v))
            else:
                if (self.useCache and self.serializeRef(v)):
                    return
                self.buf.b.write("o")
                self.serializeFields(v)
        elif (tmp == 5):
            raise _HxException("Cannot serialize function")
        elif (tmp == 6):
            c = _g.params[0]
            if (c == str):
                self.serializeString(v)
                return
            if (self.useCache and self.serializeRef(v)):
                return
            _g1 = Type.getClassName(c)
            _hx_local_0 = len(_g1)
            if (_hx_local_0 == 17):
                if (_g1 == "haxe.ds.ObjectMap"):
                    self.buf.b.write("M")
                    v5 = v
                    k2 = v5.keys()
                    while k2.hasNext():
                        k3 = k2.next()
                        self.serialize(k3)
                        self.serialize(v5.h.get(k3,None))
                    self.buf.b.write("h")
                elif (_g1 == "haxe.ds.StringMap"):
                    self.buf.b.write("b")
                    v6 = v
                    k4 = v6.keys()
                    while k4.hasNext():
                        k5 = k4.next()
                        self.serializeString(k5)
                        self.serialize(v6.h.get(k5,None))
                    self.buf.b.write("h")
                else:
                    if self.useCache:
                        _this16 = self.cache
                        if (len(_this16) != 0):
                            _this16.pop()
                    if hasattr(v,(("_hx_" + "hxSerialize") if (("hxSerialize" in python_Boot.keywords)) else (("_hx_" + "hxSerialize") if (((((len("hxSerialize") > 2) and ((ord("hxSerialize"[0]) == 95))) and ((ord("hxSerialize"[1]) == 95))) and ((ord("hxSerialize"[(len("hxSerialize") - 1)]) != 95)))) else "hxSerialize"))):
                        self.buf.b.write("C")
                        self.serializeString(Type.getClassName(c))
                        if self.useCache:
                            self.cache.append(v)
                        Reflect.field(v,"hxSerialize")(self)
                        self.buf.b.write("g")
                    else:
                        self.buf.b.write("c")
                        self.serializeString(Type.getClassName(c))
                        if self.useCache:
                            self.cache.append(v)
                        self.serializeFields(v)
            elif (_hx_local_0 == 5):
                if (_g1 == "Array"):
                    ucount = 0
                    self.buf.b.write("a")
                    v3 = v
                    l = len(v3)
                    _g2 = 0
                    while (_g2 < l):
                        i = _g2
                        _g2 = (_g2 + 1)
                        if ((v3[i] if i >= 0 and i < len(v3) else None) is None):
                            ucount = (ucount + 1)
                        else:
                            if (ucount > 0):
                                if (ucount == 1):
                                    self.buf.b.write("n")
                                else:
                                    self.buf.b.write("u")
                                    _this2 = self.buf
                                    s2 = Std.string(ucount)
                                    _this2.b.write(s2)
                                ucount = 0
                            self.serialize((v3[i] if i >= 0 and i < len(v3) else None))
                    if (ucount > 0):
                        if (ucount == 1):
                            self.buf.b.write("n")
                        else:
                            self.buf.b.write("u")
                            _this3 = self.buf
                            s3 = Std.string(ucount)
                            _this3.b.write(s3)
                    self.buf.b.write("h")
                else:
                    if self.useCache:
                        _this16 = self.cache
                        if (len(_this16) != 0):
                            _this16.pop()
                    if hasattr(v,(("_hx_" + "hxSerialize") if (("hxSerialize" in python_Boot.keywords)) else (("_hx_" + "hxSerialize") if (((((len("hxSerialize") > 2) and ((ord("hxSerialize"[0]) == 95))) and ((ord("hxSerialize"[1]) == 95))) and ((ord("hxSerialize"[(len("hxSerialize") - 1)]) != 95)))) else "hxSerialize"))):
                        self.buf.b.write("C")
                        self.serializeString(Type.getClassName(c))
                        if self.useCache:
                            self.cache.append(v)
                        Reflect.field(v,"hxSerialize")(self)
                        self.buf.b.write("g")
                    else:
                        self.buf.b.write("c")
                        self.serializeString(Type.getClassName(c))
                        if self.useCache:
                            self.cache.append(v)
                        self.serializeFields(v)
            elif (_hx_local_0 == 4):
                if (_g1 == "Date"):
                    self.buf.b.write("v")
                    _this4 = self.buf
                    s4 = Std.string((python_lib_Time.mktime(v.date.timetuple()) * 1000))
                    _this4.b.write(s4)
                else:
                    if self.useCache:
                        _this16 = self.cache
                        if (len(_this16) != 0):
                            _this16.pop()
                    if hasattr(v,(("_hx_" + "hxSerialize") if (("hxSerialize" in python_Boot.keywords)) else (("_hx_" + "hxSerialize") if (((((len("hxSerialize") > 2) and ((ord("hxSerialize"[0]) == 95))) and ((ord("hxSerialize"[1]) == 95))) and ((ord("hxSerialize"[(len("hxSerialize") - 1)]) != 95)))) else "hxSerialize"))):
                        self.buf.b.write("C")
                        self.serializeString(Type.getClassName(c))
                        if self.useCache:
                            self.cache.append(v)
                        Reflect.field(v,"hxSerialize")(self)
                        self.buf.b.write("g")
                    else:
                        self.buf.b.write("c")
                        self.serializeString(Type.getClassName(c))
                        if self.useCache:
                            self.cache.append(v)
                        self.serializeFields(v)
            elif (_hx_local_0 == 12):
                if (_g1 == "haxe.ds.List"):
                    self.buf.b.write("l")
                    _g_head = v.h
                    while (_g_head is not None):
                        val = _g_head.item
                        _g_head = _g_head.next
                        self.serialize(val)
                    self.buf.b.write("h")
                else:
                    if self.useCache:
                        _this16 = self.cache
                        if (len(_this16) != 0):
                            _this16.pop()
                    if hasattr(v,(("_hx_" + "hxSerialize") if (("hxSerialize" in python_Boot.keywords)) else (("_hx_" + "hxSerialize") if (((((len("hxSerialize") > 2) and ((ord("hxSerialize"[0]) == 95))) and ((ord("hxSerialize"[1]) == 95))) and ((ord("hxSerialize"[(len("hxSerialize") - 1)]) != 95)))) else "hxSerialize"))):
                        self.buf.b.write("C")
                        self.serializeString(Type.getClassName(c))
                        if self.useCache:
                            self.cache.append(v)
                        Reflect.field(v,"hxSerialize")(self)
                        self.buf.b.write("g")
                    else:
                        self.buf.b.write("c")
                        self.serializeString(Type.getClassName(c))
                        if self.useCache:
                            self.cache.append(v)
                        self.serializeFields(v)
            elif (_hx_local_0 == 13):
                if (_g1 == "haxe.io.Bytes"):
                    v7 = v
                    self.buf.b.write("s")
                    _this6 = self.buf
                    s6 = Std.string(Math.ceil(((v7.length * 8) / 6)))
                    _this6.b.write(s6)
                    self.buf.b.write(":")
                    i1 = 0
                    _hx_max = (v7.length - 2)
                    b64 = haxe_Serializer.BASE64_CODES
                    if (b64 is None):
                        b64 = [None]*len(haxe_Serializer.BASE64)
                        _g3 = 0
                        _g11 = len(haxe_Serializer.BASE64)
                        while (_g3 < _g11):
                            i2 = _g3
                            _g3 = (_g3 + 1)
                            val1 = HxString.charCodeAt(haxe_Serializer.BASE64,i2)
                            b64[i2] = val1
                        haxe_Serializer.BASE64_CODES = b64
                    while (i1 < _hx_max):
                        pos = i1
                        i1 = (i1 + 1)
                        b1 = v7.b[pos]
                        pos1 = i1
                        i1 = (i1 + 1)
                        b2 = v7.b[pos1]
                        pos2 = i1
                        i1 = (i1 + 1)
                        b3 = v7.b[pos2]
                        _this7 = self.buf
                        c1 = b64[(b1 >> 2)]
                        s7 = "".join(map(chr,[c1]))
                        _this7.b.write(s7)
                        _this8 = self.buf
                        c2 = b64[((((b1 << 4) | ((b2 >> 4)))) & 63)]
                        s8 = "".join(map(chr,[c2]))
                        _this8.b.write(s8)
                        _this9 = self.buf
                        c3 = b64[((((b2 << 2) | ((b3 >> 6)))) & 63)]
                        s9 = "".join(map(chr,[c3]))
                        _this9.b.write(s9)
                        _this10 = self.buf
                        c4 = b64[(b3 & 63)]
                        s10 = "".join(map(chr,[c4]))
                        _this10.b.write(s10)
                    if (i1 == _hx_max):
                        pos3 = i1
                        i1 = (i1 + 1)
                        b11 = v7.b[pos3]
                        pos4 = i1
                        i1 = (i1 + 1)
                        b21 = v7.b[pos4]
                        _this11 = self.buf
                        c5 = b64[(b11 >> 2)]
                        s11 = "".join(map(chr,[c5]))
                        _this11.b.write(s11)
                        _this12 = self.buf
                        c6 = b64[((((b11 << 4) | ((b21 >> 4)))) & 63)]
                        s12 = "".join(map(chr,[c6]))
                        _this12.b.write(s12)
                        _this13 = self.buf
                        c7 = b64[((b21 << 2) & 63)]
                        s13 = "".join(map(chr,[c7]))
                        _this13.b.write(s13)
                    elif (i1 == ((_hx_max + 1))):
                        pos5 = i1
                        i1 = (i1 + 1)
                        b12 = v7.b[pos5]
                        _this14 = self.buf
                        c8 = b64[(b12 >> 2)]
                        s14 = "".join(map(chr,[c8]))
                        _this14.b.write(s14)
                        _this15 = self.buf
                        c9 = b64[((b12 << 4) & 63)]
                        s15 = "".join(map(chr,[c9]))
                        _this15.b.write(s15)
                else:
                    if self.useCache:
                        _this16 = self.cache
                        if (len(_this16) != 0):
                            _this16.pop()
                    if hasattr(v,(("_hx_" + "hxSerialize") if (("hxSerialize" in python_Boot.keywords)) else (("_hx_" + "hxSerialize") if (((((len("hxSerialize") > 2) and ((ord("hxSerialize"[0]) == 95))) and ((ord("hxSerialize"[1]) == 95))) and ((ord("hxSerialize"[(len("hxSerialize") - 1)]) != 95)))) else "hxSerialize"))):
                        self.buf.b.write("C")
                        self.serializeString(Type.getClassName(c))
                        if self.useCache:
                            self.cache.append(v)
                        Reflect.field(v,"hxSerialize")(self)
                        self.buf.b.write("g")
                    else:
                        self.buf.b.write("c")
                        self.serializeString(Type.getClassName(c))
                        if self.useCache:
                            self.cache.append(v)
                        self.serializeFields(v)
            elif (_hx_local_0 == 14):
                if (_g1 == "haxe.ds.IntMap"):
                    self.buf.b.write("q")
                    v4 = v
                    k = v4.keys()
                    while k.hasNext():
                        k1 = k.next()
                        self.buf.b.write(":")
                        _this5 = self.buf
                        s5 = Std.string(k1)
                        _this5.b.write(s5)
                        self.serialize(v4.h.get(k1,None))
                    self.buf.b.write("h")
                else:
                    if self.useCache:
                        _this16 = self.cache
                        if (len(_this16) != 0):
                            _this16.pop()
                    if hasattr(v,(("_hx_" + "hxSerialize") if (("hxSerialize" in python_Boot.keywords)) else (("_hx_" + "hxSerialize") if (((((len("hxSerialize") > 2) and ((ord("hxSerialize"[0]) == 95))) and ((ord("hxSerialize"[1]) == 95))) and ((ord("hxSerialize"[(len("hxSerialize") - 1)]) != 95)))) else "hxSerialize"))):
                        self.buf.b.write("C")
                        self.serializeString(Type.getClassName(c))
                        if self.useCache:
                            self.cache.append(v)
                        Reflect.field(v,"hxSerialize")(self)
                        self.buf.b.write("g")
                    else:
                        self.buf.b.write("c")
                        self.serializeString(Type.getClassName(c))
                        if self.useCache:
                            self.cache.append(v)
                        self.serializeFields(v)
            else:
                if self.useCache:
                    _this16 = self.cache
                    if (len(_this16) != 0):
                        _this16.pop()
                if hasattr(v,(("_hx_" + "hxSerialize") if (("hxSerialize" in python_Boot.keywords)) else (("_hx_" + "hxSerialize") if (((((len("hxSerialize") > 2) and ((ord("hxSerialize"[0]) == 95))) and ((ord("hxSerialize"[1]) == 95))) and ((ord("hxSerialize"[(len("hxSerialize") - 1)]) != 95)))) else "hxSerialize"))):
                    self.buf.b.write("C")
                    self.serializeString(Type.getClassName(c))
                    if self.useCache:
                        self.cache.append(v)
                    Reflect.field(v,"hxSerialize")(self)
                    self.buf.b.write("g")
                else:
                    self.buf.b.write("c")
                    self.serializeString(Type.getClassName(c))
                    if self.useCache:
                        self.cache.append(v)
                    self.serializeFields(v)
        elif (tmp == 7):
            if self.useCache:
                if self.serializeRef(v):
                    return
                _this17 = self.cache
                if (len(_this17) != 0):
                    _this17.pop()
            _this18 = self.buf
            s16 = Std.string(("j" if (self.useEnumIndex) else "w"))
            _this18.b.write(s16)
            self.serializeString(Type.getEnumName(_g.params[0]))
            if self.useEnumIndex:
                self.buf.b.write(":")
                _this19 = self.buf
                s17 = Std.string(v.index)
                _this19.b.write(s17)
            else:
                self.serializeString(v.tag)
            self.buf.b.write(":")
            arr = v.params
            if (arr is not None):
                _this20 = self.buf
                s18 = Std.string(len(arr))
                _this20.b.write(s18)
                _g4 = 0
                while (_g4 < len(arr)):
                    def _hx_local_3():
                        nonlocal _g4
                        _hx_local_2 = _g4
                        _g4 = (_g4 + 1)
                        return _hx_local_2
                    v8 = python_internal_ArrayImpl._get(arr, _hx_local_3())
                    self.serialize(v8)
            else:
                self.buf.b.write("0")
            if self.useCache:
                self.cache.append(v)
        else:
            raise _HxException(("Cannot serialize " + Std.string(v)))

    @staticmethod
    def run(v):
        s = haxe_Serializer()
        s.serialize(v)
        return s.toString()

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.buf = None
        _hx_o.cache = None
        _hx_o.shash = None
        _hx_o.scount = None
        _hx_o.useCache = None
        _hx_o.useEnumIndex = None
haxe_Serializer._hx_class = haxe_Serializer
_hx_classes["haxe.Serializer"] = haxe_Serializer


class haxe_Timer:
    _hx_class_name = "haxe.Timer"
    _hx_fields = ["event"]
    _hx_methods = ["stop", "run"]
    _hx_statics = ["delay"]

    def __init__(self,time_ms):
        self.event = None
        _gthis = self
        dt = (time_ms / 1000)
        def _hx_local_2():
            _hx_local_0 = _gthis.event
            _hx_local_1 = _hx_local_0.nextRun
            _hx_local_0.nextRun = (_hx_local_1 + dt)
            _hx_local_0.nextRun
            _gthis.run()
        self.event = haxe_MainLoop.add(_hx_local_2)
        self.event.delay(dt)

    def stop(self):
        if (self.event is not None):
            self.event.stop()
            self.event = None

    def run(self):
        pass

    @staticmethod
    def delay(f,time_ms):
        t = haxe_Timer(time_ms)
        def _hx_local_0():
            t.stop()
            f()
        t.run = _hx_local_0
        return t

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.event = None
haxe_Timer._hx_class = haxe_Timer
_hx_classes["haxe.Timer"] = haxe_Timer


class haxe__Unserializer_DefaultResolver:
    _hx_class_name = "haxe._Unserializer.DefaultResolver"
    __slots__ = ()
    _hx_methods = ["resolveClass", "resolveEnum"]

    def __init__(self):
        pass

    def resolveClass(self,name):
        return Type.resolveClass(name)

    def resolveEnum(self,name):
        return Type.resolveEnum(name)

    @staticmethod
    def _hx_empty_init(_hx_o):        pass
haxe__Unserializer_DefaultResolver._hx_class = haxe__Unserializer_DefaultResolver
_hx_classes["haxe._Unserializer.DefaultResolver"] = haxe__Unserializer_DefaultResolver


class haxe_Unserializer:
    _hx_class_name = "haxe.Unserializer"
    __slots__ = ("buf", "pos", "length", "cache", "scache", "resolver")
    _hx_fields = ["buf", "pos", "length", "cache", "scache", "resolver"]
    _hx_methods = ["readDigits", "readFloat", "unserializeObject", "unserializeEnum", "unserialize"]
    _hx_statics = ["DEFAULT_RESOLVER", "BASE64", "CODES", "initCodes", "run"]

    def __init__(self,buf):
        self.buf = buf
        self.length = len(buf)
        self.pos = 0
        self.scache = list()
        self.cache = list()
        r = haxe_Unserializer.DEFAULT_RESOLVER
        if (r is None):
            r = haxe__Unserializer_DefaultResolver()
            haxe_Unserializer.DEFAULT_RESOLVER = r
        self.resolver = r

    def readDigits(self):
        k = 0
        s = False
        fpos = self.pos
        while True:
            p = self.pos
            s1 = self.buf
            c = (-1 if ((p >= len(s1))) else ord(s1[p]))
            if (c == -1):
                break
            if (c == 45):
                if (self.pos != fpos):
                    break
                s = True
                _hx_local_0 = self
                _hx_local_1 = _hx_local_0.pos
                _hx_local_0.pos = (_hx_local_1 + 1)
                _hx_local_1
                continue
            if ((c < 48) or ((c > 57))):
                break
            k = ((k * 10) + ((c - 48)))
            _hx_local_2 = self
            _hx_local_3 = _hx_local_2.pos
            _hx_local_2.pos = (_hx_local_3 + 1)
            _hx_local_3
        if s:
            k = (k * -1)
        return k

    def readFloat(self):
        p1 = self.pos
        while True:
            p = self.pos
            s = self.buf
            c = (-1 if ((p >= len(s))) else ord(s[p]))
            if (c == -1):
                break
            if ((((c >= 43) and ((c < 58))) or ((c == 101))) or ((c == 69))):
                _hx_local_0 = self
                _hx_local_1 = _hx_local_0.pos
                _hx_local_0.pos = (_hx_local_1 + 1)
                _hx_local_1
            else:
                break
        return Std.parseFloat(HxString.substr(self.buf,p1,(self.pos - p1)))

    def unserializeObject(self,o):
        while True:
            if (self.pos >= self.length):
                raise _HxException("Invalid object")
            p = self.pos
            s = self.buf
            if (((-1 if ((p >= len(s))) else ord(s[p]))) == 103):
                break
            k = self.unserialize()
            if (not Std._hx_is(k,str)):
                raise _HxException("Invalid object key")
            v = self.unserialize()
            field = k
            setattr(o,(("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field)),v)
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.pos
        _hx_local_0.pos = (_hx_local_1 + 1)
        _hx_local_1

    def unserializeEnum(self,edecl,tag):
        p = self.pos
        self.pos = (self.pos + 1)
        s = self.buf
        if (((-1 if ((p >= len(s))) else ord(s[p]))) != 58):
            raise _HxException("Invalid enum format")
        nargs = self.readDigits()
        if (nargs == 0):
            return Type.createEnum(edecl,tag)
        args = list()
        while True:
            tmp = nargs
            nargs = (nargs - 1)
            if (not ((tmp > 0))):
                break
            x = self.unserialize()
            args.append(x)
        return Type.createEnum(edecl,tag,args)

    def unserialize(self):
        p = self.pos
        self.pos = (self.pos + 1)
        s = self.buf
        _g = (-1 if ((p >= len(s))) else ord(s[p]))
        if (_g == 65):
            name = self.unserialize()
            cl = self.resolver.resolveClass(name)
            if (cl is None):
                raise _HxException(("Class not found " + ("null" if name is None else name)))
            return cl
        elif (_g == 66):
            name1 = self.unserialize()
            e = self.resolver.resolveEnum(name1)
            if (e is None):
                raise _HxException(("Enum not found " + ("null" if name1 is None else name1)))
            return e
        elif (_g == 67):
            name2 = self.unserialize()
            cl1 = self.resolver.resolveClass(name2)
            if (cl1 is None):
                raise _HxException(("Class not found " + ("null" if name2 is None else name2)))
            o = Type.createEmptyInstance(cl1)
            self.cache.append(o)
            Reflect.field(o,"hxUnserialize")(self)
            p1 = self.pos
            self.pos = (self.pos + 1)
            s1 = self.buf
            if (((-1 if ((p1 >= len(s1))) else ord(s1[p1]))) != 103):
                raise _HxException("Invalid custom data")
            return o
        elif (_g == 77):
            h = haxe_ds_ObjectMap()
            self.cache.append(h)
            while True:
                p2 = self.pos
                s2 = self.buf
                if (not ((((-1 if ((p2 >= len(s2))) else ord(s2[p2]))) != 104))):
                    break
                h.set(self.unserialize(),self.unserialize())
            _hx_local_0 = self
            _hx_local_1 = _hx_local_0.pos
            _hx_local_0.pos = (_hx_local_1 + 1)
            _hx_local_1
            return h
        elif (_g == 82):
            n = self.readDigits()
            if ((n < 0) or ((n >= len(self.scache)))):
                raise _HxException("Invalid string reference")
            return (self.scache[n] if n >= 0 and n < len(self.scache) else None)
        elif (_g == 97):
            a = list()
            self.cache.append(a)
            while True:
                p3 = self.pos
                s3 = self.buf
                c = (-1 if ((p3 >= len(s3))) else ord(s3[p3]))
                if (c == 104):
                    _hx_local_2 = self
                    _hx_local_3 = _hx_local_2.pos
                    _hx_local_2.pos = (_hx_local_3 + 1)
                    _hx_local_3
                    break
                if (c == 117):
                    _hx_local_4 = self
                    _hx_local_5 = _hx_local_4.pos
                    _hx_local_4.pos = (_hx_local_5 + 1)
                    _hx_local_5
                    n1 = self.readDigits()
                    python_internal_ArrayImpl._set(a, ((len(a) + n1) - 1), None)
                else:
                    x = self.unserialize()
                    a.append(x)
            return a
        elif (_g == 98):
            h1 = haxe_ds_StringMap()
            self.cache.append(h1)
            while True:
                p4 = self.pos
                s4 = self.buf
                if (not ((((-1 if ((p4 >= len(s4))) else ord(s4[p4]))) != 104))):
                    break
                s5 = self.unserialize()
                value = self.unserialize()
                h1.h[s5] = value
            _hx_local_6 = self
            _hx_local_7 = _hx_local_6.pos
            _hx_local_6.pos = (_hx_local_7 + 1)
            _hx_local_7
            return h1
        elif (_g == 99):
            name3 = self.unserialize()
            cl2 = self.resolver.resolveClass(name3)
            if (cl2 is None):
                raise _HxException(("Class not found " + ("null" if name3 is None else name3)))
            o1 = Type.createEmptyInstance(cl2)
            self.cache.append(o1)
            self.unserializeObject(o1)
            return o1
        elif (_g == 100):
            return self.readFloat()
        elif (_g == 102):
            return False
        elif (_g == 105):
            return self.readDigits()
        elif (_g == 106):
            name4 = self.unserialize()
            edecl = self.resolver.resolveEnum(name4)
            if (edecl is None):
                raise _HxException(("Enum not found " + ("null" if name4 is None else name4)))
            _hx_local_8 = self
            _hx_local_9 = _hx_local_8.pos
            _hx_local_8.pos = (_hx_local_9 + 1)
            _hx_local_9
            index = self.readDigits()
            tag = python_internal_ArrayImpl._get(Type.getEnumConstructs(edecl), index)
            if (tag is None):
                raise _HxException(((("Unknown enum index " + ("null" if name4 is None else name4)) + "@") + Std.string(index)))
            e1 = self.unserializeEnum(edecl,tag)
            self.cache.append(e1)
            return e1
        elif (_g == 107):
            return Math.NaN
        elif (_g == 108):
            l = haxe_ds_List()
            self.cache.append(l)
            while True:
                p5 = self.pos
                s6 = self.buf
                if (not ((((-1 if ((p5 >= len(s6))) else ord(s6[p5]))) != 104))):
                    break
                l.add(self.unserialize())
            _hx_local_10 = self
            _hx_local_11 = _hx_local_10.pos
            _hx_local_10.pos = (_hx_local_11 + 1)
            _hx_local_11
            return l
        elif (_g == 109):
            return Math.NEGATIVE_INFINITY
        elif (_g == 110):
            return None
        elif (_g == 111):
            o2 = _hx_AnonObject({})
            self.cache.append(o2)
            self.unserializeObject(o2)
            return o2
        elif (_g == 112):
            return Math.POSITIVE_INFINITY
        elif (_g == 113):
            h2 = haxe_ds_IntMap()
            self.cache.append(h2)
            p6 = self.pos
            self.pos = (self.pos + 1)
            s7 = self.buf
            c1 = (-1 if ((p6 >= len(s7))) else ord(s7[p6]))
            while (c1 == 58):
                h2.set(self.readDigits(),self.unserialize())
                p7 = self.pos
                self.pos = (self.pos + 1)
                s8 = self.buf
                c1 = (-1 if ((p7 >= len(s8))) else ord(s8[p7]))
            if (c1 != 104):
                raise _HxException("Invalid IntMap format")
            return h2
        elif (_g == 114):
            n2 = self.readDigits()
            if ((n2 < 0) or ((n2 >= len(self.cache)))):
                raise _HxException("Invalid reference")
            return (self.cache[n2] if n2 >= 0 and n2 < len(self.cache) else None)
        elif (_g == 115):
            _hx_len = self.readDigits()
            buf = self.buf
            p8 = self.pos
            self.pos = (self.pos + 1)
            s9 = self.buf
            if ((((-1 if ((p8 >= len(s9))) else ord(s9[p8]))) != 58) or (((self.length - self.pos) < _hx_len))):
                raise _HxException("Invalid bytes length")
            codes = haxe_Unserializer.CODES
            if (codes is None):
                codes = haxe_Unserializer.initCodes()
                haxe_Unserializer.CODES = codes
            i = self.pos
            rest = (_hx_len & 3)
            _hx_max = (i + ((_hx_len - rest)))
            _hx_bytes = haxe_io_Bytes.alloc(((((_hx_len >> 2)) * 3) + (((rest - 1) if ((rest >= 2)) else 0))))
            bpos = 0
            while (i < _hx_max):
                index1 = i
                i = (i + 1)
                c11 = python_internal_ArrayImpl._get(codes, (-1 if ((index1 >= len(buf))) else ord(buf[index1])))
                index2 = i
                i = (i + 1)
                c2 = python_internal_ArrayImpl._get(codes, (-1 if ((index2 >= len(buf))) else ord(buf[index2])))
                pos = bpos
                bpos = (bpos + 1)
                _hx_bytes.b[pos] = ((((c11 << 2) | ((c2 >> 4)))) & 255)
                index3 = i
                i = (i + 1)
                c3 = python_internal_ArrayImpl._get(codes, (-1 if ((index3 >= len(buf))) else ord(buf[index3])))
                pos1 = bpos
                bpos = (bpos + 1)
                _hx_bytes.b[pos1] = ((((c2 << 4) | ((c3 >> 2)))) & 255)
                index4 = i
                i = (i + 1)
                c4 = (-1 if ((index4 >= len(buf))) else ord(buf[index4]))
                pos2 = bpos
                bpos = (bpos + 1)
                _hx_bytes.b[pos2] = ((((c3 << 6) | (codes[c4] if c4 >= 0 and c4 < len(codes) else None))) & 255)
            if (rest >= 2):
                index5 = i
                i = (i + 1)
                c12 = python_internal_ArrayImpl._get(codes, (-1 if ((index5 >= len(buf))) else ord(buf[index5])))
                index6 = i
                i = (i + 1)
                c21 = python_internal_ArrayImpl._get(codes, (-1 if ((index6 >= len(buf))) else ord(buf[index6])))
                pos3 = bpos
                bpos = (bpos + 1)
                _hx_bytes.b[pos3] = ((((c12 << 2) | ((c21 >> 4)))) & 255)
                if (rest == 3):
                    index7 = i
                    i = (i + 1)
                    c31 = (-1 if ((index7 >= len(buf))) else ord(buf[index7]))
                    pos4 = bpos
                    bpos = (bpos + 1)
                    _hx_bytes.b[pos4] = ((((c21 << 4) | (((codes[c31] if c31 >= 0 and c31 < len(codes) else None) >> 2)))) & 255)
            _hx_local_12 = self
            _hx_local_13 = _hx_local_12.pos
            _hx_local_12.pos = (_hx_local_13 + _hx_len)
            _hx_local_12.pos
            self.cache.append(_hx_bytes)
            return _hx_bytes
        elif (_g == 116):
            return True
        elif (_g == 118):
            d = None
            tmp = None
            tmp1 = None
            tmp2 = None
            tmp3 = None
            tmp4 = None
            tmp5 = None
            tmp6 = None
            tmp7 = None
            p9 = self.pos
            s10 = self.buf
            if (((-1 if ((p9 >= len(s10))) else ord(s10[p9]))) >= 48):
                p10 = self.pos
                s11 = self.buf
                tmp7 = (((-1 if ((p10 >= len(s11))) else ord(s11[p10]))) <= 57)
            else:
                tmp7 = False
            if tmp7:
                p11 = (self.pos + 1)
                s12 = self.buf
                tmp6 = (((-1 if ((p11 >= len(s12))) else ord(s12[p11]))) >= 48)
            else:
                tmp6 = False
            if tmp6:
                p12 = (self.pos + 1)
                s13 = self.buf
                tmp5 = (((-1 if ((p12 >= len(s13))) else ord(s13[p12]))) <= 57)
            else:
                tmp5 = False
            if tmp5:
                p13 = (self.pos + 2)
                s14 = self.buf
                tmp4 = (((-1 if ((p13 >= len(s14))) else ord(s14[p13]))) >= 48)
            else:
                tmp4 = False
            if tmp4:
                p14 = (self.pos + 2)
                s15 = self.buf
                tmp3 = (((-1 if ((p14 >= len(s15))) else ord(s15[p14]))) <= 57)
            else:
                tmp3 = False
            if tmp3:
                p15 = (self.pos + 3)
                s16 = self.buf
                tmp2 = (((-1 if ((p15 >= len(s16))) else ord(s16[p15]))) >= 48)
            else:
                tmp2 = False
            if tmp2:
                p16 = (self.pos + 3)
                s17 = self.buf
                tmp1 = (((-1 if ((p16 >= len(s17))) else ord(s17[p16]))) <= 57)
            else:
                tmp1 = False
            if tmp1:
                p17 = (self.pos + 4)
                s18 = self.buf
                tmp = (((-1 if ((p17 >= len(s18))) else ord(s18[p17]))) == 45)
            else:
                tmp = False
            if tmp:
                d = Date.fromString(HxString.substr(self.buf,self.pos,19))
                _hx_local_14 = self
                _hx_local_15 = _hx_local_14.pos
                _hx_local_14.pos = (_hx_local_15 + 19)
                _hx_local_14.pos
            else:
                d = Date.fromTime(self.readFloat())
            self.cache.append(d)
            return d
        elif (_g == 119):
            name5 = self.unserialize()
            edecl1 = self.resolver.resolveEnum(name5)
            if (edecl1 is None):
                raise _HxException(("Enum not found " + ("null" if name5 is None else name5)))
            e2 = self.unserializeEnum(edecl1,self.unserialize())
            self.cache.append(e2)
            return e2
        elif (_g == 120):
            raise _HxException(self.unserialize())
        elif (_g == 121):
            len1 = self.readDigits()
            p18 = self.pos
            self.pos = (self.pos + 1)
            s19 = self.buf
            if ((((-1 if ((p18 >= len(s19))) else ord(s19[p18]))) != 58) or (((self.length - self.pos) < len1))):
                raise _HxException("Invalid string length")
            s20 = HxString.substr(self.buf,self.pos,len1)
            _hx_local_16 = self
            _hx_local_17 = _hx_local_16.pos
            _hx_local_16.pos = (_hx_local_17 + len1)
            _hx_local_16.pos
            s20 = python_lib_urllib_Parse.unquote(s20)
            self.scache.append(s20)
            return s20
        elif (_g == 122):
            return 0
        else:
            pass
        _hx_local_18 = self
        _hx_local_19 = _hx_local_18.pos
        _hx_local_18.pos = (_hx_local_19 - 1)
        _hx_local_19
        _this = self.buf
        index8 = self.pos
        raise _HxException(((("Invalid char " + HxOverrides.stringOrNull((("" if (((index8 < 0) or ((index8 >= len(_this))))) else _this[index8])))) + " at position ") + Std.string(self.pos)))

    @staticmethod
    def initCodes():
        codes = list()
        _g = 0
        _g1 = len(haxe_Unserializer.BASE64)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            s = haxe_Unserializer.BASE64
            python_internal_ArrayImpl._set(codes, (-1 if ((i >= len(s))) else ord(s[i])), i)
        return codes

    @staticmethod
    def run(v):
        return haxe_Unserializer(v).unserialize()

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.buf = None
        _hx_o.pos = None
        _hx_o.length = None
        _hx_o.cache = None
        _hx_o.scache = None
        _hx_o.resolver = None
haxe_Unserializer._hx_class = haxe_Unserializer
_hx_classes["haxe.Unserializer"] = haxe_Unserializer


class haxe_crypto_Adler32:
    _hx_class_name = "haxe.crypto.Adler32"
    __slots__ = ("a1", "a2")
    _hx_fields = ["a1", "a2"]
    _hx_methods = ["update", "equals"]
    _hx_statics = ["read"]

    def __init__(self):
        self.a1 = 1
        self.a2 = 0

    def update(self,b,pos,_hx_len):
        a1 = self.a1
        a2 = self.a2
        _g = pos
        _g1 = (pos + _hx_len)
        while (_g < _g1):
            p = _g
            _g = (_g + 1)
            a1 = HxOverrides.mod(((a1 + b.b[p])), 65521)
            a2 = HxOverrides.mod(((a2 + a1)), 65521)
        self.a1 = a1
        self.a2 = a2

    def equals(self,a):
        if (a.a1 == self.a1):
            return (a.a2 == self.a2)
        else:
            return False

    @staticmethod
    def read(i):
        a = haxe_crypto_Adler32()
        a2a = i.readByte()
        a2b = i.readByte()
        a.a1 = ((i.readByte() << 8) | i.readByte())
        a.a2 = ((a2a << 8) | a2b)
        return a

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.a1 = None
        _hx_o.a2 = None
haxe_crypto_Adler32._hx_class = haxe_crypto_Adler32
_hx_classes["haxe.crypto.Adler32"] = haxe_crypto_Adler32


class haxe_ds_BalancedTree:
    _hx_class_name = "haxe.ds.BalancedTree"
    __slots__ = ("root",)
    _hx_fields = ["root"]
    _hx_methods = ["set", "get", "remove", "iterator", "setLoop", "removeLoop", "iteratorLoop", "merge", "minBinding", "removeMinBinding", "balance", "compare"]
    _hx_interfaces = [haxe_IMap]

    def __init__(self):
        self.root = None

    def set(self,key,value):
        self.root = self.setLoop(key,value,self.root)

    def get(self,key):
        node = self.root
        while (node is not None):
            c = self.compare(key,node.key)
            if (c == 0):
                return node.value
            if (c < 0):
                node = node.left
            else:
                node = node.right
        return None

    def remove(self,key):
        try:
            self.root = self.removeLoop(key,self.root)
            return True
        except Exception as _hx_e:
            _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
            if isinstance(_hx_e1, str):
                e = _hx_e1
                return False
            else:
                raise _hx_e

    def iterator(self):
        ret = []
        self.iteratorLoop(self.root,ret)
        return python_HaxeIterator(ret.__iter__())

    def setLoop(self,k,v,node):
        if (node is None):
            return haxe_ds_TreeNode(None,k,v,None)
        c = self.compare(k,node.key)
        if (c == 0):
            return haxe_ds_TreeNode(node.left,k,v,node.right,(0 if ((node is None)) else node._height))
        elif (c < 0):
            return self.balance(self.setLoop(k,v,node.left),node.key,node.value,node.right)
        else:
            nr = self.setLoop(k,v,node.right)
            return self.balance(node.left,node.key,node.value,nr)

    def removeLoop(self,k,node):
        if (node is None):
            raise _HxException("Not_found")
        c = self.compare(k,node.key)
        if (c == 0):
            return self.merge(node.left,node.right)
        elif (c < 0):
            return self.balance(self.removeLoop(k,node.left),node.key,node.value,node.right)
        else:
            return self.balance(node.left,node.key,node.value,self.removeLoop(k,node.right))

    def iteratorLoop(self,node,acc):
        if (node is not None):
            self.iteratorLoop(node.left,acc)
            x = node.value
            acc.append(x)
            self.iteratorLoop(node.right,acc)

    def merge(self,t1,t2):
        if (t1 is None):
            return t2
        if (t2 is None):
            return t1
        t = self.minBinding(t2)
        return self.balance(t1,t.key,t.value,self.removeMinBinding(t2))

    def minBinding(self,t):
        if (t is None):
            raise _HxException("Not_found")
        elif (t.left is None):
            return t
        else:
            return self.minBinding(t.left)

    def removeMinBinding(self,t):
        if (t.left is None):
            return t.right
        else:
            return self.balance(self.removeMinBinding(t.left),t.key,t.value,t.right)

    def balance(self,l,k,v,r):
        hl = (0 if ((l is None)) else l._height)
        hr = (0 if ((r is None)) else r._height)
        if (hl > ((hr + 2))):
            _this = l.left
            _this1 = l.right
            if (((0 if ((_this is None)) else _this._height)) >= ((0 if ((_this1 is None)) else _this1._height))):
                return haxe_ds_TreeNode(l.left,l.key,l.value,haxe_ds_TreeNode(l.right,k,v,r))
            else:
                return haxe_ds_TreeNode(haxe_ds_TreeNode(l.left,l.key,l.value,l.right.left),l.right.key,l.right.value,haxe_ds_TreeNode(l.right.right,k,v,r))
        elif (hr > ((hl + 2))):
            _this2 = r.right
            _this3 = r.left
            if (((0 if ((_this2 is None)) else _this2._height)) > ((0 if ((_this3 is None)) else _this3._height))):
                return haxe_ds_TreeNode(haxe_ds_TreeNode(l,k,v,r.left),r.key,r.value,r.right)
            else:
                return haxe_ds_TreeNode(haxe_ds_TreeNode(l,k,v,r.left.left),r.left.key,r.left.value,haxe_ds_TreeNode(r.left.right,r.key,r.value,r.right))
        else:
            return haxe_ds_TreeNode(l,k,v,r,(((hl if ((hl > hr)) else hr)) + 1))

    def compare(self,k1,k2):
        return Reflect.compare(k1,k2)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.root = None
haxe_ds_BalancedTree._hx_class = haxe_ds_BalancedTree
_hx_classes["haxe.ds.BalancedTree"] = haxe_ds_BalancedTree


class haxe_ds_TreeNode:
    _hx_class_name = "haxe.ds.TreeNode"
    __slots__ = ("left", "right", "key", "value", "_height")
    _hx_fields = ["left", "right", "key", "value", "_height"]

    def __init__(self,l,k,v,r,h = -1):
        if (h is None):
            h = -1
        self._height = None
        self.left = l
        self.key = k
        self.value = v
        self.right = r
        if (h == -1):
            tmp = None
            _this = self.left
            _this1 = self.right
            if (((0 if ((_this is None)) else _this._height)) > ((0 if ((_this1 is None)) else _this1._height))):
                _this2 = self.left
                tmp = (0 if ((_this2 is None)) else _this2._height)
            else:
                _this3 = self.right
                tmp = (0 if ((_this3 is None)) else _this3._height)
            self._height = (tmp + 1)
        else:
            self._height = h

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.left = None
        _hx_o.right = None
        _hx_o.key = None
        _hx_o.value = None
        _hx_o._height = None
haxe_ds_TreeNode._hx_class = haxe_ds_TreeNode
_hx_classes["haxe.ds.TreeNode"] = haxe_ds_TreeNode

class haxe_ds_Either(Enum):
    __slots__ = ()
    _hx_class_name = "haxe.ds.Either"
    _hx_constructs = ["Left", "Right"]

    @staticmethod
    def Left(v):
        return haxe_ds_Either("Left", 0, [v])

    @staticmethod
    def Right(v):
        return haxe_ds_Either("Right", 1, [v])
haxe_ds_Either._hx_class = haxe_ds_Either
_hx_classes["haxe.ds.Either"] = haxe_ds_Either


class haxe_ds_EnumValueMap(haxe_ds_BalancedTree):
    _hx_class_name = "haxe.ds.EnumValueMap"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = ["compare", "compareArgs", "compareArg"]
    _hx_statics = []
    _hx_interfaces = [haxe_IMap]
    _hx_super = haxe_ds_BalancedTree


    def __init__(self):
        super().__init__()

    def compare(self,k1,k2):
        d = (k1.index - k2.index)
        if (d != 0):
            return d
        p1 = k1.params
        p2 = k2.params
        if ((len(p1) == 0) and ((len(p2) == 0))):
            return 0
        return self.compareArgs(p1,p2)

    def compareArgs(self,a1,a2):
        ld = (len(a1) - len(a2))
        if (ld != 0):
            return ld
        _g = 0
        _g1 = len(a1)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            d = self.compareArg((a1[i] if i >= 0 and i < len(a1) else None),(a2[i] if i >= 0 and i < len(a2) else None))
            if (d != 0):
                return d
        return 0

    def compareArg(self,v1,v2):
        if (Reflect.isEnumValue(v1) and Reflect.isEnumValue(v2)):
            return self.compare(v1,v2)
        elif (Std._hx_is(v1,list) and Std._hx_is(v2,list)):
            return self.compareArgs(v1,v2)
        else:
            return Reflect.compare(v1,v2)

    @staticmethod
    def _hx_empty_init(_hx_o):        pass
haxe_ds_EnumValueMap._hx_class = haxe_ds_EnumValueMap
_hx_classes["haxe.ds.EnumValueMap"] = haxe_ds_EnumValueMap


class haxe_ds_IntMap:
    _hx_class_name = "haxe.ds.IntMap"
    __slots__ = ("h",)
    _hx_fields = ["h"]
    _hx_methods = ["set", "remove", "keys", "iterator"]
    _hx_interfaces = [haxe_IMap]

    def __init__(self):
        self.h = dict()

    def set(self,key,value):
        self.h[key] = value

    def remove(self,key):
        if (not (key in self.h)):
            return False
        del self.h[key]
        return True

    def keys(self):
        return python_HaxeIterator(iter(self.h.keys()))

    def iterator(self):
        return python_HaxeIterator(iter(self.h.values()))

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.h = None
haxe_ds_IntMap._hx_class = haxe_ds_IntMap
_hx_classes["haxe.ds.IntMap"] = haxe_ds_IntMap


class haxe_ds_List:
    _hx_class_name = "haxe.ds.List"
    __slots__ = ("h", "q", "length")
    _hx_fields = ["h", "q", "length"]
    _hx_methods = ["add", "push", "pop"]

    def __init__(self):
        self.q = None
        self.h = None
        self.length = 0

    def add(self,item):
        x = haxe_ds__List_ListNode(item,None)
        if (self.h is None):
            self.h = x
        else:
            self.q.next = x
        self.q = x
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.length
        _hx_local_0.length = (_hx_local_1 + 1)
        _hx_local_1

    def push(self,item):
        x = haxe_ds__List_ListNode(item,self.h)
        self.h = x
        if (self.q is None):
            self.q = x
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.length
        _hx_local_0.length = (_hx_local_1 + 1)
        _hx_local_1

    def pop(self):
        if (self.h is None):
            return None
        x = self.h.item
        self.h = self.h.next
        if (self.h is None):
            self.q = None
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.length
        _hx_local_0.length = (_hx_local_1 - 1)
        _hx_local_1
        return x

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.h = None
        _hx_o.q = None
        _hx_o.length = None
haxe_ds_List._hx_class = haxe_ds_List
_hx_classes["haxe.ds.List"] = haxe_ds_List


class haxe_ds__List_ListNode:
    _hx_class_name = "haxe.ds._List.ListNode"
    __slots__ = ("item", "next")
    _hx_fields = ["item", "next"]

    def __init__(self,item,next):
        self.item = item
        self.next = next

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.item = None
        _hx_o.next = None
haxe_ds__List_ListNode._hx_class = haxe_ds__List_ListNode
_hx_classes["haxe.ds._List.ListNode"] = haxe_ds__List_ListNode


class haxe_ds_ObjectMap:
    _hx_class_name = "haxe.ds.ObjectMap"
    __slots__ = ("h",)
    _hx_fields = ["h"]
    _hx_methods = ["set", "keys"]
    _hx_interfaces = [haxe_IMap]

    def __init__(self):
        self.h = dict()

    def set(self,key,value):
        self.h[key] = value

    def keys(self):
        return python_HaxeIterator(iter(self.h.keys()))

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.h = None
haxe_ds_ObjectMap._hx_class = haxe_ds_ObjectMap
_hx_classes["haxe.ds.ObjectMap"] = haxe_ds_ObjectMap

class haxe_ds_Option(Enum):
    __slots__ = ()
    _hx_class_name = "haxe.ds.Option"
    _hx_constructs = ["Some", "None"]

    @staticmethod
    def Some(v):
        return haxe_ds_Option("Some", 0, [v])
haxe_ds_Option._hx_None = haxe_ds_Option("None", 1, list())
haxe_ds_Option._hx_class = haxe_ds_Option
_hx_classes["haxe.ds.Option"] = haxe_ds_Option


class haxe_format_JsonPrinter:
    _hx_class_name = "haxe.format.JsonPrinter"
    __slots__ = ("buf", "replacer", "indent", "pretty", "nind")
    _hx_fields = ["buf", "replacer", "indent", "pretty", "nind"]
    _hx_methods = ["write", "classString", "fieldsString", "quote"]
    _hx_statics = ["print"]

    def __init__(self,replacer,space):
        self.replacer = replacer
        self.indent = space
        self.pretty = (space is not None)
        self.nind = 0
        self.buf = StringBuf()

    def write(self,k,v):
        if (self.replacer is not None):
            v = self.replacer(k,v)
        _g = Type.typeof(v)
        tmp = _g.index
        if (tmp == 0):
            self.buf.b.write("null")
        elif (tmp == 1):
            _this = self.buf
            s = Std.string(v)
            _this.b.write(s)
        elif (tmp == 2):
            f = v
            v1 = (v if ((((f != Math.POSITIVE_INFINITY) and ((f != Math.NEGATIVE_INFINITY))) and (not python_lib_Math.isnan(f)))) else "null")
            _this1 = self.buf
            s1 = Std.string(v1)
            _this1.b.write(s1)
        elif (tmp == 3):
            _this2 = self.buf
            s2 = Std.string(v)
            _this2.b.write(s2)
        elif (tmp == 4):
            self.fieldsString(v,python_Boot.fields(v))
        elif (tmp == 5):
            self.buf.b.write("\"<fun>\"")
        elif (tmp == 6):
            c = _g.params[0]
            if (c == str):
                self.quote(v)
            elif (c == list):
                v2 = v
                _this3 = self.buf
                s3 = "".join(map(chr,[91]))
                _this3.b.write(s3)
                _hx_len = len(v2)
                last = (_hx_len - 1)
                _g1 = 0
                while (_g1 < _hx_len):
                    i = _g1
                    _g1 = (_g1 + 1)
                    if (i > 0):
                        _this4 = self.buf
                        s4 = "".join(map(chr,[44]))
                        _this4.b.write(s4)
                    else:
                        _hx_local_0 = self
                        _hx_local_1 = _hx_local_0.nind
                        _hx_local_0.nind = (_hx_local_1 + 1)
                        _hx_local_1
                    if self.pretty:
                        _this5 = self.buf
                        s5 = "".join(map(chr,[10]))
                        _this5.b.write(s5)
                    if self.pretty:
                        v3 = StringTools.lpad("",self.indent,(self.nind * len(self.indent)))
                        _this6 = self.buf
                        s6 = Std.string(v3)
                        _this6.b.write(s6)
                    self.write(i,(v2[i] if i >= 0 and i < len(v2) else None))
                    if (i == last):
                        _hx_local_2 = self
                        _hx_local_3 = _hx_local_2.nind
                        _hx_local_2.nind = (_hx_local_3 - 1)
                        _hx_local_3
                        if self.pretty:
                            _this7 = self.buf
                            s7 = "".join(map(chr,[10]))
                            _this7.b.write(s7)
                        if self.pretty:
                            v4 = StringTools.lpad("",self.indent,(self.nind * len(self.indent)))
                            _this8 = self.buf
                            s8 = Std.string(v4)
                            _this8.b.write(s8)
                _this9 = self.buf
                s9 = "".join(map(chr,[93]))
                _this9.b.write(s9)
            elif (c == haxe_ds_StringMap):
                v5 = v
                o = _hx_AnonObject({})
                k1 = v5.keys()
                while k1.hasNext():
                    k2 = k1.next()
                    value = v5.h.get(k2,None)
                    setattr(o,(("_hx_" + k2) if ((k2 in python_Boot.keywords)) else (("_hx_" + k2) if (((((len(k2) > 2) and ((ord(k2[0]) == 95))) and ((ord(k2[1]) == 95))) and ((ord(k2[(len(k2) - 1)]) != 95)))) else k2)),value)
                v6 = o
                self.fieldsString(v6,python_Boot.fields(v6))
            elif (c == Date):
                self.quote(v.toString())
            else:
                self.classString(v)
        elif (tmp == 7):
            _this10 = self.buf
            s10 = Std.string(v.index)
            _this10.b.write(s10)
        elif (tmp == 8):
            self.buf.b.write("\"???\"")
        else:
            pass

    def classString(self,v):
        self.fieldsString(v,python_Boot.getInstanceFields(Type.getClass(v)))

    def fieldsString(self,v,fields):
        _this = self.buf
        s = "".join(map(chr,[123]))
        _this.b.write(s)
        _hx_len = len(fields)
        last = (_hx_len - 1)
        first = True
        _g = 0
        while (_g < _hx_len):
            i = _g
            _g = (_g + 1)
            f = (fields[i] if i >= 0 and i < len(fields) else None)
            value = Reflect.field(v,f)
            if Reflect.isFunction(value):
                continue
            if first:
                _hx_local_0 = self
                _hx_local_1 = _hx_local_0.nind
                _hx_local_0.nind = (_hx_local_1 + 1)
                _hx_local_1
                first = False
            else:
                _this1 = self.buf
                s1 = "".join(map(chr,[44]))
                _this1.b.write(s1)
            if self.pretty:
                _this2 = self.buf
                s2 = "".join(map(chr,[10]))
                _this2.b.write(s2)
            if self.pretty:
                v1 = StringTools.lpad("",self.indent,(self.nind * len(self.indent)))
                _this3 = self.buf
                s3 = Std.string(v1)
                _this3.b.write(s3)
            self.quote(f)
            _this4 = self.buf
            s4 = "".join(map(chr,[58]))
            _this4.b.write(s4)
            if self.pretty:
                _this5 = self.buf
                s5 = "".join(map(chr,[32]))
                _this5.b.write(s5)
            self.write(f,value)
            if (i == last):
                _hx_local_2 = self
                _hx_local_3 = _hx_local_2.nind
                _hx_local_2.nind = (_hx_local_3 - 1)
                _hx_local_3
                if self.pretty:
                    _this6 = self.buf
                    s6 = "".join(map(chr,[10]))
                    _this6.b.write(s6)
                if self.pretty:
                    v2 = StringTools.lpad("",self.indent,(self.nind * len(self.indent)))
                    _this7 = self.buf
                    s7 = Std.string(v2)
                    _this7.b.write(s7)
        _this8 = self.buf
        s8 = "".join(map(chr,[125]))
        _this8.b.write(s8)

    def quote(self,s):
        _this = self.buf
        s1 = "".join(map(chr,[34]))
        _this.b.write(s1)
        i = 0
        while True:
            index = i
            i = (i + 1)
            c = (-1 if ((index >= len(s))) else ord(s[index]))
            if (c == -1):
                break
            c1 = c
            if (c1 == 8):
                self.buf.b.write("\\b")
            elif (c1 == 9):
                self.buf.b.write("\\t")
            elif (c1 == 10):
                self.buf.b.write("\\n")
            elif (c1 == 12):
                self.buf.b.write("\\f")
            elif (c1 == 13):
                self.buf.b.write("\\r")
            elif (c1 == 34):
                self.buf.b.write("\\\"")
            elif (c1 == 92):
                self.buf.b.write("\\\\")
            else:
                _this1 = self.buf
                s2 = "".join(map(chr,[c]))
                _this1.b.write(s2)
        _this2 = self.buf
        s3 = "".join(map(chr,[34]))
        _this2.b.write(s3)

    @staticmethod
    def print(o,replacer = None,space = None):
        printer = haxe_format_JsonPrinter(replacer,space)
        printer.write("",o)
        return printer.buf.b.getvalue()

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.buf = None
        _hx_o.replacer = None
        _hx_o.indent = None
        _hx_o.pretty = None
        _hx_o.nind = None
haxe_format_JsonPrinter._hx_class = haxe_format_JsonPrinter
_hx_classes["haxe.format.JsonPrinter"] = haxe_format_JsonPrinter


class haxe_http_HttpBase:
    _hx_class_name = "haxe.http.HttpBase"
    _hx_fields = ["url", "responseData", "postData", "headers", "params"]
    _hx_methods = ["onData", "onError", "onStatus"]

    def __init__(self,url):
        self.postData = None
        self.responseData = None
        self.url = url
        self.headers = []
        self.params = []

    def onData(self,data):
        pass

    def onError(self,msg):
        pass

    def onStatus(self,status):
        pass

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.url = None
        _hx_o.responseData = None
        _hx_o.postData = None
        _hx_o.headers = None
        _hx_o.params = None
haxe_http_HttpBase._hx_class = haxe_http_HttpBase
_hx_classes["haxe.http.HttpBase"] = haxe_http_HttpBase


class haxe_io_Bytes:
    _hx_class_name = "haxe.io.Bytes"
    __slots__ = ("length", "b")
    _hx_fields = ["length", "b"]
    _hx_methods = ["blit", "sub", "getString", "toString"]
    _hx_statics = ["alloc", "ofString", "ofData"]

    def __init__(self,length,b):
        self.length = length
        self.b = b

    def blit(self,pos,src,srcpos,_hx_len):
        if (((((pos < 0) or ((srcpos < 0))) or ((_hx_len < 0))) or (((pos + _hx_len) > self.length))) or (((srcpos + _hx_len) > src.length))):
            raise _HxException(haxe_io_Error.OutsideBounds)
        self.b[pos:pos+_hx_len] = src.b[srcpos:srcpos+_hx_len]

    def sub(self,pos,_hx_len):
        if (((pos < 0) or ((_hx_len < 0))) or (((pos + _hx_len) > self.length))):
            raise _HxException(haxe_io_Error.OutsideBounds)
        return haxe_io_Bytes(_hx_len,self.b[pos:(pos + _hx_len)])

    def getString(self,pos,_hx_len,encoding = None):
        if (((pos < 0) or ((_hx_len < 0))) or (((pos + _hx_len) > self.length))):
            raise _HxException(haxe_io_Error.OutsideBounds)
        return self.b[pos:pos+_hx_len].decode('UTF-8','replace')

    def toString(self):
        return self.getString(0,self.length)

    @staticmethod
    def alloc(length):
        return haxe_io_Bytes(length,bytearray(length))

    @staticmethod
    def ofString(s,encoding = None):
        b = bytearray(s,"UTF-8")
        return haxe_io_Bytes(len(b),b)

    @staticmethod
    def ofData(b):
        return haxe_io_Bytes(len(b),b)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.length = None
        _hx_o.b = None
haxe_io_Bytes._hx_class = haxe_io_Bytes
_hx_classes["haxe.io.Bytes"] = haxe_io_Bytes


class haxe_io_BytesBuffer:
    _hx_class_name = "haxe.io.BytesBuffer"
    __slots__ = ("b",)
    _hx_fields = ["b"]
    _hx_methods = ["getBytes"]

    def __init__(self):
        self.b = list()

    def getBytes(self):
        buf = bytearray(self.b)
        _hx_bytes = haxe_io_Bytes(len(buf),buf)
        self.b = None
        return _hx_bytes

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.b = None
        _hx_o.length = None
haxe_io_BytesBuffer._hx_class = haxe_io_BytesBuffer
_hx_classes["haxe.io.BytesBuffer"] = haxe_io_BytesBuffer


class haxe_io_BytesInput(haxe_io_Input):
    _hx_class_name = "haxe.io.BytesInput"
    __slots__ = ("b", "pos", "len", "totlen")
    _hx_fields = ["b", "pos", "len", "totlen"]
    _hx_methods = ["readByte", "readBytes"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = haxe_io_Input


    def __init__(self,b,pos = None,_hx_len = None):
        if (pos is None):
            pos = 0
        if (_hx_len is None):
            _hx_len = (b.length - pos)
        if (((pos < 0) or ((_hx_len < 0))) or (((pos + _hx_len) > b.length))):
            raise _HxException(haxe_io_Error.OutsideBounds)
        self.b = b.b
        self.pos = pos
        self.len = _hx_len
        self.totlen = _hx_len
        self.set_bigEndian(False)

    def readByte(self):
        if (self.len == 0):
            raise _HxException(haxe_io_Eof())
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.len
        _hx_local_0.len = (_hx_local_1 - 1)
        _hx_local_1
        def _hx_local_5():
            def _hx_local_4():
                _hx_local_2 = self
                _hx_local_3 = _hx_local_2.pos
                _hx_local_2.pos = (_hx_local_3 + 1)
                return _hx_local_3
            return self.b[_hx_local_4()]
        return _hx_local_5()

    def readBytes(self,buf,pos,_hx_len):
        if (((pos < 0) or ((_hx_len < 0))) or (((pos + _hx_len) > buf.length))):
            raise _HxException(haxe_io_Error.OutsideBounds)
        if ((self.len == 0) and ((_hx_len > 0))):
            raise _HxException(haxe_io_Eof())
        if (self.len < _hx_len):
            _hx_len = self.len
        b1 = self.b
        b2 = buf.b
        _g = 0
        _g1 = _hx_len
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            b2[(pos + i)] = b1[(self.pos + i)]
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.pos
        _hx_local_0.pos = (_hx_local_1 + _hx_len)
        _hx_local_0.pos
        _hx_local_2 = self
        _hx_local_3 = _hx_local_2.len
        _hx_local_2.len = (_hx_local_3 - _hx_len)
        _hx_local_2.len
        return _hx_len

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.b = None
        _hx_o.pos = None
        _hx_o.len = None
        _hx_o.totlen = None
        _hx_o.position = None
        _hx_o.length = None
haxe_io_BytesInput._hx_class = haxe_io_BytesInput
_hx_classes["haxe.io.BytesInput"] = haxe_io_BytesInput


class haxe_io_BytesOutput(haxe_io_Output):
    _hx_class_name = "haxe.io.BytesOutput"
    __slots__ = ("b",)
    _hx_fields = ["b"]
    _hx_methods = ["writeByte", "writeBytes", "getBytes"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = haxe_io_Output


    def __init__(self):
        self.b = haxe_io_BytesBuffer()
        self.set_bigEndian(False)

    def writeByte(self,c):
        self.b.b.append(c)

    def writeBytes(self,buf,pos,_hx_len):
        _this = self.b
        if (((pos < 0) or ((_hx_len < 0))) or (((pos + _hx_len) > buf.length))):
            raise _HxException(haxe_io_Error.OutsideBounds)
        b2 = buf.b
        _g = pos
        _g1 = (pos + _hx_len)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            _this.b.append(b2[i])
        return _hx_len

    def getBytes(self):
        return self.b.getBytes()

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.b = None
        _hx_o.length = None
haxe_io_BytesOutput._hx_class = haxe_io_BytesOutput
_hx_classes["haxe.io.BytesOutput"] = haxe_io_BytesOutput

class haxe_io_Encoding(Enum):
    __slots__ = ()
    _hx_class_name = "haxe.io.Encoding"
    _hx_constructs = ["UTF8", "RawNative"]
haxe_io_Encoding.UTF8 = haxe_io_Encoding("UTF8", 0, list())
haxe_io_Encoding.RawNative = haxe_io_Encoding("RawNative", 1, list())
haxe_io_Encoding._hx_class = haxe_io_Encoding
_hx_classes["haxe.io.Encoding"] = haxe_io_Encoding


class haxe_io_Eof:
    _hx_class_name = "haxe.io.Eof"
    __slots__ = ()
    _hx_methods = ["toString"]

    def __init__(self):
        pass

    def toString(self):
        return "Eof"

    @staticmethod
    def _hx_empty_init(_hx_o):        pass
haxe_io_Eof._hx_class = haxe_io_Eof
_hx_classes["haxe.io.Eof"] = haxe_io_Eof

class haxe_io_Error(Enum):
    __slots__ = ()
    _hx_class_name = "haxe.io.Error"
    _hx_constructs = ["Blocked", "Overflow", "OutsideBounds", "Custom"]

    @staticmethod
    def Custom(e):
        return haxe_io_Error("Custom", 3, [e])
haxe_io_Error.Blocked = haxe_io_Error("Blocked", 0, list())
haxe_io_Error.Overflow = haxe_io_Error("Overflow", 1, list())
haxe_io_Error.OutsideBounds = haxe_io_Error("OutsideBounds", 2, list())
haxe_io_Error._hx_class = haxe_io_Error
_hx_classes["haxe.io.Error"] = haxe_io_Error


class haxe_macro_Printer:
    _hx_class_name = "haxe.macro.Printer"
    __slots__ = ("tabs", "tabString")
    _hx_fields = ["tabs", "tabString"]

    def __init__(self,tabString = "\t"):
        if (tabString is None):
            tabString = "\t"
        self.tabs = ""
        self.tabString = tabString

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.tabs = None
        _hx_o.tabString = None
haxe_macro_Printer._hx_class = haxe_macro_Printer
_hx_classes["haxe.macro.Printer"] = haxe_macro_Printer


class haxe_zip_Compress:
    _hx_class_name = "haxe.zip.Compress"
    __slots__ = ()
    _hx_statics = ["run"]

    @staticmethod
    def run(s,level):
        raise _HxException("Not implemented for this platform")
haxe_zip_Compress._hx_class = haxe_zip_Compress
_hx_classes["haxe.zip.Compress"] = haxe_zip_Compress

class haxe_zip_Huffman(Enum):
    __slots__ = ()
    _hx_class_name = "haxe.zip.Huffman"
    _hx_constructs = ["Found", "NeedBit", "NeedBits"]

    @staticmethod
    def Found(i):
        return haxe_zip_Huffman("Found", 0, [i])

    @staticmethod
    def NeedBit(left,right):
        return haxe_zip_Huffman("NeedBit", 1, [left,right])

    @staticmethod
    def NeedBits(n,table):
        return haxe_zip_Huffman("NeedBits", 2, [n,table])
haxe_zip_Huffman._hx_class = haxe_zip_Huffman
_hx_classes["haxe.zip.Huffman"] = haxe_zip_Huffman


class haxe_zip_HuffTools:
    _hx_class_name = "haxe.zip.HuffTools"
    __slots__ = ()
    _hx_methods = ["treeDepth", "treeCompress", "treeWalk", "treeMake", "make"]

    def __init__(self):
        pass

    def treeDepth(self,t):
        tmp = t.index
        if (tmp == 0):
            return 0
        elif (tmp == 1):
            da = self.treeDepth(t.params[0])
            db = self.treeDepth(t.params[1])
            return (1 + ((da if ((da < db)) else db)))
        elif (tmp == 2):
            raise _HxException("assert")
        else:
            pass

    def treeCompress(self,t):
        d = self.treeDepth(t)
        if (d == 0):
            return t
        if (d == 1):
            if (t.index == 1):
                return haxe_zip_Huffman.NeedBit(self.treeCompress(t.params[0]),self.treeCompress(t.params[1]))
            else:
                raise _HxException("assert")
        size = (1 << d)
        table = list()
        _g = 0
        while (_g < size):
            _g = (_g + 1)
            table.append(haxe_zip_Huffman.Found(-1))
        self.treeWalk(table,0,0,d,t)
        return haxe_zip_Huffman.NeedBits(d,table)

    def treeWalk(self,table,p,cd,d,t):
        if (t.index == 1):
            if (d > 0):
                self.treeWalk(table,p,(cd + 1),(d - 1),t.params[0])
                self.treeWalk(table,(p | ((1 << cd))),(cd + 1),(d - 1),t.params[1])
            else:
                python_internal_ArrayImpl._set(table, p, self.treeCompress(t))
        else:
            python_internal_ArrayImpl._set(table, p, self.treeCompress(t))

    def treeMake(self,bits,maxbits,v,_hx_len):
        if (_hx_len > maxbits):
            raise _HxException("Invalid huffman")
        idx = ((v << 5) | _hx_len)
        if (idx in bits.h):
            return haxe_zip_Huffman.Found(bits.h.get(idx,None))
        v = (v << 1)
        _hx_len = (_hx_len + 1)
        return haxe_zip_Huffman.NeedBit(self.treeMake(bits,maxbits,v,_hx_len),self.treeMake(bits,maxbits,(v | 1),_hx_len))

    def make(self,lengths,pos,nlengths,maxbits):
        counts = list()
        tmp = list()
        if (maxbits > 32):
            raise _HxException("Invalid huffman")
        _g = 0
        while (_g < maxbits):
            _g = (_g + 1)
            counts.append(0)
            tmp.append(0)
        _g2 = 0
        while (_g2 < nlengths):
            i = _g2
            _g2 = (_g2 + 1)
            p = python_internal_ArrayImpl._get(lengths, (i + pos))
            if (p >= maxbits):
                raise _HxException("Invalid huffman")
            python_internal_ArrayImpl._set(counts, p, ((counts[p] if p >= 0 and p < len(counts) else None) + 1))
        code = 0
        _g4 = 1
        _g5 = (maxbits - 1)
        while (_g4 < _g5):
            i1 = _g4
            _g4 = (_g4 + 1)
            code = ((code + (counts[i1] if i1 >= 0 and i1 < len(counts) else None)) << 1)
            python_internal_ArrayImpl._set(tmp, i1, code)
        bits = haxe_ds_IntMap()
        _g6 = 0
        while (_g6 < nlengths):
            i2 = _g6
            _g6 = (_g6 + 1)
            l = python_internal_ArrayImpl._get(lengths, (i2 + pos))
            if (l != 0):
                n = python_internal_ArrayImpl._get(tmp, (l - 1))
                python_internal_ArrayImpl._set(tmp, (l - 1), (n + 1))
                bits.set(((n << 5) | l),i2)
        return self.treeCompress(haxe_zip_Huffman.NeedBit(self.treeMake(bits,maxbits,0,1),self.treeMake(bits,maxbits,1,1)))

    @staticmethod
    def _hx_empty_init(_hx_o):        pass
haxe_zip_HuffTools._hx_class = haxe_zip_HuffTools
_hx_classes["haxe.zip.HuffTools"] = haxe_zip_HuffTools


class haxe_zip__InflateImpl_Window:
    _hx_class_name = "haxe.zip._InflateImpl.Window"
    __slots__ = ("buffer", "pos", "crc")
    _hx_fields = ["buffer", "pos", "crc"]
    _hx_methods = ["slide", "addBytes", "addByte", "getLastChar", "available", "checksum"]

    def __init__(self,hasCrc):
        self.crc = None
        self.buffer = haxe_io_Bytes.alloc(65536)
        self.pos = 0
        if hasCrc:
            self.crc = haxe_crypto_Adler32()

    def slide(self):
        if (self.crc is not None):
            self.crc.update(self.buffer,0,32768)
        b = haxe_io_Bytes.alloc(65536)
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.pos
        _hx_local_0.pos = (_hx_local_1 - 32768)
        _hx_local_0.pos
        b.blit(0,self.buffer,32768,self.pos)
        self.buffer = b

    def addBytes(self,b,p,_hx_len):
        if ((self.pos + _hx_len) > 65536):
            self.slide()
        self.buffer.blit(self.pos,b,p,_hx_len)
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.pos
        _hx_local_0.pos = (_hx_local_1 + _hx_len)
        _hx_local_0.pos

    def addByte(self,c):
        if (self.pos == 65536):
            self.slide()
        self.buffer.b[self.pos] = (c & 255)
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.pos
        _hx_local_0.pos = (_hx_local_1 + 1)
        _hx_local_1

    def getLastChar(self):
        return self.buffer.b[(self.pos - 1)]

    def available(self):
        return self.pos

    def checksum(self):
        if (self.crc is not None):
            self.crc.update(self.buffer,0,self.pos)
        return self.crc

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.buffer = None
        _hx_o.pos = None
        _hx_o.crc = None
haxe_zip__InflateImpl_Window._hx_class = haxe_zip__InflateImpl_Window
_hx_classes["haxe.zip._InflateImpl.Window"] = haxe_zip__InflateImpl_Window

class haxe_zip__InflateImpl_State(Enum):
    __slots__ = ()
    _hx_class_name = "haxe.zip._InflateImpl.State"
    _hx_constructs = ["Head", "Block", "CData", "Flat", "Crc", "Dist", "DistOne", "Done"]
haxe_zip__InflateImpl_State.Head = haxe_zip__InflateImpl_State("Head", 0, list())
haxe_zip__InflateImpl_State.Block = haxe_zip__InflateImpl_State("Block", 1, list())
haxe_zip__InflateImpl_State.CData = haxe_zip__InflateImpl_State("CData", 2, list())
haxe_zip__InflateImpl_State.Flat = haxe_zip__InflateImpl_State("Flat", 3, list())
haxe_zip__InflateImpl_State.Crc = haxe_zip__InflateImpl_State("Crc", 4, list())
haxe_zip__InflateImpl_State.Dist = haxe_zip__InflateImpl_State("Dist", 5, list())
haxe_zip__InflateImpl_State.DistOne = haxe_zip__InflateImpl_State("DistOne", 6, list())
haxe_zip__InflateImpl_State.Done = haxe_zip__InflateImpl_State("Done", 7, list())
haxe_zip__InflateImpl_State._hx_class = haxe_zip__InflateImpl_State
_hx_classes["haxe.zip._InflateImpl.State"] = haxe_zip__InflateImpl_State


class haxe_zip_InflateImpl:
    _hx_class_name = "haxe.zip.InflateImpl"
    __slots__ = ("nbits", "bits", "state", "isFinal", "huffman", "huffdist", "htools", "len", "dist", "needed", "output", "outpos", "input", "lengths", "window")
    _hx_fields = ["nbits", "bits", "state", "isFinal", "huffman", "huffdist", "htools", "len", "dist", "needed", "output", "outpos", "input", "lengths", "window"]
    _hx_methods = ["buildFixedHuffman", "readBytes", "getBits", "getBit", "getRevBits", "resetBits", "addBytes", "addByte", "addDistOne", "addDist", "applyHuffman", "inflateLengths", "inflateLoop"]
    _hx_statics = ["LEN_EXTRA_BITS_TBL", "LEN_BASE_VAL_TBL", "DIST_EXTRA_BITS_TBL", "DIST_BASE_VAL_TBL", "CODE_LENGTHS_POS", "FIXED_HUFFMAN", "run"]

    def __init__(self,i,header = True,crc = True):
        if (header is None):
            header = True
        if (crc is None):
            crc = True
        self.window = None
        self.lengths = None
        self.input = None
        self.outpos = None
        self.output = None
        self.needed = None
        self.dist = None
        self.len = None
        self.huffdist = None
        self.huffman = None
        self.state = None
        self.bits = None
        self.nbits = None
        self.isFinal = False
        self.htools = haxe_zip_HuffTools()
        self.huffman = self.buildFixedHuffman()
        self.huffdist = None
        self.len = 0
        self.dist = 0
        self.state = (haxe_zip__InflateImpl_State.Head if header else haxe_zip__InflateImpl_State.Block)
        self.input = i
        self.bits = 0
        self.nbits = 0
        self.needed = 0
        self.output = None
        self.outpos = 0
        self.lengths = list()
        self.lengths.append(-1)
        self.lengths.append(-1)
        self.lengths.append(-1)
        self.lengths.append(-1)
        self.lengths.append(-1)
        self.lengths.append(-1)
        self.lengths.append(-1)
        self.lengths.append(-1)
        self.lengths.append(-1)
        self.lengths.append(-1)
        self.lengths.append(-1)
        self.lengths.append(-1)
        self.lengths.append(-1)
        self.lengths.append(-1)
        self.lengths.append(-1)
        self.lengths.append(-1)
        self.lengths.append(-1)
        self.lengths.append(-1)
        self.lengths.append(-1)
        self.window = haxe_zip__InflateImpl_Window(crc)

    def buildFixedHuffman(self):
        if (haxe_zip_InflateImpl.FIXED_HUFFMAN is not None):
            return haxe_zip_InflateImpl.FIXED_HUFFMAN
        a = list()
        _g = 0
        while (_g < 288):
            n = _g
            _g = (_g + 1)
            a.append((8 if ((n <= 143)) else (9 if ((n <= 255)) else (7 if ((n <= 279)) else 8))))
        haxe_zip_InflateImpl.FIXED_HUFFMAN = self.htools.make(a,0,288,10)
        return haxe_zip_InflateImpl.FIXED_HUFFMAN

    def readBytes(self,b,pos,_hx_len):
        self.needed = _hx_len
        self.outpos = pos
        self.output = b
        if (_hx_len > 0):
            while self.inflateLoop():
                pass
        return (_hx_len - self.needed)

    def getBits(self,n):
        while (self.nbits < n):
            _hx_local_0 = self
            _hx_local_1 = _hx_local_0.bits
            _hx_local_0.bits = (_hx_local_1 | ((self.input.readByte() << self.nbits)))
            _hx_local_0.bits
            _hx_local_2 = self
            _hx_local_3 = _hx_local_2.nbits
            _hx_local_2.nbits = (_hx_local_3 + 8)
            _hx_local_2.nbits
        b = (self.bits & ((((1 << n)) - 1)))
        _hx_local_4 = self
        _hx_local_5 = _hx_local_4.nbits
        _hx_local_4.nbits = (_hx_local_5 - n)
        _hx_local_4.nbits
        _hx_local_6 = self
        _hx_local_7 = _hx_local_6.bits
        _hx_local_6.bits = (_hx_local_7 >> n)
        _hx_local_6.bits
        return b

    def getBit(self):
        if (self.nbits == 0):
            self.nbits = 8
            self.bits = self.input.readByte()
        b = (((self.bits & 1)) == 1)
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.nbits
        _hx_local_0.nbits = (_hx_local_1 - 1)
        _hx_local_1
        _hx_local_2 = self
        _hx_local_3 = _hx_local_2.bits
        _hx_local_2.bits = (_hx_local_3 >> 1)
        _hx_local_2.bits
        return b

    def getRevBits(self,n):
        if (n == 0):
            return 0
        elif self.getBit():
            return ((1 << ((n - 1))) | self.getRevBits((n - 1)))
        else:
            return self.getRevBits((n - 1))

    def resetBits(self):
        self.bits = 0
        self.nbits = 0

    def addBytes(self,b,p,_hx_len):
        self.window.addBytes(b,p,_hx_len)
        self.output.blit(self.outpos,b,p,_hx_len)
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.needed
        _hx_local_0.needed = (_hx_local_1 - _hx_len)
        _hx_local_0.needed
        _hx_local_2 = self
        _hx_local_3 = _hx_local_2.outpos
        _hx_local_2.outpos = (_hx_local_3 + _hx_len)
        _hx_local_2.outpos

    def addByte(self,b):
        self.window.addByte(b)
        self.output.b[self.outpos] = (b & 255)
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.needed
        _hx_local_0.needed = (_hx_local_1 - 1)
        _hx_local_1
        _hx_local_2 = self
        _hx_local_3 = _hx_local_2.outpos
        _hx_local_2.outpos = (_hx_local_3 + 1)
        _hx_local_3

    def addDistOne(self,n):
        c = self.window.getLastChar()
        _g = 0
        while (_g < n):
            _g = (_g + 1)
            self.addByte(c)

    def addDist(self,d,_hx_len):
        self.addBytes(self.window.buffer,(self.window.pos - d),_hx_len)

    def applyHuffman(self,h):
        tmp = h.index
        if (tmp == 0):
            return h.params[0]
        elif (tmp == 1):
            return self.applyHuffman((h.params[1] if (self.getBit()) else h.params[0]))
        elif (tmp == 2):
            return self.applyHuffman(python_internal_ArrayImpl._get(h.params[1], self.getBits(h.params[0])))
        else:
            pass

    def inflateLengths(self,a,_hx_max):
        i = 0
        prev = 0
        while (i < _hx_max):
            n = self.applyHuffman(self.huffman)
            if ((((((((((((((((n == 15) or ((n == 14))) or ((n == 13))) or ((n == 12))) or ((n == 11))) or ((n == 10))) or ((n == 9))) or ((n == 8))) or ((n == 7))) or ((n == 6))) or ((n == 5))) or ((n == 4))) or ((n == 3))) or ((n == 2))) or ((n == 1))) or ((n == 0))):
                prev = n
                python_internal_ArrayImpl._set(a, i, n)
                i = (i + 1)
            elif (n == 16):
                end = ((i + 3) + self.getBits(2))
                if (end > _hx_max):
                    raise _HxException("Invalid data")
                while (i < end):
                    python_internal_ArrayImpl._set(a, i, prev)
                    i = (i + 1)
            elif (n == 17):
                i = (i + ((3 + self.getBits(3))))
                if (i > _hx_max):
                    raise _HxException("Invalid data")
            elif (n == 18):
                i = (i + ((11 + self.getBits(7))))
                if (i > _hx_max):
                    raise _HxException("Invalid data")
            else:
                raise _HxException("Invalid data")

    def inflateLoop(self):
        tmp = self.state.index
        if (tmp == 0):
            cmf = self.input.readByte()
            if (((cmf & 15)) != 8):
                raise _HxException("Invalid data")
            flg = self.input.readByte()
            if (HxOverrides.mod(((((cmf << 8)) + flg)), 31) != 0):
                raise _HxException("Invalid data")
            if (((flg & 32)) != 0):
                raise _HxException("Unsupported dictionary")
            self.state = haxe_zip__InflateImpl_State.Block
            return True
        elif (tmp == 1):
            self.isFinal = self.getBit()
            _g = self.getBits(2)
            if (_g == 0):
                self.len = self.input.readUInt16()
                if (self.input.readUInt16() != ((65535 - self.len))):
                    raise _HxException("Invalid data")
                self.state = haxe_zip__InflateImpl_State.Flat
                r = self.inflateLoop()
                self.resetBits()
                return r
            elif (_g == 1):
                self.huffman = self.buildFixedHuffman()
                self.huffdist = None
                self.state = haxe_zip__InflateImpl_State.CData
                return True
            elif (_g == 2):
                hlit = (self.getBits(5) + 257)
                hdist = (self.getBits(5) + 1)
                hclen = (self.getBits(4) + 4)
                _g1 = 0
                while (_g1 < hclen):
                    i = _g1
                    _g1 = (_g1 + 1)
                    python_internal_ArrayImpl._set(self.lengths, python_internal_ArrayImpl._get(haxe_zip_InflateImpl.CODE_LENGTHS_POS, i), self.getBits(3))
                _g2 = hclen
                while (_g2 < 19):
                    i1 = _g2
                    _g2 = (_g2 + 1)
                    python_internal_ArrayImpl._set(self.lengths, python_internal_ArrayImpl._get(haxe_zip_InflateImpl.CODE_LENGTHS_POS, i1), 0)
                self.huffman = self.htools.make(self.lengths,0,19,8)
                lengths = list()
                _g4 = 0
                _g5 = (hlit + hdist)
                while (_g4 < _g5):
                    _g4 = (_g4 + 1)
                    lengths.append(0)
                self.inflateLengths(lengths,(hlit + hdist))
                self.huffdist = self.htools.make(lengths,hlit,hdist,16)
                self.huffman = self.htools.make(lengths,0,hlit,16)
                self.state = haxe_zip__InflateImpl_State.CData
                return True
            else:
                raise _HxException("Invalid data")
        elif (tmp == 2):
            n = self.applyHuffman(self.huffman)
            if (n < 256):
                self.addByte(n)
                return (self.needed > 0)
            elif (n == 256):
                self.state = (haxe_zip__InflateImpl_State.Crc if (self.isFinal) else haxe_zip__InflateImpl_State.Block)
                return True
            else:
                n = (n - 257)
                extra_bits = python_internal_ArrayImpl._get(haxe_zip_InflateImpl.LEN_EXTRA_BITS_TBL, n)
                if (extra_bits == -1):
                    raise _HxException("Invalid data")
                self.len = (python_internal_ArrayImpl._get(haxe_zip_InflateImpl.LEN_BASE_VAL_TBL, n) + self.getBits(extra_bits))
                dist_code = (self.getRevBits(5) if ((self.huffdist is None)) else self.applyHuffman(self.huffdist))
                extra_bits = python_internal_ArrayImpl._get(haxe_zip_InflateImpl.DIST_EXTRA_BITS_TBL, dist_code)
                if (extra_bits == -1):
                    raise _HxException("Invalid data")
                self.dist = (python_internal_ArrayImpl._get(haxe_zip_InflateImpl.DIST_BASE_VAL_TBL, dist_code) + self.getBits(extra_bits))
                if (self.dist > self.window.available()):
                    raise _HxException("Invalid data")
                self.state = (haxe_zip__InflateImpl_State.DistOne if ((self.dist == 1)) else haxe_zip__InflateImpl_State.Dist)
                return True
        elif (tmp == 3):
            rlen = (self.len if ((self.len < self.needed)) else self.needed)
            _hx_bytes = self.input.read(rlen)
            _hx_local_2 = self
            _hx_local_3 = _hx_local_2.len
            _hx_local_2.len = (_hx_local_3 - rlen)
            _hx_local_2.len
            self.addBytes(_hx_bytes,0,rlen)
            if (self.len == 0):
                self.state = (haxe_zip__InflateImpl_State.Crc if (self.isFinal) else haxe_zip__InflateImpl_State.Block)
            return (self.needed > 0)
        elif (tmp == 4):
            calc = self.window.checksum()
            if (calc is None):
                self.state = haxe_zip__InflateImpl_State.Done
                return True
            if (not calc.equals(haxe_crypto_Adler32.read(self.input))):
                raise _HxException("Invalid CRC")
            self.state = haxe_zip__InflateImpl_State.Done
            return True
        elif (tmp == 5):
            while ((self.len > 0) and ((self.needed > 0))):
                rdist = (self.len if ((self.len < self.dist)) else self.dist)
                rlen1 = (self.needed if ((self.needed < rdist)) else rdist)
                self.addDist(self.dist,rlen1)
                _hx_local_4 = self
                _hx_local_5 = _hx_local_4.len
                _hx_local_4.len = (_hx_local_5 - rlen1)
                _hx_local_4.len
            if (self.len == 0):
                self.state = haxe_zip__InflateImpl_State.CData
            return (self.needed > 0)
        elif (tmp == 6):
            rlen2 = (self.len if ((self.len < self.needed)) else self.needed)
            self.addDistOne(rlen2)
            _hx_local_6 = self
            _hx_local_7 = _hx_local_6.len
            _hx_local_6.len = (_hx_local_7 - rlen2)
            _hx_local_6.len
            if (self.len == 0):
                self.state = haxe_zip__InflateImpl_State.CData
            return (self.needed > 0)
        elif (tmp == 7):
            return False
        else:
            pass

    @staticmethod
    def run(i,bufsize = 65536):
        if (bufsize is None):
            bufsize = 65536
        buf = haxe_io_Bytes.alloc(bufsize)
        output = haxe_io_BytesBuffer()
        inflate = haxe_zip_InflateImpl(i)
        while True:
            _hx_len = inflate.readBytes(buf,0,bufsize)
            if ((_hx_len < 0) or ((_hx_len > buf.length))):
                raise _HxException(haxe_io_Error.OutsideBounds)
            b2 = buf.b
            _g = 0
            while (_g < _hx_len):
                i1 = _g
                _g = (_g + 1)
                output.b.append(b2[i1])
            if (_hx_len < bufsize):
                break
        return output.getBytes()

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.nbits = None
        _hx_o.bits = None
        _hx_o.state = None
        _hx_o.isFinal = None
        _hx_o.huffman = None
        _hx_o.huffdist = None
        _hx_o.htools = None
        _hx_o.len = None
        _hx_o.dist = None
        _hx_o.needed = None
        _hx_o.output = None
        _hx_o.outpos = None
        _hx_o.input = None
        _hx_o.lengths = None
        _hx_o.window = None
haxe_zip_InflateImpl._hx_class = haxe_zip_InflateImpl
_hx_classes["haxe.zip.InflateImpl"] = haxe_zip_InflateImpl


class haxe_zip_Uncompress:
    _hx_class_name = "haxe.zip.Uncompress"
    __slots__ = ()
    _hx_statics = ["run"]

    @staticmethod
    def run(src,bufsize = None):
        return haxe_zip_InflateImpl.run(haxe_io_BytesInput(src),bufsize)
haxe_zip_Uncompress._hx_class = haxe_zip_Uncompress
_hx_classes["haxe.zip.Uncompress"] = haxe_zip_Uncompress

class hxd_storage_CreateResult(Enum):
    __slots__ = ()
    _hx_class_name = "hxd.storage.CreateResult"
    _hx_constructs = ["Created", "Expect"]

    @staticmethod
    def Created(page,records):
        return hxd_storage_CreateResult("Created", 0, [page,records])

    @staticmethod
    def Expect(count):
        return hxd_storage_CreateResult("Expect", 1, [count])
hxd_storage_CreateResult._hx_class = hxd_storage_CreateResult
_hx_classes["hxd.storage.CreateResult"] = hxd_storage_CreateResult

class hxd_storage_CreateHint(Enum):
    __slots__ = ()
    _hx_class_name = "hxd.storage.CreateHint"
    _hx_constructs = ["FullPage", "PartialPage"]
hxd_storage_CreateHint.FullPage = hxd_storage_CreateHint("FullPage", 0, list())
hxd_storage_CreateHint.PartialPage = hxd_storage_CreateHint("PartialPage", 1, list())
hxd_storage_CreateHint._hx_class = hxd_storage_CreateHint
_hx_classes["hxd.storage.CreateHint"] = hxd_storage_CreateHint


class hxd_storage_Book:
    _hx_class_name = "hxd.storage.Book"
    __slots__ = ("name", "pageSize", "retention", "workers", "_writer", "_reader", "_stat", "_sizes", "serializationHooks", "deserializationHooks")
    _hx_fields = ["name", "pageSize", "retention", "workers", "_writer", "_reader", "_stat", "_sizes", "serializationHooks", "deserializationHooks"]
    _hx_methods = ["get_writer", "get_reader", "get_file", "get_stat", "get_size", "get_pages", "get_sizes", "postSerialization", "preDeserialization", "addStoragePlan", "ensure", "peek", "cleanse", "calculatePadding", "count", "read", "write", "close", "refresh", "commit", "create", "safeCreate"]
    _hx_statics = ["open"]

    def __init__(self,n):
        self._stat = None
        self._reader = None
        self._writer = None
        self.deserializationHooks = []
        self.serializationHooks = []
        self.name = n
        self.pageSize = Reflect.field(Reflect.field(hxd_sys_Engine.get_config(),"book"),"pageSize")
        self.retention = haxe_ds_IntMap()
        self._sizes = []
        self.workers = _hx_AnonObject({'allocate': tink_RunLoop.current.createSlave(), 'cache': tink_RunLoop.current.createSlave(), 'write': tink_RunLoop.current.createSlave()})

    def get_writer(self):
        self.ensure()
        if (self._writer is None):
            self._writer = _hx_AnonObject({'update': sys_io_File.update(self.get_file(),True), 'append': sys_io_File.append(self.get_file(),True)})
        elif (self._writer.update is None):
            self._writer.update = sys_io_File.update(self.get_file(),True)
        elif (self._writer.append is None):
            self._writer.append = sys_io_File.append(self.get_file(),True)
        return self._writer

    def get_reader(self):
        self.ensure()
        if (self._reader is None):
            self._reader = sys_io_File.read(self.get_file(),True)
        return self._reader

    def get_file(self):
        return (((("./" + HxOverrides.stringOrNull(hxd_sys_Engine.get_path())) + "/") + HxOverrides.stringOrNull(self.name)) + ".hxbk")

    def get_stat(self):
        hxd_sys_Engine.ensure()
        self.ensure()
        if (self._stat is None):
            self._stat = sys_FileSystem.stat(self.get_file())
        return self._stat

    def get_size(self):
        return self.get_stat().size

    def get_pages(self):
        return Math.ceil((self.get_size() / self.pageSize))

    def get_sizes(self):
        if ((self._sizes is None) or ((len(self._sizes) == 0))):
            self._sizes = self.peek()
        return self._sizes

    def postSerialization(self,_b):
        b = _b
        _g = 0
        _g1 = self.serializationHooks
        while (_g < len(_g1)):
            def _hx_local_1():
                nonlocal _g
                _hx_local_0 = _g
                _g = (_g + 1)
                return _hx_local_0
            hook = python_internal_ArrayImpl._get(_g1, _hx_local_1())
            b = hook(b)
        return b

    def preDeserialization(self,_b):
        b = _b
        _g = 0
        _g1 = self.deserializationHooks
        while (_g < len(_g1)):
            def _hx_local_1():
                nonlocal _g
                _hx_local_0 = _g
                _g = (_g + 1)
                return _hx_local_0
            hook = python_internal_ArrayImpl._get(_g1, _hx_local_1())
            b = hook(b)
        return b

    def addStoragePlan(self,serialize,deserialize):
        self.serializationHooks.append(serialize)
        self.deserializationHooks.insert(0, deserialize)

    def ensure(self):
        if (not sys_FileSystem.exists(self.get_file())):
            output = sys_io_File.write(self.get_file(),True)
            output.writeString("")
            output.flush()
            output.close()

    def peek(self):
        retVal = []
        _g = 0
        _g1 = self.get_pages()
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            self.get_reader().seek((i * self.pageSize),sys_io_FileSeek.SeekBegin)
            x = self.get_reader().readInt16()
            retVal.append(x)
        return retVal

    def cleanse(self):
        dirty = []
        pageNo = self.retention.keys()
        while pageNo.hasNext():
            pageNo1 = pageNo.next()
            page = self.retention.h.get(pageNo1,None)
            if page.dirty:
                dirty.append(page)
                self.retention.remove(pageNo1)
        return dirty

    def calculatePadding(self):
        sizes = self.peek()
        total = 0
        _g = 0
        while (_g < len(sizes)):
            def _hx_local_1():
                nonlocal _g
                _hx_local_0 = _g
                _g = (_g + 1)
                return _hx_local_0
            size = python_internal_ArrayImpl._get(sizes, _hx_local_1())
            total = (total + size)
        return _hx_AnonObject({'bytes': total, 'percentage': (((self.get_size() - total)) / self.get_size())})

    def count(self):
        _gthis = self
        worker = tink_RunLoop.current.createSlave()
        done = tink_core_FutureTrigger()
        total = 0
        futures = []
        _g = 0
        _g1 = self.get_pages()
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            def _hx_local_2(i1):
                def _hx_local_0():
                    nonlocal total
                    count = Lambda.count(_gthis.read((i1[0] if 0 < len(i1) else None)).records)
                    total = (total + count)
                    haxe_Log.trace((((((("page-" + Std.string((i1[0] if 0 < len(i1) else None))) + " count: ") + Std.string(count)) + " (total: ") + Std.string(total)) + ")"),_hx_AnonObject({'fileName': "src/hxd/storage/Book.hx", 'lineNumber': 200, 'className': "hxd.storage.Book", 'methodName': "count"}))
                    return
                return _hx_local_0
            tmp = _hx_local_2([i])
            worker.work(tink_runloop__Task_Task_Impl_.ofFunction(tmp))
            x = tink_RunLoop.current.delegate(tink_core__Lazy_LazyConst(tink_core_Noise.Noise),worker)
            futures.append(x)
        def _hx_local_3(_):
            done.trigger(total)
            worker.kill()
            return
        tink_core__Future_Future_Impl_.ofMany(futures).handle(_hx_local_3)
        return done

    def read(self,pageNo):
        if (pageNo in self.retention.h):
            haxe_Log.trace("From retention",_hx_AnonObject({'fileName': "src/hxd/storage/Book.hx", 'lineNumber': 213, 'className': "hxd.storage.Book", 'methodName': "read"}))
            page = self.retention.h.get(pageNo,None)
            ret = [None]*1
            ret[0] = pageNo
            page.number = ret
            return page
        self.get_reader().seek((pageNo * self.pageSize),sys_io_FileSeek.SeekBegin)
        pSize = 0
        try:
            pSize = self.get_reader().readInt16()
        except Exception as _hx_e:
            _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
            e = _hx_e1
            newPage = hxd_storage_Page(self)
            haxe_Log.trace(("Error: " + Std.string(e)),_hx_AnonObject({'fileName': "src/hxd/storage/Book.hx", 'lineNumber': 224, 'className': "hxd.storage.Book", 'methodName': "read"}))
            self.retention.set(pageNo,newPage)
            pSize = -1
        if (pSize == 0):
            haxe_Log.trace("read blank page.",_hx_AnonObject({'fileName': "src/hxd/storage/Book.hx", 'lineNumber': 229, 'className': "hxd.storage.Book", 'methodName': "read"}))
            newPage1 = hxd_storage_Page(self)
            self.retention.set(pageNo,newPage1)
        else:
            pageBytes = self.get_reader().read(pSize)
            try:
                page1 = hxd_storage_Serializer.deserialize(pageBytes,self.preDeserialization)
                page1.book = self
                ret1 = [None]*1
                ret1[0] = pageNo
                page1.number = ret1
                self.retention.set(pageNo,page1)
            except Exception as _hx_e:
                _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                e1 = _hx_e1
                newPage2 = hxd_storage_Page(self)
                haxe_Log.trace(("Error: " + Std.string(e1)),_hx_AnonObject({'fileName': "src/hxd/storage/Book.hx", 'lineNumber': 242, 'className': "hxd.storage.Book", 'methodName': "read"}))
                self.retention.set(pageNo,newPage2)
        return self.retention.h.get(pageNo,None)

    def write(self,page):
        _gthis = self
        def _hx_local_0():
            isNew = (page.number[0] == -1)
            if isNew:
                this1 = page.number
                param = _gthis.get_pages()
                this1[0] = param
                tmp = _gthis.get_file()
                _gthis.get_writer().append = sys_io_File.append(tmp,True)
                _gthis.get_writer().append.write(haxe_io_Bytes.alloc(_gthis.pageSize))
                _gthis.get_writer().append.flush()
                _gthis.get_writer().append.close()
                _this = _gthis._sizes
                x = page.get_size()
                _this.append(x)
            _gthis.get_writer().update.seek((page.number[0] * _gthis.pageSize),sys_io_FileSeek.SeekBegin)
            _gthis.get_writer().update.writeInt16(page.get_size())
            _gthis.get_writer().update.write(page.get_bytes())
            _gthis.get_writer().update.flush()
            _gthis._stat = None
            if (not isNew):
                python_internal_ArrayImpl._set(_gthis._sizes, page.number[0], page.get_size())
            return
        self.workers.write.work(tink_runloop__Task_Task_Impl_.ofFunction(_hx_local_0))
        return tink_RunLoop.current.delegate(tink_core__Lazy_LazyConst(tink_core_Noise.Noise),self.workers.write)

    def close(self):
        haxe_Log.trace("Closing...",_hx_AnonObject({'fileName': "src/hxd/storage/Book.hx", 'lineNumber': 273, 'className': "hxd.storage.Book", 'methodName': "close"}))
        self.get_writer().update.close()

    def refresh(self):
        self._writer = None
        self._reader = None

    def commit(self):
        _gthis = self
        haxe_Log.trace("Begin commit.",_hx_AnonObject({'fileName': "src/hxd/storage/Book.hx", 'lineNumber': 284, 'className': "hxd.storage.Book", 'methodName': "commit"}))
        futures = []
        pageNo = self.retention.keys()
        while pageNo.hasNext():
            pageNo1 = pageNo.next()
            page = self.retention.h.get(pageNo1,None)
            if page.dirty:
                x = self.write(page)
                futures.append(x)
        done = tink_core_FutureTrigger()
        def _hx_local_0(_):
            _gthis.cleanse()
            _gthis.close()
            return done.trigger(tink_core_Noise.Noise)
        tink_core__Future_Future_Impl_.ofMany(futures).handle(_hx_local_0)
        return done

    def create(self,records):
        a = tink_core__Signal_Signal_Impl_.trigger()
        stream = tink_streams_SignalStream(a)
        segments = []
        segment = []
        counter = 0
        overgrowthFactor = Math.ceil((hxd_storage_Serializer.serialize(records).length / self.pageSize))
        segSize = Math.ceil((len(records) / overgrowthFactor))
        _g = 0
        while (_g < len(records)):
            record = (records[_g] if _g >= 0 and _g < len(records) else None)
            _g = (_g + 1)
            segment.append(record)
            counter = (counter + 1)
            if (counter == segSize):
                counter = 0
                segments.append(segment)
                segment = []
            if (record == python_internal_ArrayImpl._get(records, (len(records) - 1))):
                segments.append(segment)
        tink_core__Callback_CallbackList_Impl_.invoke(a.handlers,tink_streams_Yield.Data(hxd_storage_CreateResult.Expect(len(segments))))
        futures = []
        _g1 = 0
        while (_g1 < len(segments)):
            segment1 = (segments[_g1] if _g1 >= 0 and _g1 < len(segments) else None)
            _g1 = (_g1 + 1)
            x = self.safeCreate(segment1,a.trigger,(hxd_storage_CreateHint.FullPage if (((len(segment1) == segSize) and ((len(segments) > 1)))) else hxd_storage_CreateHint.PartialPage))
            futures.append(x)
        def _hx_local_3(_):
            tink_core__Callback_CallbackList_Impl_.invoke(a.handlers,tink_streams_Yield.End)
            return
        tink_core__Future_Future_Impl_.ofMany(futures).handle(_hx_local_3)
        return stream

    def safeCreate(self,records,emit,hint = hxd_storage_CreateHint.PartialPage,last = False):
        if (hint is None):
            hint = hxd_storage_CreateHint.PartialPage
        if (last is None):
            last = False
        _gthis = self
        haxe_Log.trace(("HINT: " + Std.string(hint)),_hx_AnonObject({'fileName': "src/hxd/storage/Book.hx", 'lineNumber': 334, 'className': "hxd.storage.Book", 'methodName': "safeCreate"}))
        estRecordSize = hxd_storage_Serializer.serialize(records,self.postSerialization).length
        def _hx_local_1():
            newPage1 = hxd_storage_Page(_gthis)
            haxe_Log.trace("New page",_hx_AnonObject({'fileName': "src/hxd/storage/Book.hx", 'lineNumber': 338, 'className': "hxd.storage.Book", 'methodName': "safeCreate"}))
            def _hx_local_0():
                if newPage1.create(records):
                    haxe_Log.trace("Working new page",_hx_AnonObject({'fileName': "src/hxd/storage/Book.hx", 'lineNumber': 341, 'className': "hxd.storage.Book", 'methodName': "safeCreate"}))
                    _gthis.retention.set(-Lambda.count(_gthis.retention),newPage1)
                    tink_core__Callback_Callback_Impl_.invoke(emit,tink_streams_Yield.Data(hxd_storage_CreateResult.Created(newPage1,records)))
                    if last:
                        tink_core__Callback_Callback_Impl_.invoke(emit,tink_streams_Yield.End)
                else:
                    raise _HxException(tink_core_TypedError(500,"This should never happen.",_hx_AnonObject({'fileName': "src/hxd/storage/Book.hx", 'lineNumber': 347, 'className': "hxd.storage.Book", 'methodName': "safeCreate"})))
                return
            _gthis.workers.allocate.work(tink_runloop__Task_Task_Impl_.ofFunction(_hx_local_0))
            return tink_RunLoop.current.delegate(tink_core__Lazy_LazyConst(tink_core_Noise.Noise),_gthis.workers.allocate)
        newPage = _hx_local_1
        tmp = hint.index
        if (tmp == 0):
            return newPage()
        elif (tmp == 1):
            haxe_Log.trace(((((((("" + Std.string(self.get_sizes())) + ", ") + Std.string(estRecordSize)) + ", ") + Std.string(self.get_pages())) + ", ") + Std.string(self.get_size())),_hx_AnonObject({'fileName': "src/hxd/storage/Book.hx", 'lineNumber': 356, 'className': "hxd.storage.Book", 'methodName': "safeCreate"}))
            if (Lambda.count(self.retention) != 0):
                key = self.retention.keys()
                while key.hasNext():
                    key1 = key.next()
                    page = self.retention.h.get(key1,None)
                    if ((page.get_size() + estRecordSize) < self.pageSize):
                        if page.create(records):
                            tink_core__Callback_Callback_Impl_.invoke(emit,tink_streams_Yield.Data(hxd_storage_CreateResult.Created(page,records)))
                            return tink_core__Future_SyncFuture(tink_core__Lazy_LazyConst(tink_core_Noise.Noise))
            if (self.get_size() > self.pageSize):
                _g = 0
                _g1 = self.get_pages()
                while (_g < _g1):
                    pageNo = _g
                    _g = (_g + 1)
                    pageNo1 = [pageNo]
                    haxe_Log.trace("check page",_hx_AnonObject({'fileName': "src/hxd/storage/Book.hx", 'lineNumber': 370, 'className': "hxd.storage.Book", 'methodName': "safeCreate"}))
                    if ((python_internal_ArrayImpl._get(self.get_sizes(), (pageNo1[0] if 0 < len(pageNo1) else None)) + estRecordSize) < self.pageSize):
                        def _hx_local_3(pageNo2):
                            def _hx_local_2():
                                haxe_Log.trace("Begin readnig into memory",_hx_AnonObject({'fileName': "src/hxd/storage/Book.hx", 'lineNumber': 373, 'className': "hxd.storage.Book", 'methodName': "safeCreate"}))
                                page1 = _gthis.read((pageNo2[0] if 0 < len(pageNo2) else None))
                                haxe_Log.trace(("Read into memory: " + HxOverrides.stringOrNull(tink_core__Ref_Ref_Impl_.toString(page1.number))),_hx_AnonObject({'fileName': "src/hxd/storage/Book.hx", 'lineNumber': 375, 'className': "hxd.storage.Book", 'methodName': "safeCreate"}))
                                if page1.create(records):
                                    _gthis.retention.set(page1.number[0],page1)
                                    tink_core__Callback_Callback_Impl_.invoke(emit,tink_streams_Yield.Data(hxd_storage_CreateResult.Created(page1,records)))
                                    if last:
                                        tink_core__Callback_Callback_Impl_.invoke(emit,tink_streams_Yield.End)
                                    haxe_Log.trace("Done",_hx_AnonObject({'fileName': "src/hxd/storage/Book.hx", 'lineNumber': 381, 'className': "hxd.storage.Book", 'methodName': "safeCreate"}))
                                else:
                                    raise _HxException(tink_core_TypedError(500,"This should also never happen.",_hx_AnonObject({'fileName': "src/hxd/storage/Book.hx", 'lineNumber': 383, 'className': "hxd.storage.Book", 'methodName': "safeCreate"})))
                                return
                            return _hx_local_2
                        self.workers.cache.work(tink_runloop__Task_Task_Impl_.ofFunction(_hx_local_3(pageNo1)))
                        return tink_RunLoop.current.delegate(tink_core__Lazy_LazyConst(tink_core_Noise.Noise),self.workers.cache)
            return newPage()
        else:
            pass

    @staticmethod
    def open(name):
        book = hxd_storage_Book(name)
        book.ensure()
        return book

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.name = None
        _hx_o.pageSize = None
        _hx_o.retention = None
        _hx_o.workers = None
        _hx_o._writer = None
        _hx_o._reader = None
        _hx_o._stat = None
        _hx_o._sizes = None
        _hx_o.serializationHooks = None
        _hx_o.deserializationHooks = None
hxd_storage_Book._hx_class = hxd_storage_Book
_hx_classes["hxd.storage.Book"] = hxd_storage_Book


class hxd_storage_Page:
    _hx_class_name = "hxd.storage.Page"
    __slots__ = ("book", "number", "dirty", "records", "_bytes", "_size")
    _hx_fields = ["book", "number", "dirty", "records", "_bytes", "_size"]
    _hx_methods = ["get_bytes", "get_size", "touch", "cleanse", "attempt", "create", "retrieve", "update", "delete", "hxSerialize", "hxUnserialize"]

    def __init__(self,b):
        self._size = None
        self._bytes = None
        self.dirty = False
        self.book = b
        ret = [None]*1
        ret[0] = -1
        self.number = ret
        self.records = haxe_ds_BalancedTree()

    def get_bytes(self):
        if (self._bytes is None):
            self._bytes = hxd_storage_Serializer.serialize(self,self.book.postSerialization)
        return self._bytes

    def get_size(self):
        if (self._size is None):
            self._size = self.get_bytes().length
        return self._size

    def touch(self):
        self.dirty = True
        self._size = None

    def cleanse(self):
        self.dirty = False

    def attempt(self,operation):
        _gthis = self
        tmpRecords = Lambda.array(self.records)
        wasDirty = self.dirty
        try:
            operation()
            self.touch()
        except Exception as _hx_e:
            _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
            e = _hx_e1
            raise _HxException(e)
        if (self.get_size() >= self.book.pageSize):
            self.records = haxe_ds_BalancedTree()
            def _hx_local_0(record):
                _gthis.records.set(record.index,record)
                return
            Lambda.iter(tmpRecords,_hx_local_0)
            if (not wasDirty):
                self.cleanse()
            return False
        return True

    def create(self,r):
        _gthis = self
        def _hx_local_2():
            def _hx_local_1():
                _g = 0
                while (_g < len(r)):
                    record = (r[_g] if _g >= 0 and _g < len(r) else None)
                    _g = (_g + 1)
                    lastRecord = _gthis.records.get((Lambda.count(_gthis.records) - 1))
                    nextIndex = ((lastRecord.index + 1) if ((lastRecord is not None)) else 0)
                    record.index = nextIndex
                    _gthis.records.set(nextIndex,record)
                return
            return self.attempt(_hx_local_1)
        return _hx_local_2()

    def retrieve(self,predicate):
        return Lambda.filter(self.records,predicate)

    def update(self,predicate,transformation):
        _gthis = self
        def _hx_local_1():
            def _hx_local_0():
                Lambda.iter(Lambda.filter(_gthis.records,predicate),transformation)
                return
            return self.attempt(_hx_local_0)
        return _hx_local_1()

    def delete(self,predicate):
        _gthis = self
        def _hx_local_3():
            def _hx_local_2():
                def _hx_local_0(d):
                    return (not predicate(d))
                reversePredicate = _hx_local_0
                def _hx_local_1(record):
                    return _gthis.records.remove(record.index)
                Lambda.iter(Lambda.filter(_gthis.records,reversePredicate),_hx_local_1)
                return
            return self.attempt(_hx_local_2)
        return _hx_local_3()

    def hxSerialize(self,s):
        s.serialize(Lambda.array(self.records))

    def hxUnserialize(self,u):
        r = u.unserialize()
        self.records = haxe_ds_BalancedTree()
        _g = 0
        while (_g < len(r)):
            record = (r[_g] if _g >= 0 and _g < len(r) else None)
            _g = (_g + 1)
            self.records.set(record.index,record)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.book = None
        _hx_o.number = None
        _hx_o.dirty = None
        _hx_o.records = None
        _hx_o._bytes = None
        _hx_o._size = None
hxd_storage_Page._hx_class = hxd_storage_Page
_hx_classes["hxd.storage.Page"] = hxd_storage_Page


class hxd_storage_Record:
    _hx_class_name = "hxd.storage.Record"
    __slots__ = ("index", "data")
    _hx_fields = ["index", "data"]
    _hx_methods = ["hxSerialize", "hxUnserialize"]

    def __init__(self,d):
        self.index = -1
        self.data = d

    def hxSerialize(self,s):
        s.serialize(self.index)
        s.serialize(self.data)

    def hxUnserialize(self,u):
        try:
            self.index = u.unserialize()
            self.data = u.unserialize()
        except Exception as _hx_e:
            _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
            e = _hx_e1
            raise _HxException(e)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.index = None
        _hx_o.data = None
hxd_storage_Record._hx_class = hxd_storage_Record
_hx_classes["hxd.storage.Record"] = hxd_storage_Record


class hxd_storage_Serializer:
    _hx_class_name = "hxd.storage.Serializer"
    __slots__ = ()
    _hx_statics = ["serialize", "deserialize"]

    @staticmethod
    def serialize(object,transform = None):
        def _hx_local_2():
            def _hx_local_0(b):
                return b
            return _hx_local_0 if (transform is None) else transform
        transform = _hx_local_2()
        return transform(haxe_io_Bytes.ofString(haxe_Serializer.run(object)))

    @staticmethod
    def deserialize(_hx_bytes,transform = None):
        def _hx_local_2():
            def _hx_local_0(b):
                return b
            return _hx_local_0 if (transform is None) else transform
        transform = _hx_local_2()
        return haxe_Unserializer.run(transform(_hx_bytes).toString())
hxd_storage_Serializer._hx_class = hxd_storage_Serializer
_hx_classes["hxd.storage.Serializer"] = hxd_storage_Serializer


class hxd_sys_Engine:
    _hx_class_name = "hxd.sys.Engine"
    __slots__ = ("cfg",)
    _hx_fields = ["cfg"]
    _hx_methods = ["setConfig"]
    _hx_statics = ["instance", "get_config", "get_path", "start", "ensure"]

    def __init__(self):
        self.cfg = _hx_AnonObject({'path': "", 'book': _hx_AnonObject({'pageSize': 16000, 'maxInsertSize': 250})})

    def setConfig(self,c):
        self.cfg = c
    instance = None
    config = None
    path = None

    @staticmethod
    def get_config():
        return hxd_sys_Engine.instance.cfg

    @staticmethod
    def get_path():
        return Reflect.field(hxd_sys_Engine.instance.cfg,"path")

    @staticmethod
    def start(config = None):
        hxd_sys_Engine.instance = hxd_sys_Engine()
        if (config is None):
            return
        dAccessConfig = hxd_sys_Engine.instance.cfg
        _g = 0
        _g1 = python_Boot.fields(config)
        while (_g < len(_g1)):
            key = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            haxe_Log.trace(key,_hx_AnonObject({'fileName': "src/hxd/sys/Engine.hx", 'lineNumber': 46, 'className': "hxd.sys.Engine", 'methodName': "start"}))
            haxe_Log.trace(dAccessConfig,_hx_AnonObject({'fileName': "src/hxd/sys/Engine.hx", 'lineNumber': 47, 'className': "hxd.sys.Engine", 'methodName': "start"}))
            haxe_Log.trace(config,_hx_AnonObject({'fileName': "src/hxd/sys/Engine.hx", 'lineNumber': 48, 'className': "hxd.sys.Engine", 'methodName': "start"}))
            value = Reflect.field(config,key)
            setattr(dAccessConfig,(("_hx_" + key) if ((key in python_Boot.keywords)) else (("_hx_" + key) if (((((len(key) > 2) and ((ord(key[0]) == 95))) and ((ord(key[1]) == 95))) and ((ord(key[(len(key) - 1)]) != 95)))) else key)),value)
            haxe_Log.trace(dAccessConfig,_hx_AnonObject({'fileName': "src/hxd/sys/Engine.hx", 'lineNumber': 50, 'className': "hxd.sys.Engine", 'methodName': "start"}))

    @staticmethod
    def ensure():
        if (hxd_sys_Engine.instance is None):
            raise _HxException(tink_core_TypedError(500,"Engine must be initialized before beginning operation.",_hx_AnonObject({'fileName': "src/hxd/sys/Engine.hx", 'lineNumber': 56, 'className': "hxd.sys.Engine", 'methodName': "ensure"})))
        if (not sys_FileSystem.exists(("./" + HxOverrides.stringOrNull(hxd_sys_Engine.get_path())))):
            sys_FileSystem.createDirectory(("./" + HxOverrides.stringOrNull(hxd_sys_Engine.get_path())))

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.cfg = None
hxd_sys_Engine._hx_class = hxd_sys_Engine
_hx_classes["hxd.sys.Engine"] = hxd_sys_Engine


class python__KwArgs_KwArgs_Impl_:
    _hx_class_name = "python._KwArgs.KwArgs_Impl_"
    __slots__ = ()
    _hx_statics = ["fromT"]

    @staticmethod
    def fromT(d):
        return python_Lib.anonAsDict(d)
python__KwArgs_KwArgs_Impl_._hx_class = python__KwArgs_KwArgs_Impl_
_hx_classes["python._KwArgs.KwArgs_Impl_"] = python__KwArgs_KwArgs_Impl_


class python_Lib:
    _hx_class_name = "python.Lib"
    __slots__ = ()
    _hx_statics = ["printString", "dictToAnon", "anonToDict", "anonAsDict"]
    __name__ = None

    @staticmethod
    def printString(_hx_str):
        python_lib_Sys.stdout.buffer.write(_hx_str.encode("utf-8", "strict"))
        python_lib_Sys.stdout.flush()

    @staticmethod
    def dictToAnon(v):
        return _hx_AnonObject(v.copy())

    @staticmethod
    def anonToDict(o):
        if isinstance(o,_hx_AnonObject):
            return o.__dict__.copy()
        else:
            return None

    @staticmethod
    def anonAsDict(o):
        if isinstance(o,_hx_AnonObject):
            return o.__dict__
        else:
            return None
python_Lib._hx_class = python_Lib
_hx_classes["python.Lib"] = python_Lib


class python_internal_ArrayImpl:
    _hx_class_name = "python.internal.ArrayImpl"
    __slots__ = ()
    _hx_statics = ["concat", "copy", "iterator", "indexOf", "lastIndexOf", "join", "toString", "pop", "push", "unshift", "remove", "shift", "slice", "sort", "splice", "map", "filter", "insert", "reverse", "_get", "_set"]

    @staticmethod
    def concat(a1,a2):
        return (a1 + a2)

    @staticmethod
    def copy(x):
        return list(x)

    @staticmethod
    def iterator(x):
        return python_HaxeIterator(x.__iter__())

    @staticmethod
    def indexOf(a,x,fromIndex = None):
        _hx_len = len(a)
        l = (0 if ((fromIndex is None)) else ((_hx_len + fromIndex) if ((fromIndex < 0)) else fromIndex))
        if (l < 0):
            l = 0
        _g = l
        while (_g < _hx_len):
            i = _g
            _g = (_g + 1)
            if HxOverrides.eq(a[i],x):
                return i
        return -1

    @staticmethod
    def lastIndexOf(a,x,fromIndex = None):
        _hx_len = len(a)
        l = (_hx_len if ((fromIndex is None)) else (((_hx_len + fromIndex) + 1) if ((fromIndex < 0)) else (fromIndex + 1)))
        if (l > _hx_len):
            l = _hx_len
        while True:
            l = (l - 1)
            tmp = l
            if (not ((tmp > -1))):
                break
            if HxOverrides.eq(a[l],x):
                return l
        return -1

    @staticmethod
    def join(x,sep):
        return sep.join([python_Boot.toString1(x1,'') for x1 in x])

    @staticmethod
    def toString(x):
        return (("[" + HxOverrides.stringOrNull(",".join([python_Boot.toString1(x1,'') for x1 in x]))) + "]")

    @staticmethod
    def pop(x):
        if (len(x) == 0):
            return None
        else:
            return x.pop()

    @staticmethod
    def push(x,e):
        x.append(e)
        return len(x)

    @staticmethod
    def unshift(x,e):
        x.insert(0, e)

    @staticmethod
    def remove(x,e):
        try:
            x.remove(e)
            return True
        except Exception as _hx_e:
            _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
            e1 = _hx_e1
            return False

    @staticmethod
    def shift(x):
        if (len(x) == 0):
            return None
        return x.pop(0)

    @staticmethod
    def slice(x,pos,end = None):
        return x[pos:end]

    @staticmethod
    def sort(x,f):
        x.sort(key= python_lib_Functools.cmp_to_key(f))

    @staticmethod
    def splice(x,pos,_hx_len):
        if (pos < 0):
            pos = (len(x) + pos)
        if (pos < 0):
            pos = 0
        res = x[pos:(pos + _hx_len)]
        del x[pos:(pos + _hx_len)]
        return res

    @staticmethod
    def map(x,f):
        return list(map(f,x))

    @staticmethod
    def filter(x,f):
        return list(filter(f,x))

    @staticmethod
    def insert(a,pos,x):
        a.insert(pos, x)

    @staticmethod
    def reverse(a):
        a.reverse()

    @staticmethod
    def _get(x,idx):
        if ((idx > -1) and ((idx < len(x)))):
            return x[idx]
        else:
            return None

    @staticmethod
    def _set(x,idx,v):
        l = len(x)
        while (l < idx):
            x.append(None)
            l = (l + 1)
        if (l == idx):
            x.append(v)
        else:
            x[idx] = v
        return v
python_internal_ArrayImpl._hx_class = python_internal_ArrayImpl
_hx_classes["python.internal.ArrayImpl"] = python_internal_ArrayImpl


class _HxException(Exception):
    _hx_class_name = "_HxException"
    __slots__ = ("val",)
    _hx_fields = ["val"]
    _hx_methods = []
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = Exception


    def __init__(self,val):
        self.val = None
        super().__init__(str(val))
        self.val = val

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.val = None
_HxException._hx_class = _HxException
_hx_classes["_HxException"] = _HxException


class HxOverrides:
    _hx_class_name = "HxOverrides"
    __slots__ = ()
    _hx_statics = ["iterator", "eq", "stringOrNull", "map", "modf", "mod", "mapKwArgs"]

    @staticmethod
    def iterator(x):
        if isinstance(x,list):
            return python_HaxeIterator(x.__iter__())
        return x.iterator()

    @staticmethod
    def eq(a,b):
        if (isinstance(a,list) or isinstance(b,list)):
            return a is b
        return (a == b)

    @staticmethod
    def stringOrNull(s):
        if (s is None):
            return "null"
        else:
            return s

    @staticmethod
    def map(x,f):
        if isinstance(x,list):
            return list(map(f,x))
        return x.map(f)

    @staticmethod
    def modf(a,b):
        return float('nan') if (b == 0.0) else a % b if a >= 0 else -(-a % b)

    @staticmethod
    def mod(a,b):
        return a % b if a >= 0 else -(-a % b)

    @staticmethod
    def mapKwArgs(a,v):
        a1 = _hx_AnonObject(python_Lib.anonToDict(a))
        k = python_HaxeIterator(iter(v.keys()))
        while k.hasNext():
            k1 = k.next()
            val = v.get(k1)
            if hasattr(a1,k1):
                setattr(a1,val,getattr(a1,k1))
                delattr(a1,k1)
        return a1
HxOverrides._hx_class = HxOverrides
_hx_classes["HxOverrides"] = HxOverrides


class python_internal_MethodClosure:
    _hx_class_name = "python.internal.MethodClosure"
    __slots__ = ("obj", "func")
    _hx_fields = ["obj", "func"]
    _hx_methods = ["__call__"]

    def __init__(self,obj,func):
        self.obj = obj
        self.func = func

    def __call__(self,*args):
        return self.func(self.obj,*args)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.obj = None
        _hx_o.func = None
python_internal_MethodClosure._hx_class = python_internal_MethodClosure
_hx_classes["python.internal.MethodClosure"] = python_internal_MethodClosure


class python_io_NativeBytesInput(python_io_NativeInput):
    _hx_class_name = "python.io.NativeBytesInput"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = ["readByte", "seek", "readinto"]
    _hx_statics = []
    _hx_interfaces = [python_io_IInput]
    _hx_super = python_io_NativeInput


    def __init__(self,stream):
        super().__init__(stream)

    def readByte(self):
        ret = self.stream.read(1)
        if (len(ret) == 0):
            self.throwEof()
        return ret[0]

    def seek(self,p,pos):
        self.wasEof = False
        python_io_IoTools.seekInBinaryMode(self.stream,p,pos)
        return

    def readinto(self,b):
        return self.stream.readinto(b)

    @staticmethod
    def _hx_empty_init(_hx_o):        pass
python_io_NativeBytesInput._hx_class = python_io_NativeBytesInput
_hx_classes["python.io.NativeBytesInput"] = python_io_NativeBytesInput


class python_io_FileBytesInput(python_io_NativeBytesInput):
    _hx_class_name = "python.io.FileBytesInput"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = []
    _hx_statics = []
    _hx_interfaces = [python_io_IFileInput]
    _hx_super = python_io_NativeBytesInput


    def __init__(self,stream):
        super().__init__(stream)
python_io_FileBytesInput._hx_class = python_io_FileBytesInput
_hx_classes["python.io.FileBytesInput"] = python_io_FileBytesInput


class python_io_NativeBytesOutput(python_io_NativeOutput):
    _hx_class_name = "python.io.NativeBytesOutput"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = ["seek", "prepare", "writeByte"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = python_io_NativeOutput


    def __init__(self,stream):
        super().__init__(stream)

    def seek(self,p,pos):
        python_io_IoTools.seekInBinaryMode(self.stream,p,pos)
        return

    def prepare(self,nbytes):
        self.stream.truncate(nbytes)

    def writeByte(self,c):
        self.stream.write(bytearray([c]))

    @staticmethod
    def _hx_empty_init(_hx_o):        pass
python_io_NativeBytesOutput._hx_class = python_io_NativeBytesOutput
_hx_classes["python.io.NativeBytesOutput"] = python_io_NativeBytesOutput


class python_io_FileBytesOutput(python_io_NativeBytesOutput):
    _hx_class_name = "python.io.FileBytesOutput"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = []
    _hx_statics = []
    _hx_interfaces = [python_io_IFileOutput]
    _hx_super = python_io_NativeBytesOutput


    def __init__(self,stream):
        super().__init__(stream)
python_io_FileBytesOutput._hx_class = python_io_FileBytesOutput
_hx_classes["python.io.FileBytesOutput"] = python_io_FileBytesOutput


class sys_net_Socket:
    _hx_class_name = "sys.net.Socket"
    __slots__ = ("_hx___s", "input", "output")
    _hx_fields = ["__s", "input", "output"]
    _hx_methods = ["__initSocket", "close", "write", "connect", "shutdown", "setTimeout", "fileno"]

    def __init__(self):
        self.output = None
        self.input = None
        self._hx___s = None
        self._hx___initSocket()
        self.input = sys_net__Socket_SocketInput(self._hx___s)
        self.output = sys_net__Socket_SocketOutput(self._hx___s)

    def _hx___initSocket(self):
        self._hx___s = python_lib_socket_Socket()

    def close(self):
        self._hx___s.close()

    def write(self,content):
        self.output.writeString(content)

    def connect(self,host,port):
        self._hx___s.connect((host.toString(), port))

    def shutdown(self,read,write):
        self._hx___s.shutdown((python_lib_Socket.SHUT_RDWR if ((read and write)) else (python_lib_Socket.SHUT_RD if read else python_lib_Socket.SHUT_WR)))

    def setTimeout(self,timeout):
        self._hx___s.settimeout(timeout)

    def fileno(self):
        return self._hx___s.fileno()

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o._hx___s = None
        _hx_o.input = None
        _hx_o.output = None
sys_net_Socket._hx_class = sys_net_Socket
_hx_classes["sys.net.Socket"] = sys_net_Socket


class python_net_SslSocket(sys_net_Socket):
    _hx_class_name = "python.net.SslSocket"
    __slots__ = ("hostName",)
    _hx_fields = ["hostName"]
    _hx_methods = ["__initSocket", "connect"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = sys_net_Socket


    def __init__(self):
        self.hostName = None
        super().__init__()

    def _hx___initSocket(self):
        context = python_lib_ssl_SSLContext(python_lib_Ssl.PROTOCOL_SSLv23)
        context.verify_mode = python_lib_Ssl.CERT_REQUIRED
        context.set_default_verify_paths()
        def _hx_local_1():
            context.options = (context.options | python_lib_Ssl.OP_NO_SSLv2)
            return context.options
        context.options = ((_hx_local_1()) | python_lib_Ssl.OP_NO_SSLv3)
        def _hx_local_3():
            context.options = (context.options | python_lib_Ssl.OP_NO_COMPRESSION)
            return context.options
        context.options = ((_hx_local_3()) | python_lib_Ssl.OP_NO_TLSv1)
        self._hx___s = python_lib_socket_Socket()
        self._hx___s = context.wrap_socket(self._hx___s,False,True,True,self.hostName)

    def connect(self,host,port):
        self.hostName = host.host
        super().connect(host,port)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.hostName = None
python_net_SslSocket._hx_class = python_net_SslSocket
_hx_classes["python.net.SslSocket"] = python_net_SslSocket


class sys_Http(haxe_http_HttpBase):
    _hx_class_name = "sys.Http"
    __slots__ = ("noShutdown", "cnxTimeout", "responseHeaders", "chunk_size", "chunk_buf", "file")
    _hx_fields = ["noShutdown", "cnxTimeout", "responseHeaders", "chunk_size", "chunk_buf", "file"]
    _hx_methods = ["request", "customRequest", "readHttpResponse", "readChunk"]
    _hx_statics = ["PROXY"]
    _hx_interfaces = []
    _hx_super = haxe_http_HttpBase


    def __init__(self,url):
        self.file = None
        self.chunk_buf = None
        self.chunk_size = None
        self.responseHeaders = None
        self.noShutdown = None
        self.cnxTimeout = 10
        super().__init__(url)

    def request(self,post = None):
        _gthis = self
        output = haxe_io_BytesOutput()
        old = self.onError
        err = False
        def _hx_local_0(e):
            nonlocal err
            _gthis.responseData = output.getBytes().toString()
            err = True
            _gthis.onError = old
            _gthis.onError(e)
        self.onError = _hx_local_0
        self.customRequest(post,output)
        if (not err):
            def _hx_local_1():
                self.responseData = output.getBytes().toString()
                return self.responseData
            self.onData(_hx_local_1())

    def customRequest(self,post,api,sock = None,method = None):
        self.responseData = None
        url_regexp = EReg("^(https?://)?([a-zA-Z\\.0-9_-]+)(:[0-9]+)?(.*)$","")
        url_regexp.matchObj = python_lib_Re.search(url_regexp.pattern,self.url)
        if (url_regexp.matchObj is None):
            self.onError("Invalid URL")
            return
        secure = (url_regexp.matchObj.group(1) == "https://")
        if (sock is None):
            if secure:
                sock = python_net_SslSocket()
            else:
                sock = sys_net_Socket()
        host = url_regexp.matchObj.group(2)
        portString = url_regexp.matchObj.group(3)
        request = url_regexp.matchObj.group(4)
        if ((("" if ((0 >= len(request))) else request[0])) != "/"):
            request = ("/" + ("null" if request is None else request))
        port = ((443 if secure else 80) if (((portString is None) or ((portString == "")))) else Std.parseInt(HxString.substr(portString,1,(len(portString) - 1))))
        multipart = (self.file is not None)
        boundary = None
        uri = None
        if multipart:
            post = True
            boundary = (((Std.string(int((python_lib_Random.random() * 1000))) + Std.string(int((python_lib_Random.random() * 1000)))) + Std.string(int((python_lib_Random.random() * 1000)))) + Std.string(int((python_lib_Random.random() * 1000))))
            while (len(boundary) < 38):
                boundary = ("-" + ("null" if boundary is None else boundary))
            b_b = python_lib_io_StringIO()
            _g = 0
            _g1 = self.params
            while (_g < len(_g1)):
                p = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                _g = (_g + 1)
                b_b.write("--")
                b_b.write(Std.string(boundary))
                b_b.write("\r\n")
                b_b.write("Content-Disposition: form-data; name=\"")
                b_b.write(Std.string(p.name))
                b_b.write("\"")
                b_b.write("\r\n")
                b_b.write("\r\n")
                b_b.write(Std.string(p.value))
                b_b.write("\r\n")
            b_b.write("--")
            b_b.write(Std.string(boundary))
            b_b.write("\r\n")
            b_b.write("Content-Disposition: form-data; name=\"")
            b_b.write(Std.string(self.file.param))
            b_b.write("\"; filename=\"")
            b_b.write(Std.string(self.file.filename))
            b_b.write("\"")
            b_b.write("\r\n")
            b_b.write(Std.string(((("Content-Type: " + HxOverrides.stringOrNull(self.file.mimeType)) + "\r\n") + "\r\n")))
            uri = b_b.getvalue()
        else:
            _g2 = 0
            _g11 = self.params
            while (_g2 < len(_g11)):
                p1 = (_g11[_g2] if _g2 >= 0 and _g2 < len(_g11) else None)
                _g2 = (_g2 + 1)
                if (uri is None):
                    uri = ""
                else:
                    uri = (("null" if uri is None else uri) + "&")
                uri = (("null" if uri is None else uri) + HxOverrides.stringOrNull((((HxOverrides.stringOrNull(python_lib_urllib_Parse.quote(p1.name,"")) + "=") + HxOverrides.stringOrNull(python_lib_urllib_Parse.quote(p1.value,""))))))
        b_b1 = python_lib_io_StringIO()
        if (method is not None):
            b_b1.write(Std.string(method))
            b_b1.write(" ")
        elif post:
            b_b1.write("POST ")
        else:
            b_b1.write("GET ")
        if (sys_Http.PROXY is not None):
            b_b1.write("http://")
            b_b1.write(Std.string(host))
            if (port != 80):
                b_b1.write(":")
                b_b1.write(Std.string(port))
        b_b1.write(Std.string(request))
        if ((not post) and ((uri is not None))):
            if (request.find("?", 0) >= 0):
                b_b1.write("&")
            else:
                b_b1.write("?")
            b_b1.write(Std.string(uri))
        b_b1.write(Std.string(((" HTTP/1.1\r\nHost: " + ("null" if host is None else host)) + "\r\n")))
        if (self.postData is not None):
            b_b1.write(Std.string((("Content-Length: " + Std.string(len(self.postData))) + "\r\n")))
        elif (post and ((uri is not None))):
            def _hx_local_4(h):
                return (h.name == "Content-Type")
            if (multipart or (not Lambda.exists(self.headers,_hx_local_4))):
                b_b1.write("Content-Type: ")
                if multipart:
                    b_b1.write("multipart/form-data")
                    b_b1.write("; boundary=")
                    b_b1.write(Std.string(boundary))
                else:
                    b_b1.write("application/x-www-form-urlencoded")
                b_b1.write("\r\n")
            if multipart:
                b_b1.write(Std.string((("Content-Length: " + Std.string(((((len(uri) + self.file.size) + len(boundary)) + 6)))) + "\r\n")))
            else:
                b_b1.write(Std.string((("Content-Length: " + Std.string(len(uri))) + "\r\n")))
        b_b1.write("Connection: close\r\n")
        _g3 = 0
        _g12 = self.headers
        while (_g3 < len(_g12)):
            h1 = (_g12[_g3] if _g3 >= 0 and _g3 < len(_g12) else None)
            _g3 = (_g3 + 1)
            b_b1.write(Std.string(h1.name))
            b_b1.write(": ")
            b_b1.write(Std.string(h1.value))
            b_b1.write("\r\n")
        b_b1.write("\r\n")
        if (self.postData is not None):
            b_b1.write(Std.string(self.postData))
        elif (post and ((uri is not None))):
            b_b1.write(Std.string(uri))
        try:
            if (sys_Http.PROXY is not None):
                sock.connect(sys_net_Host(sys_Http.PROXY.host),sys_Http.PROXY.port)
            else:
                sock.connect(sys_net_Host(host),port)
            sock.write(b_b1.getvalue())
            if multipart:
                buf = haxe_io_Bytes.alloc(4096)
                while (self.file.size > 0):
                    size = (4096 if ((self.file.size > 4096)) else self.file.size)
                    _hx_len = 0
                    try:
                        _hx_len = self.file.io.readBytes(buf,0,size)
                    except Exception as _hx_e:
                        _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                        if isinstance(_hx_e1, haxe_io_Eof):
                            e = _hx_e1
                            break
                        else:
                            raise _hx_e
                    sock.output.writeFullBytes(buf,0,_hx_len)
                    _hx_local_6 = self.file
                    _hx_local_7 = _hx_local_6.size
                    _hx_local_6.size = (_hx_local_7 - _hx_len)
                    _hx_local_6.size
                sock.write("\r\n")
                sock.write("--")
                sock.write(boundary)
                sock.write("--")
            self.readHttpResponse(api,sock)
            sock.close()
        except Exception as _hx_e:
            _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
            e1 = _hx_e1
            try:
                sock.close()
            except Exception as _hx_e:
                _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                pass
            self.onError(Std.string(e1))

    def readHttpResponse(self,api,sock):
        b = haxe_io_BytesBuffer()
        k = 4
        s = haxe_io_Bytes.alloc(4)
        sock.setTimeout(self.cnxTimeout)
        while True:
            p = sock.input.readBytes(s,0,k)
            while (p != k):
                p = (p + sock.input.readBytes(s,p,(k - p)))
            if ((k < 0) or ((k > s.length))):
                raise _HxException(haxe_io_Error.OutsideBounds)
            b2 = s.b
            _g = 0
            _g1 = k
            while (_g < _g1):
                i = _g
                _g = (_g + 1)
                b.b.append(b2[i])
            k1 = k
            if (k1 == 1):
                c = s.b[0]
                if (c == 10):
                    break
                if (c == 13):
                    k = 3
                else:
                    k = 4
            elif (k1 == 2):
                c1 = s.b[1]
                if (c1 == 10):
                    if (s.b[0] == 13):
                        break
                    k = 4
                elif (c1 == 13):
                    k = 3
                else:
                    k = 4
            elif (k1 == 3):
                c2 = s.b[2]
                if (c2 == 10):
                    if (s.b[1] != 13):
                        k = 4
                    elif (s.b[0] != 10):
                        k = 2
                    else:
                        break
                elif (c2 == 13):
                    if ((s.b[1] != 10) or ((s.b[0] != 13))):
                        k = 1
                    else:
                        k = 3
                else:
                    k = 4
            elif (k1 == 4):
                c3 = s.b[3]
                if (c3 == 10):
                    if (s.b[2] != 13):
                        continue
                    elif ((s.b[1] != 10) or ((s.b[0] != 13))):
                        k = 2
                    else:
                        break
                elif (c3 == 13):
                    if ((s.b[2] != 10) or ((s.b[1] != 13))):
                        k = 3
                    else:
                        k = 1
            else:
                pass
        headers = b.getBytes().toString().split("\r\n")
        status = Std.parseInt(python_internal_ArrayImpl._get((None if ((len(headers) == 0)) else headers.pop(0)).split(" "), 1))
        if ((status == 0) or ((status is None))):
            raise _HxException("Response status error")
        if (len(headers) != 0):
            headers.pop()
        if (len(headers) != 0):
            headers.pop()
        self.responseHeaders = haxe_ds_StringMap()
        size = None
        chunked = False
        _g2 = 0
        while (_g2 < len(headers)):
            def _hx_local_2():
                nonlocal _g2
                _hx_local_1 = _g2
                _g2 = (_g2 + 1)
                return _hx_local_1
            hline = python_internal_ArrayImpl._get(headers, _hx_local_2())
            a = hline.split(": ")
            hname = (None if ((len(a) == 0)) else a.pop(0))
            hval = ((a[0] if 0 < len(a) else None) if ((len(a) == 1)) else ": ".join([python_Boot.toString1(x1,'') for x1 in a]))
            hval = StringTools.ltrim(StringTools.rtrim(hval))
            self.responseHeaders.h[hname] = hval
            _g3 = hname.lower()
            _hx_local_3 = len(_g3)
            if (_hx_local_3 == 17):
                if (_g3 == "transfer-encoding"):
                    chunked = (hval.lower() == "chunked")
            elif (_hx_local_3 == 14):
                if (_g3 == "content-length"):
                    size = Std.parseInt(hval)
            else:
                pass
        self.onStatus(status)
        chunk_re = EReg("^([0-9A-Fa-f]+)[ ]*\r\n","m")
        self.chunk_size = None
        self.chunk_buf = None
        buf = haxe_io_Bytes.alloc(1024)
        if chunked:
            try:
                while self.readChunk(chunk_re,api,buf,sock.input.readBytes(buf,0,1024)):
                    pass
            except Exception as _hx_e:
                _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                if isinstance(_hx_e1, haxe_io_Eof):
                    e = _hx_e1
                    raise _HxException("Transfer aborted")
                else:
                    raise _hx_e
        elif (size is None):
            if (not self.noShutdown):
                sock.shutdown(False,True)
            try:
                while True:
                    _hx_len = sock.input.readBytes(buf,0,1024)
                    if (_hx_len == 0):
                        break
                    api.writeBytes(buf,0,_hx_len)
            except Exception as _hx_e:
                _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                if isinstance(_hx_e1, haxe_io_Eof):
                        pass
                else:
                    raise _hx_e
        else:
            api.prepare(size)
            try:
                while (size > 0):
                    len1 = sock.input.readBytes(buf,0,(1024 if ((size > 1024)) else size))
                    api.writeBytes(buf,0,len1)
                    size = (size - len1)
            except Exception as _hx_e:
                _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                if isinstance(_hx_e1, haxe_io_Eof):
                    e2 = _hx_e1
                    raise _HxException("Transfer aborted")
                else:
                    raise _hx_e
        if (chunked and (((self.chunk_size is not None) or ((self.chunk_buf is not None))))):
            raise _HxException("Invalid chunk")
        if ((status < 200) or ((status >= 400))):
            raise _HxException(("Http Error #" + Std.string(status)))
        api.close()

    def readChunk(self,chunk_re,api,buf,_hx_len):
        if (self.chunk_size is None):
            if (self.chunk_buf is not None):
                b = haxe_io_BytesBuffer()
                src = self.chunk_buf
                b2 = src.b
                _g = 0
                _g1 = src.length
                while (_g < _g1):
                    i = _g
                    _g = (_g + 1)
                    b.b.append(b2[i])
                if ((_hx_len < 0) or ((_hx_len > buf.length))):
                    raise _HxException(haxe_io_Error.OutsideBounds)
                b21 = buf.b
                _g2 = 0
                _g11 = _hx_len
                while (_g2 < _g11):
                    i1 = _g2
                    _g2 = (_g2 + 1)
                    b.b.append(b21[i1])
                buf = b.getBytes()
                _hx_len = (_hx_len + self.chunk_buf.length)
                self.chunk_buf = None
            s = buf.toString()
            chunk_re.matchObj = python_lib_Re.search(chunk_re.pattern,s)
            if (chunk_re.matchObj is not None):
                chunk_re.matchObj.start()
                p_len = (chunk_re.matchObj.end() - chunk_re.matchObj.start())
                if (p_len <= _hx_len):
                    self.chunk_size = Std.parseInt(("0x" + HxOverrides.stringOrNull(chunk_re.matchObj.group(1))))
                    if (self.chunk_size == 0):
                        self.chunk_size = None
                        self.chunk_buf = None
                        return False
                    _hx_len = (_hx_len - p_len)
                    return self.readChunk(chunk_re,api,buf.sub(p_len,_hx_len),_hx_len)
            if (_hx_len > 10):
                self.onError("Invalid chunk")
                return False
            self.chunk_buf = buf.sub(0,_hx_len)
            return True
        if (self.chunk_size > _hx_len):
            _hx_local_2 = self
            _hx_local_3 = _hx_local_2.chunk_size
            _hx_local_2.chunk_size = (_hx_local_3 - _hx_len)
            _hx_local_2.chunk_size
            api.writeBytes(buf,0,_hx_len)
            return True
        end = (self.chunk_size + 2)
        if (_hx_len >= end):
            if (self.chunk_size > 0):
                api.writeBytes(buf,0,self.chunk_size)
            _hx_len = (_hx_len - end)
            self.chunk_size = None
            if (_hx_len == 0):
                return True
            return self.readChunk(chunk_re,api,buf.sub(end,_hx_len),_hx_len)
        if (self.chunk_size > 0):
            api.writeBytes(buf,0,self.chunk_size)
        _hx_local_5 = self
        _hx_local_6 = _hx_local_5.chunk_size
        _hx_local_5.chunk_size = (_hx_local_6 - _hx_len)
        _hx_local_5.chunk_size
        return True

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.noShutdown = None
        _hx_o.cnxTimeout = None
        _hx_o.responseHeaders = None
        _hx_o.chunk_size = None
        _hx_o.chunk_buf = None
        _hx_o.file = None
sys_Http._hx_class = sys_Http
_hx_classes["sys.Http"] = sys_Http


class sys_io_File:
    _hx_class_name = "sys.io.File"
    __slots__ = ()
    _hx_statics = ["read", "write", "append", "update"]

    @staticmethod
    def read(path,binary = True):
        if (binary is None):
            binary = True
        f = python_lib_Builtins.open(path,("rb" if binary else "r"),-1,None,None,(None if binary else ""))
        if binary:
            return python_io_IoTools.createFileInputFromBytes(f)
        else:
            return python_io_IoTools.createFileInputFromText(f)

    @staticmethod
    def write(path,binary = True):
        if (binary is None):
            binary = True
        f = python_lib_Builtins.open(path,("wb" if binary else "w"),-1,None,None,(None if binary else ""))
        if binary:
            return python_io_IoTools.createFileOutputFromBytes(f)
        else:
            return python_io_IoTools.createFileOutputFromText(f)

    @staticmethod
    def append(path,binary = True):
        if (binary is None):
            binary = True
        f = python_lib_Builtins.open(path,("ab" if binary else "a"),-1,None,None,(None if binary else ""))
        if binary:
            return python_io_IoTools.createFileOutputFromBytes(f)
        else:
            return python_io_IoTools.createFileOutputFromText(f)

    @staticmethod
    def update(path,binary = True):
        if (binary is None):
            binary = True
        if (not sys_FileSystem.exists(path)):
            sys_io_File.write(path).close()
        f = python_lib_Builtins.open(path,("rb+" if binary else "r+"),-1,None,None,(None if binary else ""))
        if binary:
            return python_io_IoTools.createFileOutputFromBytes(f)
        else:
            return python_io_IoTools.createFileOutputFromText(f)
sys_io_File._hx_class = sys_io_File
_hx_classes["sys.io.File"] = sys_io_File

class sys_io_FileSeek(Enum):
    __slots__ = ()
    _hx_class_name = "sys.io.FileSeek"
    _hx_constructs = ["SeekBegin", "SeekCur", "SeekEnd"]
sys_io_FileSeek.SeekBegin = sys_io_FileSeek("SeekBegin", 0, list())
sys_io_FileSeek.SeekCur = sys_io_FileSeek("SeekCur", 1, list())
sys_io_FileSeek.SeekEnd = sys_io_FileSeek("SeekEnd", 2, list())
sys_io_FileSeek._hx_class = sys_io_FileSeek
_hx_classes["sys.io.FileSeek"] = sys_io_FileSeek


class sys_net_Host:
    _hx_class_name = "sys.net.Host"
    __slots__ = ("host", "name")
    _hx_fields = ["host", "name"]
    _hx_methods = ["toString"]

    def __init__(self,name):
        self.host = name
        self.name = name

    def toString(self):
        return self.name

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.host = None
        _hx_o.name = None
sys_net_Host._hx_class = sys_net_Host
_hx_classes["sys.net.Host"] = sys_net_Host


class sys_net__Socket_SocketInput(haxe_io_Input):
    _hx_class_name = "sys.net._Socket.SocketInput"
    __slots__ = ("_hx___s",)
    _hx_fields = ["__s"]
    _hx_methods = ["readByte", "readBytes"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = haxe_io_Input


    def __init__(self,s):
        self._hx___s = s

    def readByte(self):
        r = None
        try:
            r = self._hx___s.recv(1,0)
        except Exception as _hx_e:
            _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
            if isinstance(_hx_e1, BlockingIOError):
                e = _hx_e1
                raise _HxException(haxe_io_Error.Blocked)
            else:
                raise _hx_e
        if (len(r) == 0):
            raise _HxException(haxe_io_Eof())
        return r[0]

    def readBytes(self,buf,pos,_hx_len):
        r = None
        data = buf.b
        try:
            r = self._hx___s.recv(_hx_len,0)
            _g = pos
            _g1 = (pos + len(r))
            while (_g < _g1):
                i = _g
                _g = (_g + 1)
                data.__setitem__(i,r[(i - pos)])
        except Exception as _hx_e:
            _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
            if isinstance(_hx_e1, BlockingIOError):
                e = _hx_e1
                raise _HxException(haxe_io_Error.Blocked)
            else:
                raise _hx_e
        if (len(r) == 0):
            raise _HxException(haxe_io_Eof())
        return len(r)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o._hx___s = None
sys_net__Socket_SocketInput._hx_class = sys_net__Socket_SocketInput
_hx_classes["sys.net._Socket.SocketInput"] = sys_net__Socket_SocketInput


class sys_net__Socket_SocketOutput(haxe_io_Output):
    _hx_class_name = "sys.net._Socket.SocketOutput"
    __slots__ = ("_hx___s",)
    _hx_fields = ["__s"]
    _hx_methods = ["writeByte", "writeBytes", "close"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = haxe_io_Output


    def __init__(self,s):
        self._hx___s = s

    def writeByte(self,c):
        try:
            self._hx___s.send(bytes([c]),0)
        except Exception as _hx_e:
            _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
            if isinstance(_hx_e1, BlockingIOError):
                e = _hx_e1
                raise _HxException(haxe_io_Error.Blocked)
            else:
                raise _hx_e

    def writeBytes(self,buf,pos,_hx_len):
        try:
            payload = data[pos:pos+_hx_len]
            return self._hx___s.send(payload,0)
        except Exception as _hx_e:
            _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
            if isinstance(_hx_e1, BlockingIOError):
                e = _hx_e1
                raise _HxException(haxe_io_Error.Blocked)
            else:
                raise _hx_e

    def close(self):
        super().close()
        if (self._hx___s is not None):
            self._hx___s.close()

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o._hx___s = None
sys_net__Socket_SocketOutput._hx_class = sys_net__Socket_SocketOutput
_hx_classes["sys.net._Socket.SocketOutput"] = sys_net__Socket_SocketOutput


class tink_runloop_Worker:
    _hx_class_name = "tink.runloop.Worker"
    __slots__ = ()
    _hx_methods = ["get_owner", "get_id", "work", "asap", "atNextStep", "step", "kill"]
tink_runloop_Worker._hx_class = tink_runloop_Worker
_hx_classes["tink.runloop.Worker"] = tink_runloop_Worker


class tink_runloop_QueueWorker:
    _hx_class_name = "tink.runloop.QueueWorker"
    __slots__ = ("id", "owner", "tasks", "thread")
    _hx_fields = ["tasks", "thread"]
    _hx_methods = ["get_id", "get_owner", "log", "work", "atNextStep", "asap", "kill", "error", "execute", "toString", "step", "doStep"]
    _hx_interfaces = [tink_runloop_Worker]

    def __init__(self,owner,id):
        self.id = id
        self.tasks = haxe_ds_List()
        self.owner = owner
        self.thread = "Fake Main Thread"

    def get_id(self):
        return self.id

    def get_owner(self):
        return self.owner

    def log(self,v,p = None):
        self.owner.log(v,p)

    def work(self,task):
        if (task.get_state() == tink_runloop_TaskState.Pending):
            self.tasks.add(task)
        return task

    def atNextStep(self,task):
        if (task.get_state() == tink_runloop_TaskState.Pending):
            self.tasks.push(task)
        return task

    def asap(self,task):
        if (self.thread == "Fake Main Thread"):
            task.perform()
        else:
            self.atNextStep(task)
        return task

    def kill(self):
        self.tasks = None

    def error(self,e,t):
        _gthis = self
        def _hx_local_0():
            _gthis1 = _gthis.owner.onError
            tmp = haxe_CallStack.exceptionStack()
            _gthis1(e,t,_gthis,tmp)
        self.owner.asap(tink_runloop__Task_Task_Impl_.ofFunction(_hx_local_0))

    def execute(self,t):
        if (t is None):
            return tink_runloop_WorkResult.Idle
        else:
            try:
                t.perform()
                if t.get_recurring():
                    self.work(t)
            except Exception as _hx_e:
                _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                if isinstance(_hx_e1, tink_core_TypedError):
                    e = _hx_e1
                    self.error(e,t)
                else:
                    e1 = _hx_e1
                    self.error(tink_core_TypedError.withData(None,("Uncaught exception: " + Std.string(e1)),e1,_hx_AnonObject({'fileName': "tink/runloop/QueueWorker.hx", 'lineNumber': 70, 'className': "tink.runloop.QueueWorker", 'methodName': "execute"})),t)
            return tink_runloop_WorkResult.Progressed

    def toString(self):
        return ("Worker:" + HxOverrides.stringOrNull(self.id))

    def step(self):
        if (self.thread == "Fake Main Thread"):
            return self.doStep()
        else:
            return tink_runloop_WorkResult.WrongThread

    def doStep(self):
        if (self.tasks is None):
            return tink_runloop_WorkResult.Aborted
        else:
            return self.execute(self.tasks.pop())

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.tasks = None
        _hx_o.thread = None
tink_runloop_QueueWorker._hx_class = tink_runloop_QueueWorker
_hx_classes["tink.runloop.QueueWorker"] = tink_runloop_QueueWorker


class tink_core__Signal_Signal_Impl_:
    _hx_class_name = "tink.core._Signal.Signal_Impl_"
    __slots__ = ()
    _hx_statics = ["_new", "map", "flatMap", "filter", "select", "join", "nextTime", "until", "next", "noise", "gather", "generate", "trigger", "create", "ofClassical"]

    @staticmethod
    def _new(f):
        return tink_core__Signal_SimpleSignal(f)

    @staticmethod
    def map(this1,f,gather = True):
        if (gather is None):
            gather = True
        def _hx_local_2(cb):
            def _hx_local_1():
                def _hx_local_0(result):
                    this2 = f(result)
                    tink_core__Callback_Callback_Impl_.invoke(cb,this2)
                return this1.handle(_hx_local_0)
            return _hx_local_1()
        ret = tink_core__Signal_SimpleSignal(_hx_local_2)
        if gather:
            return tink_core__Signal_Signal_Impl_.gather(ret)
        else:
            return ret

    @staticmethod
    def flatMap(this1,f,gather = True):
        if (gather is None):
            gather = True
        def _hx_local_2(cb):
            def _hx_local_1():
                def _hx_local_0(result):
                    f(result).handle(cb)
                return this1.handle(_hx_local_0)
            return _hx_local_1()
        ret = tink_core__Signal_SimpleSignal(_hx_local_2)
        if gather:
            return tink_core__Signal_Signal_Impl_.gather(ret)
        else:
            return ret

    @staticmethod
    def filter(this1,f,gather = True):
        if (gather is None):
            gather = True
        def _hx_local_2(cb):
            def _hx_local_1():
                def _hx_local_0(result):
                    if f(result):
                        tink_core__Callback_Callback_Impl_.invoke(cb,result)
                return this1.handle(_hx_local_0)
            return _hx_local_1()
        ret = tink_core__Signal_SimpleSignal(_hx_local_2)
        if gather:
            return tink_core__Signal_Signal_Impl_.gather(ret)
        else:
            return ret

    @staticmethod
    def select(this1,selector,gather = True):
        if (gather is None):
            gather = True
        def _hx_local_2(cb):
            def _hx_local_1():
                def _hx_local_0(result):
                    _g = selector(result)
                    this2 = _g.index
                    if (this2 == 0):
                        tink_core__Callback_Callback_Impl_.invoke(cb,_g.params[0])
                    elif (this2 == 1):
                        pass
                    else:
                        pass
                return this1.handle(_hx_local_0)
            return _hx_local_1()
        ret = tink_core__Signal_SimpleSignal(_hx_local_2)
        if gather:
            return tink_core__Signal_Signal_Impl_.gather(ret)
        else:
            return ret

    @staticmethod
    def join(this1,other,gather = True):
        if (gather is None):
            gather = True
        def _hx_local_0(cb):
            return tink_core__Callback_LinkPair(this1.handle(cb),other.handle(cb))
        ret = tink_core__Signal_SimpleSignal(_hx_local_0)
        if gather:
            return tink_core__Signal_Signal_Impl_.gather(ret)
        else:
            return ret

    @staticmethod
    def nextTime(this1,condition = None):
        ret = tink_core_FutureTrigger()
        link = None
        immediate = False
        def _hx_local_0(v):
            nonlocal immediate
            if ((condition is None) or condition(v)):
                ret.trigger(v)
                if (link is None):
                    immediate = True
                elif (link is not None):
                    link.cancel()
        link = this1.handle(_hx_local_0)
        if immediate:
            if (link is not None):
                link.cancel()
        return ret

    @staticmethod
    def until(this1,end):
        def _hx_local_0(_hx_yield):
            this2 = this1.handle(_hx_yield)
            if (this2 is None):
                return tink_core__Callback_CallbackLink_Impl_.noop
            else:
                return this2.cancel
        ret = tink_core__Signal_Suspendable(_hx_local_0)
        end.handle(tink_core__Callback_Callback_Impl_.fromNiladic(ret.kill))
        return ret

    @staticmethod
    def next(this1,condition = None):
        return tink_core__Signal_Signal_Impl_.nextTime(this1,condition)

    @staticmethod
    def noise(this1):
        def _hx_local_1():
            def _hx_local_0(_):
                return tink_core_Noise.Noise
            return tink_core__Signal_Signal_Impl_.map(this1,_hx_local_0)
        return _hx_local_1()

    @staticmethod
    def gather(this1):
        ret = tink_core__Signal_Signal_Impl_.trigger()
        def _hx_local_0(x):
            tink_core__Callback_CallbackList_Impl_.invoke(ret.handlers,x)
        this1.handle(_hx_local_0)
        return ret

    @staticmethod
    def generate(generator):
        ret = tink_core__Signal_Signal_Impl_.trigger()
        generator(ret.trigger)
        return ret

    @staticmethod
    def trigger():
        return tink_core_SignalTrigger()

    @staticmethod
    def create(create):
        return tink_core__Signal_Suspendable(create)

    @staticmethod
    def ofClassical(add,remove,gather = True):
        if (gather is None):
            gather = True
        def _hx_local_3(cb):
            def _hx_local_0(a):
                tink_core__Callback_Callback_Impl_.invoke(cb,a)
            f = _hx_local_0
            add(f)
            f1 = remove
            a1 = f
            def _hx_local_2():
                def _hx_local_1():
                    f1(a1)
                return tink_core__Callback_SimpleLink(_hx_local_1)
            return _hx_local_2()
        ret = tink_core__Signal_SimpleSignal(_hx_local_3)
        if gather:
            return tink_core__Signal_Signal_Impl_.gather(ret)
        else:
            return ret
tink_core__Signal_Signal_Impl_._hx_class = tink_core__Signal_Signal_Impl_
_hx_classes["tink.core._Signal.Signal_Impl_"] = tink_core__Signal_Signal_Impl_


class tink_core_SignalObject:
    _hx_class_name = "tink.core.SignalObject"
    __slots__ = ()
    _hx_methods = ["handle"]
tink_core_SignalObject._hx_class = tink_core_SignalObject
_hx_classes["tink.core.SignalObject"] = tink_core_SignalObject


class tink_core_SignalTrigger:
    _hx_class_name = "tink.core.SignalTrigger"
    __slots__ = ("handlers",)
    _hx_fields = ["handlers"]
    _hx_methods = ["trigger", "getLength", "handle", "clear", "asSignal"]
    _hx_interfaces = [tink_core_SignalObject]

    def __init__(self):
        self.handlers = []

    def trigger(self,event):
        tink_core__Callback_CallbackList_Impl_.invoke(self.handlers,event)

    def getLength(self):
        return len(self.handlers)

    def handle(self,cb):
        return tink_core__Callback_CallbackList_Impl_.add(self.handlers,cb)

    def clear(self):
        tink_core__Callback_CallbackList_Impl_.clear(self.handlers)

    def asSignal(self):
        return self

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.handlers = None
tink_core_SignalTrigger._hx_class = tink_core_SignalTrigger
_hx_classes["tink.core.SignalTrigger"] = tink_core_SignalTrigger


class tink_RunLoop(tink_runloop_QueueWorker):
    _hx_class_name = "tink.RunLoop"
    _hx_fields = ["retainCount", "running", "slaves", "done", "_done", "burstCap", "slaveCounter"]
    _hx_methods = ["burst", "enter", "spin", "log", "onError", "delegate", "tryDelegate", "retain", "bind", "synchronously", "runSlaves", "doStep", "createSlave"]
    _hx_statics = ["current", "getStamp", "create"]
    _hx_interfaces = []
    _hx_super = tink_runloop_QueueWorker


    def __init__(self,id = "ROOT_LOOP"):
        if (id is None):
            id = "ROOT_LOOP"
        self.running = None
        self.slaveCounter = 0
        self.burstCap = .25
        self.retainCount = 0
        self.slaves = []
        def _hx_local_0():
            self._done = tink_core__Signal_Signal_Impl_.trigger()
            return self._done
        self.done = _hx_local_0()
        super().__init__(self,id)

    def burst(self,time):
        limit = tink_RunLoop.getStamp()
        b = self.burstCap
        limit1 = (limit + ((time if (python_lib_Math.isnan(time)) else (b if (python_lib_Math.isnan(b)) else min(time,b)))))
        ret = None
        while self.running:
            _g = self.step()
            if (_g.index != 0):
                ret = _g
                break
            if (not ((tink_RunLoop.getStamp() < limit1))):
                break
        return ret

    def enter(self,init):
        if (not self.running):
            self.spin(init)
        else:
            self.work(tink_runloop__Task_Task_Impl_.ofFunction(init))

    def spin(self,init):
        self.running = True
        self.execute(tink_runloop__Task_Task_Impl_.ofFunction(init))
        tink_RunLoop.getStamp()
        while self.running:
            tmp = self.step().index
            if ((tmp == 4) or ((tmp == 3))):
                self.running = False
            else:
                pass

    def log(self,v,p = None):
        haxe_Log.trace(v,p)

    def onError(self,e,t,w,stack):
        if (w != self):
            self.log(t,_hx_AnonObject({'fileName': "tink/RunLoop.hx", 'lineNumber': 120, 'className': "tink.RunLoop", 'methodName': "onError"}))
            self.log((((("\nError on worker " + Std.string(w)) + ":\n") + HxOverrides.stringOrNull(haxe_CallStack.toString(stack))) + "\n"),_hx_AnonObject({'fileName': "tink/RunLoop.hx", 'lineNumber': 121, 'className': "tink.RunLoop", 'methodName': "onError"}))
            self.kill()
            raise _HxException(e)
        else:
            raise _HxException(e)

    def delegate(self,task,slave):
        _gthis = self
        t = tink_core_FutureTrigger()
        def _hx_local_1():
            _gthis.retainCount = (_gthis.retainCount + 1)
        self.asap(tink_runloop__Task_Task_Impl_.ofFunction(_hx_local_1))
        def _hx_local_4():
            res = task.get()
            def _hx_local_3():
                t.trigger(res)
                _gthis.retainCount = (_gthis.retainCount - 1)
            _gthis.work(tink_runloop__Task_Task_Impl_.ofFunction(_hx_local_3))
        slave.work(tink_runloop__Task_Task_Impl_.ofFunction(_hx_local_4))
        return t

    def tryDelegate(self,unsafe,slave,report):
        def _hx_local_1():
            def _hx_local_0():
                return unsafe.get()
            return self.delegate(tink_core__Lazy_LazyConst(tink_core_TypedError.catchExceptions(_hx_local_0,report,_hx_AnonObject({'fileName': "tink/RunLoop.hx", 'lineNumber': 155, 'className': "tink.RunLoop", 'methodName': "tryDelegate"}))),slave)
        return _hx_local_1()

    def retain(self):
        _gthis = self
        def _hx_local_1():
            _gthis.retainCount = (_gthis.retainCount + 1)
        self.asap(tink_runloop__Task_Task_Impl_.ofFunction(_hx_local_1))
        def _hx_local_5():
            def _hx_local_4():
                def _hx_local_3():
                    _gthis.retainCount = (_gthis.retainCount - 1)
                _gthis.asap(tink_runloop__Task_Task_Impl_.ofFunction(_hx_local_3))
            return tink_runloop__Task_Task_Impl_.ofFunction(_hx_local_4)
        return _hx_local_5()

    def bind(self,callback):
        _gthis = self
        if (callback is None):
            return None
        def _hx_local_1():
            _gthis.retainCount = (_gthis.retainCount + 1)
        self.asap(tink_runloop__Task_Task_Impl_.ofFunction(_hx_local_1))
        def _hx_local_2(result):
            def _hx_local_4():
                nonlocal callback
                if (callback is not None):
                    tink_core__Callback_Callback_Impl_.invoke(callback,result)
                    callback = None
                    _gthis.retainCount = (_gthis.retainCount - 1)
            _gthis.work(tink_runloop__Task_Task_Impl_.ofFunction(_hx_local_4))
        return _hx_local_2

    def synchronously(self,operation):
        return operation()

    def runSlaves(self):
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.slaveCounter
        _hx_local_0.slaveCounter = HxOverrides.mod(_hx_local_1, len(self.slaves))
        _hx_local_0.slaveCounter
        if (len(self.slaves) > 0):
            _g = 0
            _g1 = len(self.slaves)
            while (_g < _g1):
                _g = (_g + 1)
                def _hx_local_5():
                    _hx_local_3 = self
                    _hx_local_4 = _hx_local_3.slaveCounter
                    _hx_local_3.slaveCounter = (_hx_local_4 + 1)
                    return _hx_local_4
                _g2 = HxOverrides.mod(_hx_local_5(), len(self.slaves))
                if ((self.slaves[_g2] if _g2 >= 0 and _g2 < len(self.slaves) else None).step().index == 0):
                    return tink_runloop_WorkResult.Progressed
        return tink_runloop_WorkResult.Idle

    def doStep(self):
        _g = self.tasks.pop()
        if (_g is None):
            if (self.retainCount == 0):
                tink_core__Callback_CallbackList_Impl_.invoke(self._done.handlers,tink_core_Noise.Noise)
                return tink_runloop_WorkResult.Done
            else:
                return self.runSlaves()
        else:
            return self.execute(_g)

    def createSlave(self):
        w = tink_runloop_QueueWorker(self,((("" + HxOverrides.stringOrNull(self.id)) + "/worker#") + Std.string(len(self.slaves))))
        self.slaves.append(w)
        return w

    @staticmethod
    def getStamp():
        return python_lib_Timeit.default_timer()

    @staticmethod
    def create(init):
        tink_RunLoop.current.enter(init)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.retainCount = None
        _hx_o.running = None
        _hx_o.slaves = None
        _hx_o.done = None
        _hx_o._done = None
        _hx_o.burstCap = None
        _hx_o.slaveCounter = None
tink_RunLoop._hx_class = tink_RunLoop
_hx_classes["tink.RunLoop"] = tink_RunLoop


class tink_concurrent__Mutex_Mutex_Impl_:
    _hx_class_name = "tink.concurrent._Mutex.Mutex_Impl_"
    __slots__ = ()
    _hx_statics = ["_new", "synchronized"]

    @staticmethod
    def _new():
        return False

    @staticmethod
    def synchronized(this1,f):
        return f()
tink_concurrent__Mutex_Mutex_Impl_._hx_class = tink_concurrent__Mutex_Mutex_Impl_
_hx_classes["tink.concurrent._Mutex.Mutex_Impl_"] = tink_concurrent__Mutex_Mutex_Impl_


class tink_concurrent__Mutex_Impl_Impl_:
    _hx_class_name = "tink.concurrent._Mutex.Impl_Impl_"
    __slots__ = ()
    _hx_statics = ["_new", "tryAcquire", "acquire", "release"]

    @staticmethod
    def _new():
        return False

    @staticmethod
    def tryAcquire(this1):
        return True

    @staticmethod
    def acquire(this1):
        pass

    @staticmethod
    def release(this1):
        pass
tink_concurrent__Mutex_Impl_Impl_._hx_class = tink_concurrent__Mutex_Impl_Impl_
_hx_classes["tink.concurrent._Mutex.Impl_Impl_"] = tink_concurrent__Mutex_Impl_Impl_


class tink_concurrent__Queue_Queue_Impl_:
    _hx_class_name = "tink.concurrent._Queue.Queue_Impl_"
    __slots__ = ()
    _hx_statics = ["_new", "pop", "await"]

    @staticmethod
    def _new():
        return haxe_ds_List()

    @staticmethod
    def pop(this1):
        return this1.pop()

    @staticmethod
    def _hx_await(this1):
        return this1.pop()
tink_concurrent__Queue_Queue_Impl_._hx_class = tink_concurrent__Queue_Queue_Impl_
_hx_classes["tink.concurrent._Queue.Queue_Impl_"] = tink_concurrent__Queue_Queue_Impl_


class tink_concurrent__Queue_Impl_Impl_:
    _hx_class_name = "tink.concurrent._Queue.Impl_Impl_"
    __slots__ = ()
    _hx_statics = ["_new", "pop"]

    @staticmethod
    def _new():
        return haxe_ds_List()

    @staticmethod
    def pop(this1,block):
        return this1.pop()
tink_concurrent__Queue_Impl_Impl_._hx_class = tink_concurrent__Queue_Impl_Impl_
_hx_classes["tink.concurrent._Queue.Impl_Impl_"] = tink_concurrent__Queue_Impl_Impl_


class tink_concurrent__Thread_Thread_Impl_:
    _hx_class_name = "tink.concurrent._Thread.Thread_Impl_"
    __slots__ = ()
    _hx_statics = ["get_current", "MAIN"]
    current = None

    @staticmethod
    def get_current():
        return "Fake Main Thread"
tink_concurrent__Thread_Thread_Impl_._hx_class = tink_concurrent__Thread_Thread_Impl_
_hx_classes["tink.concurrent._Thread.Thread_Impl_"] = tink_concurrent__Thread_Thread_Impl_


class tink_concurrent__Thread_Impl_Impl_:
    _hx_class_name = "tink.concurrent._Thread.Impl_Impl_"
    __slots__ = ()
    _hx_statics = ["_new", "getCurrent"]

    @staticmethod
    def _new(s):
        return s

    @staticmethod
    def getCurrent():
        return "Fake Main Thread"
tink_concurrent__Thread_Impl_Impl_._hx_class = tink_concurrent__Thread_Impl_Impl_
_hx_classes["tink.concurrent._Thread.Impl_Impl_"] = tink_concurrent__Thread_Impl_Impl_


class tink_core_Annex:
    _hx_class_name = "tink.core.Annex"
    __slots__ = ("target", "registry")
    _hx_fields = ["target", "registry"]

    def __init__(self,target):
        self.target = target
        self.registry = haxe_ds_ObjectMap()

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.target = None
        _hx_o.registry = None
tink_core_Annex._hx_class = tink_core_Annex
_hx_classes["tink.core.Annex"] = tink_core_Annex


class tink_core__Callback_Callback_Impl_:
    _hx_class_name = "tink.core._Callback.Callback_Impl_"
    __slots__ = ()
    _hx_statics = ["_new", "toFunction", "depth", "MAX_DEPTH", "invoke", "ignore", "fromNiladic", "fromMany", "defer"]

    @staticmethod
    def _new(f):
        return f

    @staticmethod
    def toFunction(this1):
        return this1

    @staticmethod
    def invoke(this1,data):
        if (tink_core__Callback_Callback_Impl_.depth < 200):
            _hx_local_0 = tink_core__Callback_Callback_Impl_
            _hx_local_1 = _hx_local_0.depth
            _hx_local_0.depth = (_hx_local_1 + 1)
            _hx_local_1
            this1(data)
            _hx_local_2 = tink_core__Callback_Callback_Impl_
            _hx_local_3 = _hx_local_2.depth
            _hx_local_2.depth = (_hx_local_3 - 1)
            _hx_local_3
        else:
            _e = this1
            def _hx_local_4(data1):
                tink_core__Callback_Callback_Impl_.invoke(_e,data1)
            f = _hx_local_4
            data2 = data
            def _hx_local_5():
                f(data2)
            tink_core__Callback_Callback_Impl_.defer(_hx_local_5)

    @staticmethod
    def ignore(cb):
        def _hx_local_0(_):
            tink_core__Callback_Callback_Impl_.invoke(cb,tink_core_Noise.Noise)
        return _hx_local_0

    @staticmethod
    def fromNiladic(f):
        def _hx_local_0(_):
            f()
        return _hx_local_0

    @staticmethod
    def fromMany(callbacks):
        def _hx_local_0(v):
            _g = 0
            while (_g < len(callbacks)):
                def _hx_local_2():
                    nonlocal _g
                    _hx_local_1 = _g
                    _g = (_g + 1)
                    return _hx_local_1
                callback = python_internal_ArrayImpl._get(callbacks, _hx_local_2())
                tink_core__Callback_Callback_Impl_.invoke(callback,v)
        return _hx_local_0

    @staticmethod
    def defer(f):
        tink_RunLoop.current.work(tink_runloop__Task_Task_Impl_.ofFunction(f))
tink_core__Callback_Callback_Impl_._hx_class = tink_core__Callback_Callback_Impl_
_hx_classes["tink.core._Callback.Callback_Impl_"] = tink_core__Callback_Callback_Impl_


class tink_core__Callback_LinkObject:
    _hx_class_name = "tink.core._Callback.LinkObject"
    __slots__ = ()
    _hx_methods = ["cancel"]
tink_core__Callback_LinkObject._hx_class = tink_core__Callback_LinkObject
_hx_classes["tink.core._Callback.LinkObject"] = tink_core__Callback_LinkObject


class tink_core__Callback_CallbackLink_Impl_:
    _hx_class_name = "tink.core._Callback.CallbackLink_Impl_"
    __slots__ = ()
    _hx_statics = ["_new", "cancel", "dissolve", "noop", "toFunction", "toCallback", "fromFunction", "join", "fromMany"]

    @staticmethod
    def _new(link):
        return tink_core__Callback_SimpleLink(link)

    @staticmethod
    def cancel(this1):
        if (this1 is not None):
            this1.cancel()

    @staticmethod
    def dissolve(this1):
        if (this1 is not None):
            this1.cancel()

    @staticmethod
    def noop():
        pass

    @staticmethod
    def toFunction(this1):
        if (this1 is None):
            return tink_core__Callback_CallbackLink_Impl_.noop
        else:
            return this1.cancel

    @staticmethod
    def toCallback(this1):
        def _hx_local_0(_):
            this1.cancel()
        return _hx_local_0

    @staticmethod
    def fromFunction(f):
        return tink_core__Callback_SimpleLink(f)

    @staticmethod
    def join(a,b):
        return tink_core__Callback_LinkPair(a,b)

    @staticmethod
    def fromMany(callbacks):
        def _hx_local_2():
            def _hx_local_1():
                _g = 0
                while (_g < len(callbacks)):
                    cb = (callbacks[_g] if _g >= 0 and _g < len(callbacks) else None)
                    _g = (_g + 1)
                    if (cb is not None):
                        cb.cancel()
            return tink_core__Callback_SimpleLink(_hx_local_1)
        return _hx_local_2()
tink_core__Callback_CallbackLink_Impl_._hx_class = tink_core__Callback_CallbackLink_Impl_
_hx_classes["tink.core._Callback.CallbackLink_Impl_"] = tink_core__Callback_CallbackLink_Impl_


class tink_core__Callback_SimpleLink:
    _hx_class_name = "tink.core._Callback.SimpleLink"
    __slots__ = ("f",)
    _hx_fields = ["f"]
    _hx_methods = ["cancel"]
    _hx_interfaces = [tink_core__Callback_LinkObject]

    def __init__(self,f):
        self.f = f

    def cancel(self):
        if (self.f is not None):
            self.f()
            self.f = None

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.f = None
tink_core__Callback_SimpleLink._hx_class = tink_core__Callback_SimpleLink
_hx_classes["tink.core._Callback.SimpleLink"] = tink_core__Callback_SimpleLink


class tink_core__Callback_LinkPair:
    _hx_class_name = "tink.core._Callback.LinkPair"
    __slots__ = ("a", "b", "dissolved")
    _hx_fields = ["a", "b", "dissolved"]
    _hx_methods = ["cancel"]
    _hx_interfaces = [tink_core__Callback_LinkObject]

    def __init__(self,a,b):
        self.dissolved = False
        self.a = a
        self.b = b

    def cancel(self):
        if (not self.dissolved):
            self.dissolved = True
            this1 = self.a
            if (this1 is not None):
                this1.cancel()
            this2 = self.b
            if (this2 is not None):
                this2.cancel()
            self.a = None
            self.b = None

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.a = None
        _hx_o.b = None
        _hx_o.dissolved = None
tink_core__Callback_LinkPair._hx_class = tink_core__Callback_LinkPair
_hx_classes["tink.core._Callback.LinkPair"] = tink_core__Callback_LinkPair


class tink_core__Callback_ListCell:
    _hx_class_name = "tink.core._Callback.ListCell"
    __slots__ = ("list", "cb")
    _hx_fields = ["list", "cb"]
    _hx_methods = ["invoke", "clear", "cancel"]
    _hx_interfaces = [tink_core__Callback_LinkObject]

    def __init__(self,cb,_hx_list):
        if (cb is None):
            raise _HxException("callback expected but null received")
        self.cb = cb
        self.list = _hx_list

    def invoke(self,data):
        if (self.cb is not None):
            tink_core__Callback_Callback_Impl_.invoke(self.cb,data)

    def clear(self):
        self.list = None
        self.cb = None

    def cancel(self):
        _g = self.list
        if (_g is not None):
            self.clear()
            python_internal_ArrayImpl.remove(_g,self)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.list = None
        _hx_o.cb = None
tink_core__Callback_ListCell._hx_class = tink_core__Callback_ListCell
_hx_classes["tink.core._Callback.ListCell"] = tink_core__Callback_ListCell


class tink_core__Callback_CallbackList_Impl_:
    _hx_class_name = "tink.core._Callback.CallbackList_Impl_"
    __slots__ = ()
    _hx_statics = ["_new", "get_length", "add", "invoke", "clear", "invokeAndClear"]
    length = None

    @staticmethod
    def _new():
        return []

    @staticmethod
    def get_length(this1):
        return len(this1)

    @staticmethod
    def add(this1,cb):
        node = tink_core__Callback_ListCell(cb,this1)
        this1.append(node)
        return node

    @staticmethod
    def invoke(this1,data):
        _g = 0
        _g1 = list(this1)
        while (_g < len(_g1)):
            cell = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            if (cell.cb is not None):
                tink_core__Callback_Callback_Impl_.invoke(cell.cb,data)

    @staticmethod
    def clear(this1):
        _g = 0
        _hx_len = len(this1)
        res = this1[0:_hx_len]
        del this1[0:_hx_len]
        while (_g < len(res)):
            def _hx_local_1():
                nonlocal _g
                _hx_local_0 = _g
                _g = (_g + 1)
                return _hx_local_0
            cell = python_internal_ArrayImpl._get(res, _hx_local_1())
            cell.clear()

    @staticmethod
    def invokeAndClear(this1,data):
        _g = 0
        _hx_len = len(this1)
        res = this1[0:_hx_len]
        del this1[0:_hx_len]
        while (_g < len(res)):
            cell = (res[_g] if _g >= 0 and _g < len(res) else None)
            _g = (_g + 1)
            if (cell.cb is not None):
                tink_core__Callback_Callback_Impl_.invoke(cell.cb,data)
tink_core__Callback_CallbackList_Impl_._hx_class = tink_core__Callback_CallbackList_Impl_
_hx_classes["tink.core._Callback.CallbackList_Impl_"] = tink_core__Callback_CallbackList_Impl_


class tink_core_TypedError:
    _hx_class_name = "tink.core.TypedError"
    __slots__ = ("message", "code", "data", "pos", "callStack", "exceptionStack", "isTinkError")
    _hx_fields = ["message", "code", "data", "pos", "callStack", "exceptionStack", "isTinkError"]
    _hx_methods = ["printPos", "toString", "throwSelf"]
    _hx_statics = ["withData", "typed", "asError", "catchExceptions", "reporter", "rethrow", "tryFinally"]

    def __init__(self,code = 500,message = None,pos = None):
        if (code is None):
            code = 500
        self.data = None
        self.isTinkError = True
        self.code = code
        self.message = message
        self.pos = pos
        self.exceptionStack = []
        self.callStack = []

    def printPos(self):
        return ((((HxOverrides.stringOrNull(self.pos.className) + ".") + HxOverrides.stringOrNull(self.pos.methodName)) + ":") + Std.string(self.pos.lineNumber))

    def toString(self):
        ret = ((("Error#" + Std.string(self.code)) + ": ") + HxOverrides.stringOrNull(self.message))
        if (self.pos is not None):
            ret = (("null" if ret is None else ret) + HxOverrides.stringOrNull(((" @ " + HxOverrides.stringOrNull(self.printPos())))))
        return ret

    def throwSelf(self):
        raise _HxException(self)

    @staticmethod
    def withData(code = None,message = None,data = None,pos = None):
        return tink_core_TypedError.typed(code,message,data,pos)

    @staticmethod
    def typed(code = None,message = None,data = None,pos = None):
        ret = tink_core_TypedError(code,message,pos)
        ret.data = data
        return ret

    @staticmethod
    def asError(v):
        try:
            if isinstance(v,tink_core_TypedError):
                return v
            else:
                return None
        except Exception as _hx_e:
            _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
            e = _hx_e1
            return None

    @staticmethod
    def catchExceptions(f,report = None,pos = None):
        try:
            return tink_core_Outcome.Success(f())
        except Exception as _hx_e:
            _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
            e = _hx_e1
            _g = tink_core_TypedError.asError(e)
            return tink_core_Outcome.Failure(((tink_core_TypedError.withData(None,"Unexpected Error",e,pos) if ((report is None)) else report(e)) if ((_g is None)) else _g))

    @staticmethod
    def reporter(code = None,message = None,pos = None):
        def _hx_local_0(e):
            return tink_core_TypedError.withData(code,message,e,pos)
        return _hx_local_0

    @staticmethod
    def rethrow(any):
        raise _HxException(any)

    @staticmethod
    def tryFinally(f,cleanup):
        try:
            ret = f()
            cleanup()
            return ret
        except Exception as _hx_e:
            _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
            e = _hx_e1
            cleanup()
            raise _HxException(e)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.message = None
        _hx_o.code = None
        _hx_o.data = None
        _hx_o.pos = None
        _hx_o.callStack = None
        _hx_o.exceptionStack = None
        _hx_o.isTinkError = None
tink_core_TypedError._hx_class = tink_core_TypedError
_hx_classes["tink.core.TypedError"] = tink_core_TypedError


class tink_core__Error_Stack_Impl_:
    _hx_class_name = "tink.core._Error.Stack_Impl_"
    __slots__ = ()
    _hx_statics = ["toString"]

    @staticmethod
    def toString(this1):
        return "Error stack not available. Compile with -D error_stack."
tink_core__Error_Stack_Impl_._hx_class = tink_core__Error_Stack_Impl_
_hx_classes["tink.core._Error.Stack_Impl_"] = tink_core__Error_Stack_Impl_


class tink_core__Future_FutureObject:
    _hx_class_name = "tink.core._Future.FutureObject"
    __slots__ = ()
    _hx_methods = ["map", "flatMap", "handle", "gather", "eager"]
tink_core__Future_FutureObject._hx_class = tink_core__Future_FutureObject
_hx_classes["tink.core._Future.FutureObject"] = tink_core__Future_FutureObject


class tink_core__Future_NeverFuture:
    _hx_class_name = "tink.core._Future.NeverFuture"
    __slots__ = ()
    _hx_methods = ["map", "flatMap", "handle", "gather", "eager"]
    _hx_statics = ["inst"]
    _hx_interfaces = [tink_core__Future_FutureObject]

    def __init__(self):
        pass

    def map(self,f):
        return tink_core__Future_NeverFuture.inst

    def flatMap(self,f):
        return tink_core__Future_NeverFuture.inst

    def handle(self,callback):
        return None

    def gather(self):
        return tink_core__Future_NeverFuture.inst

    def eager(self):
        return tink_core__Future_NeverFuture.inst

    @staticmethod
    def _hx_empty_init(_hx_o):        pass
tink_core__Future_NeverFuture._hx_class = tink_core__Future_NeverFuture
_hx_classes["tink.core._Future.NeverFuture"] = tink_core__Future_NeverFuture


class tink_core__Lazy_LazyObject:
    _hx_class_name = "tink.core._Lazy.LazyObject"
    __slots__ = ()
    _hx_methods = ["get", "map", "flatMap"]
tink_core__Lazy_LazyObject._hx_class = tink_core__Lazy_LazyObject
_hx_classes["tink.core._Lazy.LazyObject"] = tink_core__Lazy_LazyObject


class tink_core__Lazy_LazyConst:
    _hx_class_name = "tink.core._Lazy.LazyConst"
    __slots__ = ("value",)
    _hx_fields = ["value"]
    _hx_methods = ["get", "map", "flatMap"]
    _hx_interfaces = [tink_core__Lazy_LazyObject]

    def __init__(self,value):
        self.value = value

    def get(self):
        return self.value

    def map(self,f):
        _gthis = self
        def _hx_local_1():
            def _hx_local_0():
                return f(_gthis.value)
            return tink_core__Lazy_LazyFunc(_hx_local_0)
        return _hx_local_1()

    def flatMap(self,f):
        _gthis = self
        def _hx_local_1():
            def _hx_local_0():
                return f(_gthis.value).get()
            return tink_core__Lazy_LazyFunc(_hx_local_0)
        return _hx_local_1()

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.value = None
tink_core__Lazy_LazyConst._hx_class = tink_core__Lazy_LazyConst
_hx_classes["tink.core._Lazy.LazyConst"] = tink_core__Lazy_LazyConst


class tink_core__Future_SyncFuture:
    _hx_class_name = "tink.core._Future.SyncFuture"
    __slots__ = ("value",)
    _hx_fields = ["value"]
    _hx_methods = ["map", "flatMap", "handle", "eager", "gather"]
    _hx_interfaces = [tink_core__Future_FutureObject]

    def __init__(self,value):
        self.value = value

    def map(self,f):
        return tink_core__Future_SyncFuture(self.value.map(f))

    def flatMap(self,f):
        l = self.value.map(f)
        def _hx_local_1():
            def _hx_local_0(cb):
                return l.get().handle(cb)
            return tink_core__Future_SimpleFuture(_hx_local_0)
        return _hx_local_1()

    def handle(self,cb):
        tink_core__Callback_Callback_Impl_.invoke(cb,self.value.get())
        return None

    def eager(self):
        return self

    def gather(self):
        return self

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.value = None
tink_core__Future_SyncFuture._hx_class = tink_core__Future_SyncFuture
_hx_classes["tink.core._Future.SyncFuture"] = tink_core__Future_SyncFuture

class tink_core_Noise(Enum):
    __slots__ = ()
    _hx_class_name = "tink.core.Noise"
    _hx_constructs = ["Noise"]
tink_core_Noise.Noise = tink_core_Noise("Noise", 0, list())
tink_core_Noise._hx_class = tink_core_Noise
_hx_classes["tink.core.Noise"] = tink_core_Noise


class tink_core__Future_Future_Impl_:
    _hx_class_name = "tink.core._Future.Future_Impl_"
    __slots__ = ()
    _hx_statics = ["NULL", "NOISE", "NEVER", "_new", "first", "map", "flatMap", "next", "merge", "flatten", "ofAny", "asPromise", "ofMany", "fromMany", "lazy", "sync", "make", "or", "either", "and", "_tryFailingFlatMap", "_tryFlatMap", "_tryFailingMap", "_tryMap", "_flatMap", "_map", "trigger", "delay"]

    @staticmethod
    def _new(f):
        return tink_core__Future_SimpleFuture(f)

    @staticmethod
    def first(this1,other):
        ret = tink_core_FutureTrigger()
        l1 = this1.handle(ret.trigger)
        l2 = other.handle(ret.trigger)
        ret1 = ret
        if (l1 is not None):
            this2 = l1
            def _hx_local_0(_):
                this2.cancel()
            ret1.handle(_hx_local_0)
        if (l2 is not None):
            this3 = l2
            def _hx_local_1(_1):
                this3.cancel()
            ret1.handle(_hx_local_1)
        return ret1

    @staticmethod
    def map(this1,f,gather = True):
        if (gather is None):
            gather = True
        ret = this1.map(f)
        if gather:
            return ret.gather()
        else:
            return ret

    @staticmethod
    def flatMap(this1,next,gather = True):
        if (gather is None):
            gather = True
        ret = this1.flatMap(next)
        if gather:
            return ret.gather()
        else:
            return ret

    @staticmethod
    def next(this1,n):
        def _hx_local_1():
            def _hx_local_0(v):
                return n(v)
            return this1.flatMap(_hx_local_0)
        return _hx_local_1()

    @staticmethod
    def merge(this1,other,merger,gather = True):
        if (gather is None):
            gather = True
        def _hx_local_2(t):
            def _hx_local_1():
                def _hx_local_0(a):
                    return merger(t,a)
                return other.map(_hx_local_0)
            return _hx_local_1()
        ret = this1.flatMap(_hx_local_2)
        if gather:
            return ret.gather()
        else:
            return ret

    @staticmethod
    def flatten(f):
        return tink_core__Future_NestedFuture(f)

    @staticmethod
    def ofAny(v):
        return tink_core__Future_SyncFuture(tink_core__Lazy_LazyConst(v))

    @staticmethod
    def asPromise(s):
        return s

    @staticmethod
    def ofMany(futures,gather = True):
        if (gather is None):
            gather = True
        ret = tink_core__Future_SyncFuture(tink_core__Lazy_LazyConst([]))
        _g = 0
        while (_g < len(futures)):
            def _hx_local_1():
                nonlocal _g
                _hx_local_0 = _g
                _g = (_g + 1)
                return _hx_local_0
            f = [python_internal_ArrayImpl._get(futures, _hx_local_1())]
            def _hx_local_5(f1):
                def _hx_local_2(results):
                    def _hx_local_4():
                        def _hx_local_3(result):
                            return (results + [result])
                        return _hx_local_3
                    ret1 = _hx_local_4()
                    return (f1[0] if 0 < len(f1) else None).map(ret1)
                return _hx_local_2
            ret = ret.flatMap(_hx_local_5(f))
        if gather:
            return ret.gather()
        else:
            return ret

    @staticmethod
    def fromMany(futures):
        return tink_core__Future_Future_Impl_.ofMany(futures)

    @staticmethod
    def lazy(l):
        return tink_core__Future_SyncFuture(l)

    @staticmethod
    def sync(v):
        return tink_core__Future_SyncFuture(tink_core__Lazy_LazyConst(v))

    @staticmethod
    def make(f,lazy = False):
        if (lazy is None):
            lazy = False
        if lazy:
            return tink_core__Future_LazyTrigger(f)
        else:
            op = tink_core_FutureTrigger()
            tink_core__Callback_Callback_Impl_.invoke(f,op.trigger)
            return op

    @staticmethod
    def _hx_or(a,b):
        return tink_core__Future_Future_Impl_.first(a,b)

    @staticmethod
    def either(a,b):
        return tink_core__Future_Future_Impl_.first(a.map(haxe_ds_Either.Left),b.map(haxe_ds_Either.Right))

    @staticmethod
    def _hx_and(a,b):
        def _hx_local_1():
            def _hx_local_0(a1,b1):
                return tink_core_MPair(a1,b1)
            return tink_core__Future_Future_Impl_.merge(a,b,_hx_local_0)
        return _hx_local_1()

    @staticmethod
    def _tryFailingFlatMap(f,_hx_map):
        def _hx_local_1():
            def _hx_local_0(o):
                ret = o.index
                if (ret == 0):
                    return _hx_map(o.params[0])
                elif (ret == 1):
                    return tink_core__Future_SyncFuture(tink_core__Lazy_LazyConst(tink_core_Outcome.Failure(o.params[0])))
                else:
                    pass
            return f.flatMap(_hx_local_0).gather()
        return _hx_local_1()

    @staticmethod
    def _tryFlatMap(f,_hx_map):
        def _hx_local_1():
            def _hx_local_0(o):
                ret = o.index
                if (ret == 0):
                    return _hx_map(o.params[0]).map(tink_core_Outcome.Success).gather()
                elif (ret == 1):
                    return tink_core__Future_SyncFuture(tink_core__Lazy_LazyConst(tink_core_Outcome.Failure(o.params[0])))
                else:
                    pass
            return f.flatMap(_hx_local_0).gather()
        return _hx_local_1()

    @staticmethod
    def _tryFailingMap(f,_hx_map):
        def _hx_local_1():
            def _hx_local_0(o):
                return tink_core_OutcomeTools.flatMap(o,tink_core__Outcome_OutcomeMapper_Impl_.withSameError(_hx_map))
            return f.map(_hx_local_0).gather()
        return _hx_local_1()

    @staticmethod
    def _tryMap(f,_hx_map):
        def _hx_local_1():
            def _hx_local_0(o):
                return tink_core_OutcomeTools.map(o,_hx_map)
            return f.map(_hx_local_0).gather()
        return _hx_local_1()

    @staticmethod
    def _flatMap(f,_hx_map):
        return f.flatMap(_hx_map).gather()

    @staticmethod
    def _map(f,_hx_map):
        return f.map(_hx_map).gather()

    @staticmethod
    def trigger():
        return tink_core_FutureTrigger()

    @staticmethod
    def delay(ms,value):
        def _hx_local_2():
            def _hx_local_1(cb):
                def _hx_local_0():
                    cb(value.get())
                haxe_Timer.delay(_hx_local_0,ms)
            return tink_core__Future_Future_Impl_.make(_hx_local_1)
        return _hx_local_2()
tink_core__Future_Future_Impl_._hx_class = tink_core__Future_Future_Impl_
_hx_classes["tink.core._Future.Future_Impl_"] = tink_core__Future_Future_Impl_


class tink_core__Future_SimpleFuture:
    _hx_class_name = "tink.core._Future.SimpleFuture"
    __slots__ = ("f", "gathered")
    _hx_fields = ["f", "gathered"]
    _hx_methods = ["handle", "map", "flatMap", "gather", "eager"]
    _hx_interfaces = [tink_core__Future_FutureObject]

    def __init__(self,f):
        self.gathered = None
        self.f = f

    def handle(self,callback):
        return self.f(callback)

    def map(self,f):
        _gthis = self
        def _hx_local_3():
            def _hx_local_2(cb):
                def _hx_local_1():
                    def _hx_local_0(v):
                        tmp = f(v)
                        tink_core__Callback_Callback_Impl_.invoke(cb,tmp)
                    return _gthis.f(_hx_local_0)
                return _hx_local_1()
            return tink_core__Future_SimpleFuture(_hx_local_2)
        return _hx_local_3()

    def flatMap(self,f):
        f1 = f
        _gthis = self
        def _hx_local_3():
            def _hx_local_2(cb):
                def _hx_local_1():
                    def _hx_local_0(v):
                        tmp = f1(v)
                        tink_core__Callback_Callback_Impl_.invoke(cb,tmp)
                    return _gthis.f(_hx_local_0)
                return _hx_local_1()
            return tink_core__Future_Future_Impl_.flatten(tink_core__Future_SimpleFuture(_hx_local_2))
        return _hx_local_3()

    def gather(self):
        if (self.gathered is not None):
            return self.gathered
        else:
            def _hx_local_1():
                def _hx_local_0():
                    self.gathered = tink_core_FutureTrigger.gatherFuture(self)
                    return self.gathered
                return _hx_local_0()
            return _hx_local_1()

    def eager(self):
        def _hx_local_2():
            def _hx_local_0():
                self.gathered = tink_core_FutureTrigger.gatherFuture(self)
                return self.gathered
            return self.gathered if (self.gathered is not None) else _hx_local_0()
        ret = _hx_local_2()
        def _hx_local_3():
            pass
        ret.handle(tink_core__Callback_Callback_Impl_.fromNiladic(_hx_local_3))
        return ret

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.f = None
        _hx_o.gathered = None
tink_core__Future_SimpleFuture._hx_class = tink_core__Future_SimpleFuture
_hx_classes["tink.core._Future.SimpleFuture"] = tink_core__Future_SimpleFuture


class tink_core__Future_NestedFuture:
    _hx_class_name = "tink.core._Future.NestedFuture"
    __slots__ = ("outer", "gathered")
    _hx_fields = ["outer", "gathered"]
    _hx_methods = ["map", "flatMap", "gather", "eager", "handle"]
    _hx_interfaces = [tink_core__Future_FutureObject]

    def __init__(self,outer):
        self.gathered = None
        self.outer = outer

    def map(self,f):
        def _hx_local_1():
            def _hx_local_0(inner):
                return inner.map(f).gather()
            return self.outer.flatMap(_hx_local_0).gather()
        return _hx_local_1()

    def flatMap(self,f):
        def _hx_local_1():
            def _hx_local_0(inner):
                return inner.flatMap(f).gather()
            return self.outer.flatMap(_hx_local_0).gather()
        return _hx_local_1()

    def gather(self):
        if (self.gathered is not None):
            return self.gathered
        else:
            def _hx_local_1():
                def _hx_local_0():
                    self.gathered = tink_core_FutureTrigger.gatherFuture(self)
                    return self.gathered
                return _hx_local_0()
            return _hx_local_1()

    def eager(self):
        def _hx_local_2():
            def _hx_local_0():
                self.gathered = tink_core_FutureTrigger.gatherFuture(self)
                return self.gathered
            return self.gathered if (self.gathered is not None) else _hx_local_0()
        ret = _hx_local_2()
        def _hx_local_3():
            pass
        ret.handle(tink_core__Callback_Callback_Impl_.fromNiladic(_hx_local_3))
        return ret

    def handle(self,cb):
        ret = None
        def _hx_local_1(inner):
            nonlocal ret
            def _hx_local_0(result):
                tink_core__Callback_Callback_Impl_.invoke(cb,result)
            ret = inner.handle(_hx_local_0)
        ret = self.outer.handle(_hx_local_1)
        return ret

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.outer = None
        _hx_o.gathered = None
tink_core__Future_NestedFuture._hx_class = tink_core__Future_NestedFuture
_hx_classes["tink.core._Future.NestedFuture"] = tink_core__Future_NestedFuture


class tink_core_FutureTrigger:
    _hx_class_name = "tink.core.FutureTrigger"
    __slots__ = ("result", "list")
    _hx_fields = ["result", "list"]
    _hx_methods = ["handle", "map", "flatMap", "gather", "eager", "asFuture", "trigger"]
    _hx_statics = ["gatherFuture"]
    _hx_interfaces = [tink_core__Future_FutureObject]

    def __init__(self):
        self.result = None
        self.list = []

    def handle(self,callback):
        _g = self.list
        if (_g is None):
            tink_core__Callback_Callback_Impl_.invoke(callback,self.result)
            return None
        else:
            return tink_core__Callback_CallbackList_Impl_.add(_g,callback)

    def map(self,f):
        if (self.list is None):
            return tink_core__Future_SyncFuture(tink_core__Lazy_LazyConst(f(self.result)))
        else:
            ret = tink_core_FutureTrigger()
            def _hx_local_0(v):
                tmp = f(v)
                ret.trigger(tmp)
            tink_core__Callback_CallbackList_Impl_.add(self.list,_hx_local_0)
            return ret

    def flatMap(self,f):
        if (self.list is None):
            return f(self.result)
        else:
            ret = tink_core_FutureTrigger()
            def _hx_local_0(v):
                f(v).handle(ret.trigger)
            tink_core__Callback_CallbackList_Impl_.add(self.list,_hx_local_0)
            return ret

    def gather(self):
        return self

    def eager(self):
        return self

    def asFuture(self):
        return self

    def trigger(self,result):
        if (self.list is None):
            return False
        else:
            _hx_list = self.list
            self.list = None
            self.result = result
            tink_core__Callback_CallbackList_Impl_.invoke(_hx_list,result)
            tink_core__Callback_CallbackList_Impl_.clear(_hx_list)
            return True

    @staticmethod
    def gatherFuture(f):
        op = None
        def _hx_local_1():
            def _hx_local_0(cb):
                nonlocal op
                nonlocal f
                if (op is None):
                    op = tink_core_FutureTrigger()
                    f.handle(op.trigger)
                    f = None
                return op.handle(cb)
            return tink_core__Future_SimpleFuture(_hx_local_0)
        return _hx_local_1()

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.result = None
        _hx_o.list = None
tink_core_FutureTrigger._hx_class = tink_core_FutureTrigger
_hx_classes["tink.core.FutureTrigger"] = tink_core_FutureTrigger


class tink_core__Future_LazyTrigger(tink_core_FutureTrigger):
    _hx_class_name = "tink.core._Future.LazyTrigger"
    __slots__ = ("op",)
    _hx_fields = ["op"]
    _hx_methods = ["eager", "map", "flatMap", "handle"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = tink_core_FutureTrigger


    def __init__(self,op):
        self.op = op
        super().__init__()

    def eager(self):
        if (self.op is not None):
            op = self.op
            self.op = None
            tink_core__Callback_Callback_Impl_.invoke(op,self.trigger)
        return self

    def map(self,f):
        _gthis = self
        if (self.op is None):
            return super().map(f)
        else:
            def _hx_local_2():
                def _hx_local_1(cb):
                    def _hx_local_0(v):
                        tmp = f(v)
                        cb(tmp)
                    _gthis.handle(_hx_local_0)
                return tink_core__Future_Future_Impl_.make(_hx_local_1,True)
            return _hx_local_2()

    def flatMap(self,f):
        _gthis = self
        if (self.op is None):
            return super().flatMap(f)
        else:
            def _hx_local_2():
                def _hx_local_1(cb):
                    def _hx_local_0(v):
                        f(v).handle(cb)
                    _gthis.handle(_hx_local_0)
                return tink_core__Future_Future_Impl_.make(_hx_local_1,True)
            return _hx_local_2()

    def handle(self,cb):
        self.eager()
        return super().handle(cb)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.op = None
tink_core__Future_LazyTrigger._hx_class = tink_core__Future_LazyTrigger
_hx_classes["tink.core._Future.LazyTrigger"] = tink_core__Future_LazyTrigger


class tink_core__Lazy_Lazy_Impl_:
    _hx_class_name = "tink.core._Lazy.Lazy_Impl_"
    __slots__ = ()
    _hx_statics = ["get", "ofFunc", "map", "flatMap", "ofConst"]

    @staticmethod
    def get(this1):
        return this1.get()

    @staticmethod
    def ofFunc(f):
        return tink_core__Lazy_LazyFunc(f)

    @staticmethod
    def map(this1,f):
        return this1.map(f)

    @staticmethod
    def flatMap(this1,f):
        return this1.flatMap(f)

    @staticmethod
    def ofConst(c):
        return tink_core__Lazy_LazyConst(c)
tink_core__Lazy_Lazy_Impl_._hx_class = tink_core__Lazy_Lazy_Impl_
_hx_classes["tink.core._Lazy.Lazy_Impl_"] = tink_core__Lazy_Lazy_Impl_


class tink_core__Lazy_LazyFunc:
    _hx_class_name = "tink.core._Lazy.LazyFunc"
    __slots__ = ("f", "result")
    _hx_fields = ["f", "result"]
    _hx_methods = ["get", "map", "flatMap"]
    _hx_interfaces = [tink_core__Lazy_LazyObject]

    def __init__(self,f):
        self.result = None
        self.f = f

    def get(self):
        if (self.f is not None):
            self.result = self.f()
            self.f = None
        return self.result

    def map(self,f):
        _gthis = self
        def _hx_local_1():
            def _hx_local_0():
                tmp = _gthis.get()
                return f(tmp)
            return tink_core__Lazy_LazyFunc(_hx_local_0)
        return _hx_local_1()

    def flatMap(self,f):
        _gthis = self
        def _hx_local_1():
            def _hx_local_0():
                this1 = _gthis.get()
                return f(this1).get()
            return tink_core__Lazy_LazyFunc(_hx_local_0)
        return _hx_local_1()

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.f = None
        _hx_o.result = None
tink_core__Lazy_LazyFunc._hx_class = tink_core__Lazy_LazyFunc
_hx_classes["tink.core._Lazy.LazyFunc"] = tink_core__Lazy_LazyFunc


class tink_core_NamedWith:
    _hx_class_name = "tink.core.NamedWith"
    __slots__ = ("name", "value")
    _hx_fields = ["name", "value"]

    def __init__(self,name,value):
        self.name = name
        self.value = value

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.name = None
        _hx_o.value = None
tink_core_NamedWith._hx_class = tink_core_NamedWith
_hx_classes["tink.core.NamedWith"] = tink_core_NamedWith


class tink_core_OptionTools:
    _hx_class_name = "tink.core.OptionTools"
    __slots__ = ()
    _hx_statics = ["force", "or", "orNull", "filter", "satisfies", "equals", "map", "flatMap", "iterator", "toArray"]

    @staticmethod
    def force(o,pos = None):
        if (o.index == 0):
            return o.params[0]
        else:
            raise _HxException(tink_core_TypedError(404,"Some value expected but none found",pos))

    @staticmethod
    def _hx_or(o,l):
        if (o.index == 0):
            return o.params[0]
        else:
            return l.get()

    @staticmethod
    def orNull(o):
        if (o.index == 0):
            return o.params[0]
        else:
            return None

    @staticmethod
    def filter(o,f):
        if (o.index == 0):
            if (f(o.params[0]) == False):
                return haxe_ds_Option._hx_None
            else:
                return o
        else:
            return o

    @staticmethod
    def satisfies(o,f):
        if (o.index == 0):
            return f(o.params[0])
        else:
            return False

    @staticmethod
    def equals(o,v):
        if (o.index == 0):
            return HxOverrides.eq(o.params[0],v)
        else:
            return False

    @staticmethod
    def map(o,f):
        if (o.index == 0):
            return haxe_ds_Option.Some(f(o.params[0]))
        else:
            return haxe_ds_Option._hx_None

    @staticmethod
    def flatMap(o,f):
        if (o.index == 0):
            return f(o.params[0])
        else:
            return haxe_ds_Option._hx_None

    @staticmethod
    def iterator(o):
        return tink_core_OptionIter(o)

    @staticmethod
    def toArray(o):
        if (o.index == 0):
            return [o.params[0]]
        else:
            return []
tink_core_OptionTools._hx_class = tink_core_OptionTools
_hx_classes["tink.core.OptionTools"] = tink_core_OptionTools


class tink_core_OptionIter:
    _hx_class_name = "tink.core.OptionIter"
    __slots__ = ("value", "alive")
    _hx_fields = ["value", "alive"]
    _hx_methods = ["hasNext", "next"]

    def __init__(self,o):
        self.value = None
        self.alive = True
        if (o.index == 0):
            self.value = o.params[0]
        else:
            self.alive = False

    def hasNext(self):
        return self.alive

    def next(self):
        self.alive = False
        return self.value

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.value = None
        _hx_o.alive = None
tink_core_OptionIter._hx_class = tink_core_OptionIter
_hx_classes["tink.core.OptionIter"] = tink_core_OptionIter

class tink_core_Outcome(Enum):
    __slots__ = ()
    _hx_class_name = "tink.core.Outcome"
    _hx_constructs = ["Success", "Failure"]

    @staticmethod
    def Success(data):
        return tink_core_Outcome("Success", 0, [data])

    @staticmethod
    def Failure(failure):
        return tink_core_Outcome("Failure", 1, [failure])
tink_core_Outcome._hx_class = tink_core_Outcome
_hx_classes["tink.core.Outcome"] = tink_core_Outcome


class tink_core_OutcomeTools:
    _hx_class_name = "tink.core.OutcomeTools"
    __slots__ = ()
    _hx_statics = ["sure", "toOption", "toOutcome", "orNull", "orUse", "orTry", "equals", "map", "isSuccess", "flatMap", "swap", "attempt", "flatten"]

    @staticmethod
    def sure(outcome):
        tmp = outcome.index
        if (tmp == 0):
            return outcome.params[0]
        elif (tmp == 1):
            failure = outcome.params[0]
            _g = tink_core_TypedError.asError(failure)
            if (_g is None):
                raise _HxException(failure)
            else:
                return _g.throwSelf()
        else:
            pass

    @staticmethod
    def toOption(outcome):
        tmp = outcome.index
        if (tmp == 0):
            return haxe_ds_Option.Some(outcome.params[0])
        elif (tmp == 1):
            return haxe_ds_Option._hx_None
        else:
            pass

    @staticmethod
    def toOutcome(option,pos = None):
        tmp = option.index
        if (tmp == 0):
            return tink_core_Outcome.Success(option.params[0])
        elif (tmp == 1):
            return tink_core_Outcome.Failure(tink_core_TypedError(404,((("Some value expected but none found in " + HxOverrides.stringOrNull(pos.fileName)) + "@line ") + Std.string(pos.lineNumber)),_hx_AnonObject({'fileName': "tink/core/Outcome.hx", 'lineNumber': 47, 'className': "tink.core.OutcomeTools", 'methodName': "toOutcome"})))
        else:
            pass

    @staticmethod
    def orNull(outcome):
        tmp = outcome.index
        if (tmp == 0):
            return outcome.params[0]
        elif (tmp == 1):
            return None
        else:
            pass

    @staticmethod
    def orUse(outcome,fallback):
        tmp = outcome.index
        if (tmp == 0):
            return outcome.params[0]
        elif (tmp == 1):
            return fallback.get()
        else:
            pass

    @staticmethod
    def orTry(outcome,fallback):
        tmp = outcome.index
        if (tmp == 0):
            return outcome
        elif (tmp == 1):
            return fallback.get()
        else:
            pass

    @staticmethod
    def equals(outcome,to):
        tmp = outcome.index
        if (tmp == 0):
            return HxOverrides.eq(outcome.params[0],to)
        elif (tmp == 1):
            return False
        else:
            pass

    @staticmethod
    def map(outcome,transform):
        tmp = outcome.index
        if (tmp == 0):
            return tink_core_Outcome.Success(transform(outcome.params[0]))
        elif (tmp == 1):
            return tink_core_Outcome.Failure(outcome.params[0])
        else:
            pass

    @staticmethod
    def isSuccess(outcome):
        if (outcome.index == 0):
            return True
        else:
            return False

    @staticmethod
    def flatMap(o,mapper):
        return tink_core__Outcome_OutcomeMapper_Impl_.apply(mapper,o)

    @staticmethod
    def swap(outcome,v):
        tmp = outcome.index
        if (tmp == 0):
            return tink_core_Outcome.Success(v)
        elif (tmp == 1):
            return tink_core_Outcome.Failure(outcome.params[0])
        else:
            pass

    @staticmethod
    def attempt(f,report):
        try:
            return tink_core_Outcome.Success(f())
        except Exception as _hx_e:
            _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
            e = _hx_e1
            return tink_core_Outcome.Failure(report(e))

    @staticmethod
    def flatten(o):
        tmp = o.index
        if (tmp == 0):
            tmp1 = o.params[0].index
            if (tmp1 == 0):
                return tink_core_Outcome.Success(o.params[0].params[0])
            elif (tmp1 == 1):
                return tink_core_Outcome.Failure(o.params[0].params[0])
            else:
                pass
        elif (tmp == 1):
            return tink_core_Outcome.Failure(o.params[0])
        else:
            pass
tink_core_OutcomeTools._hx_class = tink_core_OutcomeTools
_hx_classes["tink.core.OutcomeTools"] = tink_core_OutcomeTools


class tink_core__Outcome_OutcomeMapper_Impl_:
    _hx_class_name = "tink.core._Outcome.OutcomeMapper_Impl_"
    __slots__ = ()
    _hx_statics = ["_new", "apply", "withSameError", "withEitherError"]

    @staticmethod
    def _new(f):
        return _hx_AnonObject({'f': f})

    @staticmethod
    def apply(this1,o):
        return this1.f(o)

    @staticmethod
    def withSameError(f):
        def _hx_local_1():
            def _hx_local_0(o):
                tmp = o.index
                if (tmp == 0):
                    return f(o.params[0])
                elif (tmp == 1):
                    return tink_core_Outcome.Failure(o.params[0])
                else:
                    pass
            return tink_core__Outcome_OutcomeMapper_Impl_._new(_hx_local_0)
        return _hx_local_1()

    @staticmethod
    def withEitherError(f):
        def _hx_local_1():
            def _hx_local_0(o):
                tmp = o.index
                if (tmp == 0):
                    _g = f(o.params[0])
                    tmp1 = _g.index
                    if (tmp1 == 0):
                        return tink_core_Outcome.Success(_g.params[0])
                    elif (tmp1 == 1):
                        return tink_core_Outcome.Failure(haxe_ds_Either.Right(_g.params[0]))
                    else:
                        pass
                elif (tmp == 1):
                    return tink_core_Outcome.Failure(haxe_ds_Either.Left(o.params[0]))
                else:
                    pass
            return tink_core__Outcome_OutcomeMapper_Impl_._new(_hx_local_0)
        return _hx_local_1()
tink_core__Outcome_OutcomeMapper_Impl_._hx_class = tink_core__Outcome_OutcomeMapper_Impl_
_hx_classes["tink.core._Outcome.OutcomeMapper_Impl_"] = tink_core__Outcome_OutcomeMapper_Impl_


class tink_core__Pair_Pair_Impl_:
    _hx_class_name = "tink.core._Pair.Pair_Impl_"
    __slots__ = ()
    _hx_statics = ["_new", "get_a", "get_b", "toBool", "isNil", "nil"]
    a = None
    b = None

    @staticmethod
    def _new(a,b):
        return tink_core_MPair(a,b)

    @staticmethod
    def get_a(this1):
        return this1.a

    @staticmethod
    def get_b(this1):
        return this1.b

    @staticmethod
    def toBool(this1):
        return (this1 is not None)

    @staticmethod
    def isNil(this1):
        return (this1 is None)

    @staticmethod
    def nil():
        return None
tink_core__Pair_Pair_Impl_._hx_class = tink_core__Pair_Pair_Impl_
_hx_classes["tink.core._Pair.Pair_Impl_"] = tink_core__Pair_Pair_Impl_


class tink_core_MPair:
    _hx_class_name = "tink.core.MPair"
    __slots__ = ("a", "b")
    _hx_fields = ["a", "b"]

    def __init__(self,a,b):
        self.a = a
        self.b = b

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.a = None
        _hx_o.b = None
tink_core_MPair._hx_class = tink_core_MPair
_hx_classes["tink.core.MPair"] = tink_core_MPair


class tink_core__Promise_Promise_Impl_:
    _hx_class_name = "tink.core._Promise.Promise_Impl_"
    __slots__ = ()
    _hx_statics = ["NULL", "NOISE", "NEVER", "_new", "eager", "map", "flatMap", "tryRecover", "recover", "mapError", "handle", "noise", "isSuccess", "next", "swap", "swapError", "merge", "and", "iterate", "retry", "ofSpecific", "ofFuture", "ofOutcome", "ofError", "ofData", "lazy", "inParallel", "inSequence", "cache", "lift", "trigger"]

    @staticmethod
    def _new(f,lazy = False):
        if (lazy is None):
            lazy = False
        def _hx_local_3():
            def _hx_local_2(cb):
                def _hx_local_0(v):
                    cb(tink_core_Outcome.Success(v))
                def _hx_local_1(e):
                    cb(tink_core_Outcome.Failure(e))
                f(_hx_local_0,_hx_local_1)
            return tink_core__Future_Future_Impl_.make(_hx_local_2,lazy)
        return _hx_local_3()

    @staticmethod
    def eager(this1):
        return this1.eager()

    @staticmethod
    def map(this1,f):
        return this1.map(f).gather()

    @staticmethod
    def flatMap(this1,f):
        return this1.flatMap(f).gather()

    @staticmethod
    def tryRecover(this1,f):
        def _hx_local_1():
            def _hx_local_0(o):
                ret = o.index
                if (ret == 0):
                    return tink_core__Future_SyncFuture(tink_core__Lazy_LazyConst(o))
                elif (ret == 1):
                    return f(o.params[0])
                else:
                    pass
            return this1.flatMap(_hx_local_0).gather()
        return _hx_local_1()

    @staticmethod
    def recover(this1,f):
        def _hx_local_1():
            def _hx_local_0(o):
                ret = o.index
                if (ret == 0):
                    return tink_core__Future_SyncFuture(tink_core__Lazy_LazyConst(o.params[0]))
                elif (ret == 1):
                    return f(o.params[0])
                else:
                    pass
            return this1.flatMap(_hx_local_0).gather()
        return _hx_local_1()

    @staticmethod
    def mapError(this1,f):
        def _hx_local_1():
            def _hx_local_0(o):
                ret = o.index
                if (ret == 0):
                    return o
                elif (ret == 1):
                    return tink_core_Outcome.Failure(f(o.params[0]))
                else:
                    pass
            return this1.map(_hx_local_0).gather()
        return _hx_local_1()

    @staticmethod
    def handle(this1,cb):
        return this1.handle(cb)

    @staticmethod
    def noise(this1):
        def _hx_local_1():
            def _hx_local_0(v):
                return tink_core__Future_SyncFuture(tink_core__Lazy_LazyConst(tink_core_Outcome.Success(tink_core_Noise.Noise)))
            return tink_core__Promise_Promise_Impl_.next(this1,_hx_local_0)
        return _hx_local_1()

    @staticmethod
    def isSuccess(this1):
        def _hx_local_1():
            def _hx_local_0(o):
                return tink_core_OutcomeTools.isSuccess(o)
            return this1.map(_hx_local_0).gather()
        return _hx_local_1()

    @staticmethod
    def next(this1,f,gather = True):
        if (gather is None):
            gather = True
        def _hx_local_0(o):
            ret1 = o.index
            if (ret1 == 0):
                return f(o.params[0])
            elif (ret1 == 1):
                return tink_core__Future_SyncFuture(tink_core__Lazy_LazyConst(tink_core_Outcome.Failure(o.params[0])))
            else:
                pass
        ret = this1.flatMap(_hx_local_0)
        if gather:
            return ret.gather()
        else:
            return ret

    @staticmethod
    def swap(this1,v):
        def _hx_local_1():
            def _hx_local_0(_):
                return v
            return tink_core__Future_Future_Impl_._tryMap(this1,_hx_local_0)
        return _hx_local_1()

    @staticmethod
    def swapError(this1,e):
        def _hx_local_1():
            def _hx_local_0(_):
                return e
            return tink_core__Promise_Promise_Impl_.mapError(this1,_hx_local_0)
        return _hx_local_1()

    @staticmethod
    def merge(this1,other,merger,gather = True):
        if (gather is None):
            gather = True
        def _hx_local_3():
            def _hx_local_2(t):
                def _hx_local_1():
                    def _hx_local_0(a):
                        return merger(t,a)
                    return tink_core__Promise_Promise_Impl_.next(other,_hx_local_0,False)
                return _hx_local_1()
            return tink_core__Promise_Promise_Impl_.next(this1,_hx_local_2,gather)
        return _hx_local_3()

    @staticmethod
    def _hx_and(a,b):
        def _hx_local_1():
            def _hx_local_0(a1,b1):
                return tink_core__Future_SyncFuture(tink_core__Lazy_LazyConst(tink_core_Outcome.Success(tink_core_MPair(a1,b1))))
            return tink_core__Promise_Promise_Impl_.merge(a,b,_hx_local_0)
        return _hx_local_1()

    @staticmethod
    def iterate(promises,_hx_yield,_hx_finally,lazy = None):
        def _hx_local_4():
            def _hx_local_3(cb):
                _hx_iter = HxOverrides.iterator(promises)
                next = None
                def _hx_local_2():
                    if _hx_iter.hasNext():
                        def _hx_local_1(o):
                            next1 = o.index
                            if (next1 == 0):
                                def _hx_local_0(o1):
                                    next2 = o1.index
                                    if (next2 == 0):
                                        next3 = o1.params[0].index
                                        if (next3 == 0):
                                            cb(tink_core_Outcome.Success(o1.params[0].params[0]))
                                        elif (next3 == 1):
                                            next()
                                        else:
                                            pass
                                    elif (next2 == 1):
                                        cb(tink_core_Outcome.Failure(o1.params[0]))
                                    else:
                                        pass
                                _hx_yield(o.params[0]).handle(_hx_local_0)
                            elif (next1 == 1):
                                cb(tink_core_Outcome.Failure(o.params[0]))
                            else:
                                pass
                        _hx_iter.next().handle(_hx_local_1)
                    else:
                        _hx_finally.handle(cb)
                next = _hx_local_2
                next()
            return tink_core__Future_Future_Impl_.make(_hx_local_3,lazy)
        return _hx_local_4()

    @staticmethod
    def retry(gen,next):
        def _hx_local_0():
            return (python_lib_Timeit.default_timer() * 1000)
        stamp = _hx_local_0
        start = stamp()
        attempt = None
        def _hx_local_6(count):
            def _hx_local_3(error):
                f1 = (stamp() - start)
                def _hx_local_2():
                    def _hx_local_1(_):
                        return attempt((count + 1))
                    return tink_core__Promise_Promise_Impl_.next(next(_hx_AnonObject({'attempt': count, 'error': error, 'elapsed': f1})),_hx_local_1)
                return _hx_local_2()
            f = _hx_local_3
            def _hx_local_5():
                def _hx_local_4(o):
                    ret = o.index
                    if (ret == 0):
                        return tink_core__Future_SyncFuture(tink_core__Lazy_LazyConst(o))
                    elif (ret == 1):
                        return f(o.params[0])
                    else:
                        pass
                return gen().flatMap(_hx_local_4).gather()
            return _hx_local_5()
        attempt = _hx_local_6
        return attempt(1)

    @staticmethod
    def ofSpecific(s):
        return s

    @staticmethod
    def ofFuture(f):
        return f.map(tink_core_Outcome.Success).gather()

    @staticmethod
    def ofOutcome(o):
        return tink_core__Future_SyncFuture(tink_core__Lazy_LazyConst(o))

    @staticmethod
    def ofError(e):
        return tink_core__Future_SyncFuture(tink_core__Lazy_LazyConst(tink_core_Outcome.Failure(e)))

    @staticmethod
    def ofData(d):
        return tink_core__Future_SyncFuture(tink_core__Lazy_LazyConst(tink_core_Outcome.Success(d)))

    @staticmethod
    def lazy(p):
        def _hx_local_1():
            def _hx_local_0(cb):
                p.get().handle(cb)
            return tink_core__Future_Future_Impl_.make(_hx_local_0,True)
        return _hx_local_1()

    @staticmethod
    def inParallel(a,concurrency = None,lazy = None):
        if (len(a) == 0):
            return tink_core__Future_SyncFuture(tink_core__Lazy_LazyConst(tink_core_Outcome.Success([])))
        else:
            def _hx_local_10():
                def _hx_local_9(cb):
                    nonlocal concurrency
                    result = []
                    pending = len(a)
                    links = None
                    linkArray = []
                    sync = False
                    i = 0
                    _hx_iter = python_HaxeIterator(a.__iter__())
                    next = None
                    def _hx_local_0(o):
                        nonlocal sync
                        if (links is None):
                            sync = True
                        elif (links is not None):
                            links.cancel()
                        cb(o)
                    done = _hx_local_0
                    def _hx_local_1(e):
                        nonlocal pending
                        pending = 0
                        done(tink_core_Outcome.Failure(e))
                    fail = _hx_local_1
                    def _hx_local_4(index,value):
                        python_internal_ArrayImpl._set(result, index, value)
                        def _hx_local_3():
                            nonlocal pending
                            pending = (pending - 1)
                            return pending
                        if ((_hx_local_3()) == 0):
                            done(tink_core_Outcome.Success(result))
                        elif (_hx_iter.hasNext() and ((pending > 0))):
                            next()
                    _hx_set = _hx_local_4
                    def _hx_local_7():
                        nonlocal i
                        i = (i + 1)
                        index1 = (i - 1)
                        def _hx_local_6(o1):
                            x1 = o1.index
                            if (x1 == 0):
                                _hx_set(index1,o1.params[0])
                            elif (x1 == 1):
                                fail(o1.params[0])
                            else:
                                pass
                        x = _hx_iter.next().handle(_hx_local_6)
                        linkArray.append(x)
                    next = _hx_local_7
                    while True:
                        tmp = None
                        if (_hx_iter.hasNext() and ((pending > 0))):
                            if (concurrency is not None):
                                concurrency = (concurrency - 1)
                                tmp = ((concurrency + 1) > 0)
                            else:
                                tmp = True
                        else:
                            tmp = False
                        if (not tmp):
                            break
                        next()
                    links = tink_core__Callback_CallbackLink_Impl_.fromMany(linkArray)
                    if sync:
                        if (links is not None):
                            links.cancel()
                return tink_core__Future_Future_Impl_.make(_hx_local_9,lazy)
            return _hx_local_10()

    @staticmethod
    def inSequence(a):
        loop = None
        def _hx_local_4(index):
            if (index == len(a)):
                return tink_core__Future_SyncFuture(tink_core__Lazy_LazyConst(tink_core_Outcome.Success([])))
            else:
                def _hx_local_3():
                    def _hx_local_2(head):
                        def _hx_local_1():
                            def _hx_local_0(tail):
                                return tink_core__Future_SyncFuture(tink_core__Lazy_LazyConst(tink_core_Outcome.Success(([head] + tail))))
                            return tink_core__Promise_Promise_Impl_.next(loop((index + 1)),_hx_local_0)
                        return _hx_local_1()
                    return tink_core__Promise_Promise_Impl_.next((a[index] if index >= 0 and index < len(a) else None),_hx_local_2)
                return _hx_local_3()
        loop = _hx_local_4
        return loop(0)

    @staticmethod
    def cache(gen):
        p = None
        def _hx_local_0():
            nonlocal p
            ret = p
            if (ret is None):
                sync = False
                def _hx_local_2(o):
                    def _hx_local_1(_):
                        nonlocal p
                        nonlocal sync
                        sync = True
                        p = None
                    o.b.handle(_hx_local_1)
                    return tink_core__Future_SyncFuture(tink_core__Lazy_LazyConst(tink_core_Outcome.Success(o.a)))
                ret = tink_core__Promise_Promise_Impl_.next(gen(),_hx_local_2)
                if (not sync):
                    p = ret
            def _hx_local_4():
                def _hx_local_3(o1):
                    nonlocal p
                    if (not tink_core_OutcomeTools.isSuccess(o1)):
                        p = None
                    return o1
                return ret.map(_hx_local_3).gather()
            return _hx_local_4()
        return _hx_local_0

    @staticmethod
    def lift(p):
        return p

    @staticmethod
    def trigger():
        return tink_core_FutureTrigger()
tink_core__Promise_Promise_Impl_._hx_class = tink_core__Promise_Promise_Impl_
_hx_classes["tink.core._Promise.Promise_Impl_"] = tink_core__Promise_Promise_Impl_


class tink_core__Promise_Next_Impl_:
    _hx_class_name = "tink.core._Promise.Next_Impl_"
    __slots__ = ()
    _hx_statics = ["ofSafe", "ofSync", "ofSafeSync", "_chain"]

    @staticmethod
    def ofSafe(f):
        def _hx_local_0(x):
            return tink_core__Future_SyncFuture(tink_core__Lazy_LazyConst(f(x)))
        return _hx_local_0

    @staticmethod
    def ofSync(f):
        def _hx_local_0(x):
            return f(x).map(tink_core_Outcome.Success).gather()
        return _hx_local_0

    @staticmethod
    def ofSafeSync(f):
        def _hx_local_0(x):
            return tink_core__Future_SyncFuture(tink_core__Lazy_LazyConst(tink_core_Outcome.Success(f(x))))
        return _hx_local_0

    @staticmethod
    def _chain(a,b):
        def _hx_local_0(v):
            return tink_core__Promise_Promise_Impl_.next(a(v),b)
        return _hx_local_0
tink_core__Promise_Next_Impl_._hx_class = tink_core__Promise_Next_Impl_
_hx_classes["tink.core._Promise.Next_Impl_"] = tink_core__Promise_Next_Impl_


class tink_core__Promise_Recover_Impl_:
    _hx_class_name = "tink.core._Promise.Recover_Impl_"
    __slots__ = ()
    _hx_statics = ["ofSync"]

    @staticmethod
    def ofSync(f):
        def _hx_local_0(e):
            return tink_core__Future_SyncFuture(tink_core__Lazy_LazyConst(f(e)))
        return _hx_local_0
tink_core__Promise_Recover_Impl_._hx_class = tink_core__Promise_Recover_Impl_
_hx_classes["tink.core._Promise.Recover_Impl_"] = tink_core__Promise_Recover_Impl_


class tink_core__Promise_Combiner_Impl_:
    _hx_class_name = "tink.core._Promise.Combiner_Impl_"
    __slots__ = ()
    _hx_statics = ["ofSafe", "ofSync", "ofSafeSync"]

    @staticmethod
    def ofSafe(f):
        def _hx_local_0(x1,x2):
            return tink_core__Future_SyncFuture(tink_core__Lazy_LazyConst(f(x1,x2)))
        return _hx_local_0

    @staticmethod
    def ofSync(f):
        def _hx_local_0(x1,x2):
            return f(x1,x2).map(tink_core_Outcome.Success).gather()
        return _hx_local_0

    @staticmethod
    def ofSafeSync(f):
        def _hx_local_0(x1,x2):
            return tink_core__Future_SyncFuture(tink_core__Lazy_LazyConst(tink_core_Outcome.Success(f(x1,x2))))
        return _hx_local_0
tink_core__Promise_Combiner_Impl_._hx_class = tink_core__Promise_Combiner_Impl_
_hx_classes["tink.core._Promise.Combiner_Impl_"] = tink_core__Promise_Combiner_Impl_


class tink_core__Promise_PromiseTrigger_Impl_:
    _hx_class_name = "tink.core._Promise.PromiseTrigger_Impl_"
    __slots__ = ()
    _hx_statics = ["_new", "resolve", "reject", "asPromise"]

    @staticmethod
    def _new():
        return tink_core_FutureTrigger()

    @staticmethod
    def resolve(this1,v):
        return this1.trigger(tink_core_Outcome.Success(v))

    @staticmethod
    def reject(this1,e):
        return this1.trigger(tink_core_Outcome.Failure(e))

    @staticmethod
    def asPromise(this1):
        return this1
tink_core__Promise_PromiseTrigger_Impl_._hx_class = tink_core__Promise_PromiseTrigger_Impl_
_hx_classes["tink.core._Promise.PromiseTrigger_Impl_"] = tink_core__Promise_PromiseTrigger_Impl_


class tink_core__Ref_Ref_Impl_:
    _hx_class_name = "tink.core._Ref.Ref_Impl_"
    __slots__ = ()
    _hx_statics = ["_new", "get_value", "set_value", "toString", "to"]
    value = None

    @staticmethod
    def _new():
        return [None]*1

    @staticmethod
    def get_value(this1):
        return this1[0]

    @staticmethod
    def set_value(this1,param):
        this1[0] = param
        return param

    @staticmethod
    def toString(this1):
        return (("@[" + Std.string(this1[0])) + "]")

    @staticmethod
    def to(v):
        ret = [None]*1
        ret[0] = v
        return ret
tink_core__Ref_Ref_Impl_._hx_class = tink_core__Ref_Ref_Impl_
_hx_classes["tink.core._Ref.Ref_Impl_"] = tink_core__Ref_Ref_Impl_


class tink_core__Signal_SimpleSignal:
    _hx_class_name = "tink.core._Signal.SimpleSignal"
    __slots__ = ("f",)
    _hx_fields = ["f"]
    _hx_methods = ["handle"]
    _hx_interfaces = [tink_core_SignalObject]

    def __init__(self,f):
        self.f = f

    def handle(self,cb):
        return self.f(cb)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.f = None
tink_core__Signal_SimpleSignal._hx_class = tink_core__Signal_SimpleSignal
_hx_classes["tink.core._Signal.SimpleSignal"] = tink_core__Signal_SimpleSignal


class tink_core__Signal_Suspendable:
    _hx_class_name = "tink.core._Signal.Suspendable"
    __slots__ = ("trigger", "activate", "suspend", "check", "killed")
    _hx_fields = ["trigger", "activate", "suspend", "check", "killed"]
    _hx_methods = ["kill", "handle"]
    _hx_interfaces = [tink_core_SignalObject]

    def __init__(self,activate):
        self.check = None
        self.suspend = None
        self.killed = False
        self.trigger = tink_core_SignalTrigger()
        self.activate = activate

    def kill(self):
        if (not self.killed):
            self.killed = True
            self.trigger = None

    def handle(self,cb):
        _gthis = self
        if self.killed:
            return None
        if (len(self.trigger.handlers) == 0):
            self.suspend = self.activate(self.trigger.trigger)
        def _hx_local_1():
            def _hx_local_0():
                if (len(_gthis.trigger.handlers) == 0):
                    _gthis.suspend()
                    _gthis.suspend = None
            return tink_core__Callback_LinkPair(tink_core__Callback_CallbackList_Impl_.add(self.trigger.handlers,cb),tink_core__Callback_SimpleLink(_hx_local_0))
        return _hx_local_1()

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.trigger = None
        _hx_o.activate = None
        _hx_o.suspend = None
        _hx_o.check = None
        _hx_o.killed = None
tink_core__Signal_Suspendable._hx_class = tink_core__Signal_Suspendable
_hx_classes["tink.core._Signal.Suspendable"] = tink_core__Signal_Suspendable


class tink_runloop_TaskObject:
    _hx_class_name = "tink.runloop.TaskObject"
    __slots__ = ()
    _hx_methods = ["get_state", "get_recurring", "cancel", "perform"]
tink_runloop_TaskObject._hx_class = tink_runloop_TaskObject
_hx_classes["tink.runloop.TaskObject"] = tink_runloop_TaskObject


class tink_runloop__Task_Noop:
    _hx_class_name = "tink.runloop._Task.Noop"
    __slots__ = ()
    _hx_methods = ["get_recurring", "get_state", "cancel", "perform"]
    _hx_interfaces = [tink_runloop_TaskObject]

    def __init__(self):
        pass

    def get_recurring(self):
        return False

    def get_state(self):
        return tink_runloop_TaskState.Performed

    def cancel(self):
        pass

    def perform(self):
        pass

    @staticmethod
    def _hx_empty_init(_hx_o):        pass
tink_runloop__Task_Noop._hx_class = tink_runloop__Task_Noop
_hx_classes["tink.runloop._Task.Noop"] = tink_runloop__Task_Noop


class tink_runloop__Task_Task_Impl_:
    _hx_class_name = "tink.runloop._Task.Task_Impl_"
    __slots__ = ()
    _hx_statics = ["ofFunction", "repeat", "NOOP"]

    @staticmethod
    def ofFunction(f):
        return tink_runloop_FunctionTask(f)

    @staticmethod
    def repeat(f):
        return tink_runloop_RepeatableFunctionTask(f)
tink_runloop__Task_Task_Impl_._hx_class = tink_runloop__Task_Task_Impl_
_hx_classes["tink.runloop._Task.Task_Impl_"] = tink_runloop__Task_Task_Impl_

class tink_runloop_TaskRepeat(Enum):
    __slots__ = ()
    _hx_class_name = "tink.runloop.TaskRepeat"
    _hx_constructs = ["Continue", "Done"]
tink_runloop_TaskRepeat.Continue = tink_runloop_TaskRepeat("Continue", 0, list())
tink_runloop_TaskRepeat.Done = tink_runloop_TaskRepeat("Done", 1, list())
tink_runloop_TaskRepeat._hx_class = tink_runloop_TaskRepeat
_hx_classes["tink.runloop.TaskRepeat"] = tink_runloop_TaskRepeat

class tink_runloop_TaskState(Enum):
    __slots__ = ()
    _hx_class_name = "tink.runloop.TaskState"
    _hx_constructs = ["Pending", "Canceled", "Busy", "Performed"]
tink_runloop_TaskState.Pending = tink_runloop_TaskState("Pending", 0, list())
tink_runloop_TaskState.Canceled = tink_runloop_TaskState("Canceled", 1, list())
tink_runloop_TaskState.Busy = tink_runloop_TaskState("Busy", 2, list())
tink_runloop_TaskState.Performed = tink_runloop_TaskState("Performed", 3, list())
tink_runloop_TaskState._hx_class = tink_runloop_TaskState
_hx_classes["tink.runloop.TaskState"] = tink_runloop_TaskState


class tink_runloop_TaskBase:
    _hx_class_name = "tink.runloop.TaskBase"
    __slots__ = ("m", "recurring", "state")
    _hx_fields = ["m"]
    _hx_methods = ["get_recurring", "get_state", "cancel", "exec", "perform", "doCleanup", "doCancel", "doPerform"]
    _hx_interfaces = [tink_runloop_TaskObject]

    def __init__(self,recurring = False):
        if (recurring is None):
            recurring = False
        self.recurring = recurring
        self.state = tink_runloop_TaskState.Pending
        self.m = False

    def get_recurring(self):
        return self.recurring

    def get_state(self):
        return self.state

    def cancel(self):
        _gthis = self
        def _hx_local_0():
            _gthis.state = tink_runloop_TaskState.Canceled
            _gthis.doCleanup()
        self._hx_exec(_hx_local_0)

    def _hx_exec(self,f):
        if (self.state == tink_runloop_TaskState.Pending):
            try:
                f()
            except Exception as _hx_e:
                _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                e = _hx_e1
                raise _HxException(e)

    def perform(self):
        _gthis = self
        def _hx_local_0():
            _gthis.state = tink_runloop_TaskState.Busy
            _gthis.doPerform()
            if _gthis.recurring:
                _gthis.state = tink_runloop_TaskState.Pending
            else:
                _gthis.state = tink_runloop_TaskState.Performed
                _gthis.doCleanup()
        self._hx_exec(_hx_local_0)

    def doCleanup(self):
        pass

    def doCancel(self):
        pass

    def doPerform(self):
        pass

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.m = None
tink_runloop_TaskBase._hx_class = tink_runloop_TaskBase
_hx_classes["tink.runloop.TaskBase"] = tink_runloop_TaskBase


class tink_runloop_FunctionTask(tink_runloop_TaskBase):
    _hx_class_name = "tink.runloop.FunctionTask"
    __slots__ = ("f",)
    _hx_fields = ["f"]
    _hx_methods = ["doCleanup", "doPerform"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = tink_runloop_TaskBase


    def __init__(self,f):
        self.f = None
        super().__init__()
        self.f = f

    def doCleanup(self):
        self.f = None

    def doPerform(self):
        self.f()

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.f = None
tink_runloop_FunctionTask._hx_class = tink_runloop_FunctionTask
_hx_classes["tink.runloop.FunctionTask"] = tink_runloop_FunctionTask


class tink_runloop_RepeatableFunctionTask(tink_runloop_TaskBase):
    _hx_class_name = "tink.runloop.RepeatableFunctionTask"
    __slots__ = ("f",)
    _hx_fields = ["f"]
    _hx_methods = ["doCleanup", "doPerform"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = tink_runloop_TaskBase


    def __init__(self,f):
        self.f = None
        super().__init__()
        self.f = f

    def doCleanup(self):
        self.f = None

    def doPerform(self):
        self.recurring = (self.f() == tink_runloop_TaskRepeat.Continue)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.f = None
tink_runloop_RepeatableFunctionTask._hx_class = tink_runloop_RepeatableFunctionTask
_hx_classes["tink.runloop.RepeatableFunctionTask"] = tink_runloop_RepeatableFunctionTask

class tink_runloop_WorkResult(Enum):
    __slots__ = ()
    _hx_class_name = "tink.runloop.WorkResult"
    _hx_constructs = ["Progressed", "Waiting", "Idle", "Done", "Aborted", "WrongThread"]

    @staticmethod
    def Waiting(seconds):
        return tink_runloop_WorkResult("Waiting", 1, [seconds])
tink_runloop_WorkResult.Progressed = tink_runloop_WorkResult("Progressed", 0, list())
tink_runloop_WorkResult.Idle = tink_runloop_WorkResult("Idle", 2, list())
tink_runloop_WorkResult.Done = tink_runloop_WorkResult("Done", 3, list())
tink_runloop_WorkResult.Aborted = tink_runloop_WorkResult("Aborted", 4, list())
tink_runloop_WorkResult.WrongThread = tink_runloop_WorkResult("WrongThread", 5, list())
tink_runloop_WorkResult._hx_class = tink_runloop_WorkResult
_hx_classes["tink.runloop.WorkResult"] = tink_runloop_WorkResult


class tink_streams__IdealStream_IdealStream_Impl_:
    _hx_class_name = "tink.streams._IdealStream.IdealStream_Impl_"
    __slots__ = ()
    _hx_statics = ["promiseOfIdealStream", "promiseOfStreamNoise", "collect"]

    @staticmethod
    def promiseOfIdealStream(p):
        return tink_streams__Stream_Stream_Impl_.promise(tink_core__Promise_Promise_Impl_.ofSpecific(p))

    @staticmethod
    def promiseOfStreamNoise(p):
        return tink_streams__Stream_Stream_Impl_.promise(p)

    @staticmethod
    def collect(this1):
        buf = []
        def _hx_local_2():
            def _hx_local_1(x):
                buf.append(x)
                return tink_core__Future_SyncFuture(tink_core__Lazy_LazyConst(tink_streams_Handled.Resume))
            def _hx_local_0(c):
                return buf
            return this1.forEach(tink_streams__Stream_Handler_Impl_.ofSafe(_hx_local_1)).map(_hx_local_0).gather()
        return _hx_local_2()
tink_streams__IdealStream_IdealStream_Impl_._hx_class = tink_streams__IdealStream_IdealStream_Impl_
_hx_classes["tink.streams._IdealStream.IdealStream_Impl_"] = tink_streams__IdealStream_IdealStream_Impl_


class tink_streams_StreamObject:
    _hx_class_name = "tink.streams.StreamObject"
    __slots__ = ()
    _hx_methods = ["get_depleted", "next", "regroup", "map", "filter", "retain", "idealize", "append", "prepend", "blend", "decompose", "forEach", "reduce"]
tink_streams_StreamObject._hx_class = tink_streams_StreamObject
_hx_classes["tink.streams.StreamObject"] = tink_streams_StreamObject


class tink_streams_StreamBase:
    _hx_class_name = "tink.streams.StreamBase"
    __slots__ = ("retainCount",)
    _hx_fields = ["retainCount"]
    _hx_methods = ["get_depleted", "retain", "next", "regroup", "map", "filter", "destroy", "append", "prepend", "blend", "decompose", "idealize", "reduce", "forEach"]
    _hx_interfaces = [tink_streams_StreamObject]

    def __init__(self):
        self.retainCount = 0

    def get_depleted(self):
        return False

    def retain(self):
        _gthis = self
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.retainCount
        _hx_local_0.retainCount = (_hx_local_1 + 1)
        _hx_local_1
        retained = True
        def _hx_local_2():
            nonlocal retained
            if retained:
                retained = False
                _gthis.retainCount = (_gthis.retainCount - 1)
        return _hx_local_2

    def next(self):
        raise _HxException("not implemented")

    def regroup(self,f):
        return tink_streams__Stream_RegroupStream(self,f)

    def map(self,f):
        return self.regroup(f)

    def filter(self,f):
        return self.regroup(f)

    def destroy(self):
        pass

    def append(self,other):
        if self.get_depleted():
            return other
        else:
            return tink_streams__Stream_CompoundStream.of([self, other])

    def prepend(self,other):
        if self.get_depleted():
            return other
        else:
            return tink_streams__Stream_CompoundStream.of([other, self])

    def blend(self,other):
        if self.get_depleted():
            return other
        else:
            return tink_streams_BlendStream(self,other)

    def decompose(self,into):
        if (not self.get_depleted()):
            into.append(self)

    def idealize(self,rescue):
        if self.get_depleted():
            return tink_streams_Empty.inst
        else:
            return tink_streams_IdealizeStream(self,rescue)

    def reduce(self,initial,reducer):
        _gthis = self
        def _hx_local_5():
            def _hx_local_4(cb):
                def _hx_local_3(item):
                    def _hx_local_2():
                        def _hx_local_1(o):
                            nonlocal initial
                            ret = o.index
                            if (ret == 0):
                                initial = o.params[0]
                                return tink_streams_Handled.Resume
                            elif (ret == 1):
                                return tink_streams_Handled.Clog(o.params[0])
                            else:
                                pass
                        return reducer(initial,item).map(_hx_local_1).gather()
                    return _hx_local_2()
                def _hx_local_0(c):
                    tmp = c.index
                    if (tmp == 0):
                        raise _HxException("assert")
                    elif (tmp == 1):
                        cb(tink_streams_Reduction.Crashed(c.params[0],c.params[1]))
                    elif (tmp == 2):
                        cb(tink_streams_Reduction.Failed(c.params[0]))
                    elif (tmp == 3):
                        cb(tink_streams_Reduction.Reduced(initial))
                    else:
                        pass
                _gthis.forEach(tink_streams__Stream_Handler_Impl_.ofUnknown(_hx_local_3)).handle(_hx_local_0)
            return tink_core__Future_Future_Impl_.make(_hx_local_4,True)
        return _hx_local_5()

    def forEach(self,handler):
        raise _HxException("not implemented")

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.retainCount = None
tink_streams_StreamBase._hx_class = tink_streams_StreamBase
_hx_classes["tink.streams.StreamBase"] = tink_streams_StreamBase


class tink_streams_IdealStreamBase(tink_streams_StreamBase):
    _hx_class_name = "tink.streams.IdealStreamBase"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = ["idealize"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = tink_streams_StreamBase


    def __init__(self):
        super().__init__()

    def idealize(self,rescue):
        return self

    @staticmethod
    def _hx_empty_init(_hx_o):        pass
tink_streams_IdealStreamBase._hx_class = tink_streams_IdealStreamBase
_hx_classes["tink.streams.IdealStreamBase"] = tink_streams_IdealStreamBase


class tink_streams__RealStream_RealStream_Impl_:
    _hx_class_name = "tink.streams._RealStream.RealStream_Impl_"
    __slots__ = ()
    _hx_statics = ["promiseOfIdealStream", "promiseOfStreamNoise", "promiseOfRealStream", "promiseOfStreamError", "collect"]

    @staticmethod
    def promiseOfIdealStream(p):
        return tink_streams__Stream_Stream_Impl_.promise(tink_core__Promise_Promise_Impl_.ofSpecific(p))

    @staticmethod
    def promiseOfStreamNoise(p):
        return tink_streams__Stream_Stream_Impl_.promise(p)

    @staticmethod
    def promiseOfRealStream(p):
        return tink_streams__Stream_Stream_Impl_.promise(tink_core__Promise_Promise_Impl_.ofSpecific(p))

    @staticmethod
    def promiseOfStreamError(p):
        return tink_streams__Stream_Stream_Impl_.promise(p)

    @staticmethod
    def collect(this1):
        buf = []
        def _hx_local_2():
            def _hx_local_1(x):
                buf.append(x)
                return tink_core__Future_SyncFuture(tink_core__Lazy_LazyConst(tink_streams_Handled.Resume))
            def _hx_local_0(c):
                ret = c.index
                if (ret == 0):
                    raise _HxException("unreachable")
                elif (ret == 2):
                    return tink_core_Outcome.Failure(c.params[0])
                elif (ret == 3):
                    return tink_core_Outcome.Success(buf)
                else:
                    pass
            return this1.forEach(tink_streams__Stream_Handler_Impl_.ofSafe(_hx_local_1)).map(_hx_local_0).gather()
        return _hx_local_2()
tink_streams__RealStream_RealStream_Impl_._hx_class = tink_streams__RealStream_RealStream_Impl_
_hx_classes["tink.streams._RealStream.RealStream_Impl_"] = tink_streams__RealStream_RealStream_Impl_


class tink_streams__Stream_Stream_Impl_:
    _hx_class_name = "tink.streams._Stream.Stream_Impl_"
    __slots__ = ()
    _hx_statics = ["get_depleted", "dirty", "single", "ofIterator", "flatten", "promiseIdeal", "promiseReal", "promise", "ofError"]
    depleted = None

    @staticmethod
    def get_depleted(this1):
        return this1.get_depleted()

    @staticmethod
    def dirty(this1):
        return this1

    @staticmethod
    def single(i):
        return tink_streams_Single(tink_core__Lazy_LazyConst(i))

    @staticmethod
    def ofIterator(i):
        next = None
        def _hx_local_0(step):
            step((tink_streams_Step.Link(i.next(),tink_streams_Generator.stream(next)) if (i.hasNext()) else tink_streams_Step.End))
        next = _hx_local_0
        return tink_streams_Generator.stream(next)

    @staticmethod
    def flatten(f):
        return tink_streams_FutureStream(f)

    @staticmethod
    def promiseIdeal(f):
        return tink_streams__Stream_Stream_Impl_.promise(tink_core__Promise_Promise_Impl_.ofSpecific(f))

    @staticmethod
    def promiseReal(f):
        return tink_streams__Stream_Stream_Impl_.promise(tink_core__Promise_Promise_Impl_.ofSpecific(f))

    @staticmethod
    def promise(f):
        def _hx_local_1():
            def _hx_local_0(o):
                ret = o.index
                if (ret == 0):
                    return tink_streams__Stream_Stream_Impl_.dirty(o.params[0])
                elif (ret == 1):
                    return tink_streams__Stream_Stream_Impl_.ofError(o.params[0])
                else:
                    pass
            return tink_streams__Stream_Stream_Impl_.flatten(f.map(_hx_local_0).gather())
        return _hx_local_1()

    @staticmethod
    def ofError(e):
        return tink_streams__Stream_ErrorStream(e)
tink_streams__Stream_Stream_Impl_._hx_class = tink_streams__Stream_Stream_Impl_
_hx_classes["tink.streams._Stream.Stream_Impl_"] = tink_streams__Stream_Stream_Impl_

class tink_streams_RegroupStatus(Enum):
    __slots__ = ()
    _hx_class_name = "tink.streams.RegroupStatus"
    _hx_constructs = ["Flowing", "Errored", "Ended"]

    @staticmethod
    def Errored(e):
        return tink_streams_RegroupStatus("Errored", 1, [e])
tink_streams_RegroupStatus.Flowing = tink_streams_RegroupStatus("Flowing", 0, list())
tink_streams_RegroupStatus.Ended = tink_streams_RegroupStatus("Ended", 2, list())
tink_streams_RegroupStatus._hx_class = tink_streams_RegroupStatus
_hx_classes["tink.streams.RegroupStatus"] = tink_streams_RegroupStatus

class tink_streams_RegroupResult(Enum):
    __slots__ = ()
    _hx_class_name = "tink.streams.RegroupResult"
    _hx_constructs = ["Converted", "Terminated", "Untouched", "Errored"]

    @staticmethod
    def Converted(data):
        return tink_streams_RegroupResult("Converted", 0, [data])

    @staticmethod
    def Terminated(data):
        return tink_streams_RegroupResult("Terminated", 1, [data])

    @staticmethod
    def Errored(e):
        return tink_streams_RegroupResult("Errored", 3, [e])
tink_streams_RegroupResult.Untouched = tink_streams_RegroupResult("Untouched", 2, list())
tink_streams_RegroupResult._hx_class = tink_streams_RegroupResult
_hx_classes["tink.streams.RegroupResult"] = tink_streams_RegroupResult


class tink_streams__Stream_Regrouper_Impl_:
    _hx_class_name = "tink.streams._Stream.Regrouper_Impl_"
    __slots__ = ()
    _hx_statics = ["ofIgnorance", "ofIgnoranceSync", "ofFunc", "ofFuncSync"]

    @staticmethod
    def ofIgnorance(f):
        def _hx_local_1():
            def _hx_local_0(i,_):
                return f(i)
            return _hx_AnonObject({'apply': _hx_local_0})
        return _hx_local_1()

    @staticmethod
    def ofIgnoranceSync(f):
        def _hx_local_1():
            def _hx_local_0(i,_):
                return tink_core__Future_SyncFuture(tink_core__Lazy_LazyConst(f(i)))
            return _hx_AnonObject({'apply': _hx_local_0})
        return _hx_local_1()

    @staticmethod
    def ofFunc(f):
        return _hx_AnonObject({'apply': f})

    @staticmethod
    def ofFuncSync(f):
        def _hx_local_1():
            def _hx_local_0(i,s):
                return tink_core__Future_SyncFuture(tink_core__Lazy_LazyConst(f(i,s)))
            return _hx_AnonObject({'apply': _hx_local_0})
        return _hx_local_1()
tink_streams__Stream_Regrouper_Impl_._hx_class = tink_streams__Stream_Regrouper_Impl_
_hx_classes["tink.streams._Stream.Regrouper_Impl_"] = tink_streams__Stream_Regrouper_Impl_


class tink_streams__Stream_CompoundStream(tink_streams_StreamBase):
    _hx_class_name = "tink.streams._Stream.CompoundStream"
    __slots__ = ("parts",)
    _hx_fields = ["parts"]
    _hx_methods = ["get_depleted", "next", "decompose", "forEach"]
    _hx_statics = ["consumeParts", "of"]
    _hx_interfaces = []
    _hx_super = tink_streams_StreamBase


    def __init__(self,parts):
        self.parts = None
        super().__init__()
        self.parts = parts

    def get_depleted(self):
        _g = len(self.parts)
        if (_g == 0):
            return True
        elif (_g == 1):
            return (self.parts[0] if 0 < len(self.parts) else None).get_depleted()
        else:
            return False

    def next(self):
        _gthis = self
        if (len(self.parts) == 0):
            return tink_core__Future_SyncFuture(tink_core__Lazy_LazyConst(tink_streams_Step.End))
        else:
            def _hx_local_1():
                def _hx_local_0(v):
                    ret = v.index
                    if (ret == 0):
                        copy = list(_gthis.parts)
                        python_internal_ArrayImpl._set(copy, 0, v.params[1])
                        return tink_core__Future_SyncFuture(tink_core__Lazy_LazyConst(tink_streams_Step.Link(v.params[0],tink_streams__Stream_CompoundStream(copy))))
                    elif (ret == 2):
                        if (len(_gthis.parts) > 1):
                            return (_gthis.parts[1] if 1 < len(_gthis.parts) else None).next()
                        else:
                            return tink_core__Future_SyncFuture(tink_core__Lazy_LazyConst(v))
                    else:
                        return tink_core__Future_SyncFuture(tink_core__Lazy_LazyConst(v))
                return (self.parts[0] if 0 < len(self.parts) else None).next().flatMap(_hx_local_0).gather()
            return _hx_local_1()

    def decompose(self,into):
        _g = 0
        _g1 = self.parts
        while (_g < len(_g1)):
            def _hx_local_1():
                nonlocal _g
                _hx_local_0 = _g
                _g = (_g + 1)
                return _hx_local_0
            p = python_internal_ArrayImpl._get(_g1, _hx_local_1())
            p.decompose(into)

    def forEach(self,handler):
        parts = self.parts
        handler1 = handler
        def _hx_local_1():
            def _hx_local_0(cb):
                tink_streams__Stream_CompoundStream.consumeParts(parts,handler1,cb)
            return tink_core__Future_Future_Impl_.make(_hx_local_0)
        return _hx_local_1()

    @staticmethod
    def consumeParts(parts,handler,cb):
        if (len(parts) == 0):
            cb(tink_streams_Conclusion.Depleted)
        else:
            def _hx_local_0(o):
                nonlocal parts
                nonlocal parts
                nonlocal parts
                tmp = o.index
                if (tmp == 0):
                    parts = list(parts)
                    python_internal_ArrayImpl._set(parts, 0, o.params[0])
                    cb(tink_streams_Conclusion.Halted(tink_streams__Stream_CompoundStream(parts)))
                elif (tmp == 1):
                    at = o.params[1]
                    if at.get_depleted():
                        parts = parts[1:None]
                    else:
                        parts = list(parts)
                        python_internal_ArrayImpl._set(parts, 0, at)
                    cb(tink_streams_Conclusion.Clogged(o.params[0],tink_streams__Stream_CompoundStream(parts)))
                elif (tmp == 2):
                    cb(tink_streams_Conclusion.Failed(o.params[0]))
                elif (tmp == 3):
                    tink_streams__Stream_CompoundStream.consumeParts(parts[1:None],handler,cb)
                else:
                    pass
            (parts[0] if 0 < len(parts) else None).forEach(handler).handle(_hx_local_0)

    @staticmethod
    def of(streams):
        ret = []
        _g = 0
        while (_g < len(streams)):
            def _hx_local_1():
                nonlocal _g
                _hx_local_0 = _g
                _g = (_g + 1)
                return _hx_local_0
            s = python_internal_ArrayImpl._get(streams, _hx_local_1())
            s.decompose(ret)
        if (len(ret) == 0):
            return tink_streams_Empty.inst
        else:
            return tink_streams__Stream_CompoundStream(ret)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.parts = None
tink_streams__Stream_CompoundStream._hx_class = tink_streams__Stream_CompoundStream
_hx_classes["tink.streams._Stream.CompoundStream"] = tink_streams__Stream_CompoundStream


class tink_streams__Stream_RegroupStream(tink_streams__Stream_CompoundStream):
    _hx_class_name = "tink.streams._Stream.RegroupStream"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = []
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = tink_streams__Stream_CompoundStream


    def __init__(self,source,f,prev = None):
        if (prev is None):
            prev = tink_streams_Empty.inst
        ret = None
        terminated = False
        buf = []
        def _hx_local_5(item):
            buf.append(item)
            def _hx_local_4():
                def _hx_local_3(o):
                    nonlocal terminated
                    nonlocal ret
                    nonlocal ret
                    ret1 = o.index
                    if (ret1 == 0):
                        ret = o.params[0]
                        return tink_streams_Handled.Finish
                    elif (ret1 == 1):
                        v = o.params[0]
                        ret = (v.params[0] if ((v.index == 0)) else tink_core__Lazy_LazyFunc(tink_streams_Empty.make).get())
                        terminated = True
                        return tink_streams_Handled.Finish
                    elif (ret1 == 2):
                        return tink_streams_Handled.Resume
                    elif (ret1 == 3):
                        return tink_streams_Handled.Clog(o.params[0])
                    else:
                        pass
                return f.apply(buf,tink_streams_RegroupStatus.Flowing).map(_hx_local_3).gather()
            return _hx_local_4()
        def _hx_local_2(o1):
            ret2 = o1.index
            if (ret2 == 0):
                if terminated:
                    return ret
                else:
                    return tink_streams__Stream_RegroupStream(o1.params[0],f,ret)
            elif (ret2 == 1):
                return tink_streams__Stream_CloggedStream(tink_streams__Stream_Stream_Impl_.ofError(o1.params[0]),o1.params[1])
            elif (ret2 == 2):
                return tink_streams__Stream_Stream_Impl_.ofError(o1.params[0])
            elif (ret2 == 3):
                if (len(buf) == 0):
                    return tink_streams_Empty.inst
                else:
                    def _hx_local_1():
                        def _hx_local_0(o2):
                            ret3 = o2.index
                            if (ret3 == 0):
                                return o2.params[0]
                            elif (ret3 == 1):
                                v1 = o2.params[0]
                                if (v1.index == 0):
                                    return v1.params[0]
                                else:
                                    return tink_core__Lazy_LazyFunc(tink_streams_Empty.make).get()
                            elif (ret3 == 2):
                                return tink_streams_Empty.inst
                            elif (ret3 == 3):
                                return tink_streams__Stream_Stream_Impl_.ofError(o2.params[0])
                            else:
                                pass
                        return tink_streams__Stream_Stream_Impl_.flatten(f.apply(buf,tink_streams_RegroupStatus.Ended).map(_hx_local_0).gather())
                    return _hx_local_1()
            else:
                pass
        super().__init__([prev, tink_streams__Stream_Stream_Impl_.flatten(source.forEach(tink_streams__Stream_Handler_Impl_.ofUnknown(_hx_local_5)).map(_hx_local_2).gather())])
tink_streams__Stream_RegroupStream._hx_class = tink_streams__Stream_RegroupStream
_hx_classes["tink.streams._Stream.RegroupStream"] = tink_streams__Stream_RegroupStream

class tink_streams_Handled(Enum):
    __slots__ = ()
    _hx_class_name = "tink.streams.Handled"
    _hx_constructs = ["BackOff", "Finish", "Resume", "Clog"]

    @staticmethod
    def Clog(e):
        return tink_streams_Handled("Clog", 3, [e])
tink_streams_Handled.BackOff = tink_streams_Handled("BackOff", 0, list())
tink_streams_Handled.Finish = tink_streams_Handled("Finish", 1, list())
tink_streams_Handled.Resume = tink_streams_Handled("Resume", 2, list())
tink_streams_Handled._hx_class = tink_streams_Handled
_hx_classes["tink.streams.Handled"] = tink_streams_Handled

class tink_streams_Conclusion(Enum):
    __slots__ = ()
    _hx_class_name = "tink.streams.Conclusion"
    _hx_constructs = ["Halted", "Clogged", "Failed", "Depleted"]

    @staticmethod
    def Halted(rest):
        return tink_streams_Conclusion("Halted", 0, [rest])

    @staticmethod
    def Clogged(error,at):
        return tink_streams_Conclusion("Clogged", 1, [error,at])

    @staticmethod
    def Failed(error):
        return tink_streams_Conclusion("Failed", 2, [error])
tink_streams_Conclusion.Depleted = tink_streams_Conclusion("Depleted", 3, list())
tink_streams_Conclusion._hx_class = tink_streams_Conclusion
_hx_classes["tink.streams.Conclusion"] = tink_streams_Conclusion

class tink_streams_ReductionStep(Enum):
    __slots__ = ()
    _hx_class_name = "tink.streams.ReductionStep"
    _hx_constructs = ["Progress", "Crash"]

    @staticmethod
    def Progress(result):
        return tink_streams_ReductionStep("Progress", 0, [result])

    @staticmethod
    def Crash(e):
        return tink_streams_ReductionStep("Crash", 1, [e])
tink_streams_ReductionStep._hx_class = tink_streams_ReductionStep
_hx_classes["tink.streams.ReductionStep"] = tink_streams_ReductionStep

class tink_streams_Reduction(Enum):
    __slots__ = ()
    _hx_class_name = "tink.streams.Reduction"
    _hx_constructs = ["Crashed", "Failed", "Reduced"]

    @staticmethod
    def Crashed(error,at):
        return tink_streams_Reduction("Crashed", 0, [error,at])

    @staticmethod
    def Failed(error):
        return tink_streams_Reduction("Failed", 1, [error])

    @staticmethod
    def Reduced(result):
        return tink_streams_Reduction("Reduced", 2, [result])
tink_streams_Reduction._hx_class = tink_streams_Reduction
_hx_classes["tink.streams.Reduction"] = tink_streams_Reduction


class tink_streams__Stream_CloggedStream(tink_streams_StreamBase):
    _hx_class_name = "tink.streams._Stream.CloggedStream"
    __slots__ = ("rest", "error")
    _hx_fields = ["rest", "error"]
    _hx_methods = ["next", "forEach"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = tink_streams_StreamBase


    def __init__(self,rest,error):
        self.error = None
        self.rest = None
        super().__init__()
        self.rest = rest
        self.error = error

    def next(self):
        return tink_core__Future_SyncFuture(tink_core__Lazy_LazyConst(tink_streams_Step.Fail(self.error)))

    def forEach(self,handler):
        return tink_core__Future_SyncFuture(tink_core__Lazy_LazyConst(tink_streams_Conclusion.Clogged(self.error,self.rest)))

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.rest = None
        _hx_o.error = None
tink_streams__Stream_CloggedStream._hx_class = tink_streams__Stream_CloggedStream
_hx_classes["tink.streams._Stream.CloggedStream"] = tink_streams__Stream_CloggedStream


class tink_streams__Stream_ErrorStream(tink_streams_StreamBase):
    _hx_class_name = "tink.streams._Stream.ErrorStream"
    __slots__ = ("error",)
    _hx_fields = ["error"]
    _hx_methods = ["next", "forEach"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = tink_streams_StreamBase


    def __init__(self,error):
        self.error = None
        super().__init__()
        self.error = error

    def next(self):
        return tink_core__Future_SyncFuture(tink_core__Lazy_LazyConst(tink_streams_Step.Fail(self.error)))

    def forEach(self,handler):
        return tink_core__Future_SyncFuture(tink_core__Lazy_LazyConst(tink_streams_Conclusion.Failed(self.error)))

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.error = None
tink_streams__Stream_ErrorStream._hx_class = tink_streams__Stream_ErrorStream
_hx_classes["tink.streams._Stream.ErrorStream"] = tink_streams__Stream_ErrorStream


class tink_streams_Empty(tink_streams_StreamBase):
    _hx_class_name = "tink.streams.Empty"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = ["get_depleted", "next", "forEach"]
    _hx_statics = ["inst", "make"]
    _hx_interfaces = []
    _hx_super = tink_streams_StreamBase


    def __init__(self):
        super().__init__()

    def get_depleted(self):
        return True

    def next(self):
        return tink_core__Future_SyncFuture(tink_core__Lazy_LazyConst(tink_streams_Step.End))

    def forEach(self,handler):
        return tink_core__Future_SyncFuture(tink_core__Lazy_LazyConst(tink_streams_Conclusion.Depleted))

    @staticmethod
    def make():
        return tink_streams_Empty.inst

    @staticmethod
    def _hx_empty_init(_hx_o):        pass
tink_streams_Empty._hx_class = tink_streams_Empty
_hx_classes["tink.streams.Empty"] = tink_streams_Empty


class tink_streams__Stream_Mapping_Impl_:
    _hx_class_name = "tink.streams._Stream.Mapping_Impl_"
    __slots__ = ()
    _hx_statics = ["_new", "ofNext", "ofAsync", "ofSync", "ofPlain"]

    @staticmethod
    def _new(o):
        return o

    @staticmethod
    def ofNext(n):
        def _hx_local_4():
            def _hx_local_3(i,_):
                def _hx_local_0(o):
                    return tink_core__Future_SyncFuture(tink_core__Lazy_LazyConst(tink_core_Outcome.Success(tink_streams_RegroupResult.Converted(tink_streams__Stream_Stream_Impl_.single(o)))))
                this1 = tink_core__Promise_Promise_Impl_.next(n((i[0] if 0 < len(i) else None)),_hx_local_0)
                f = tink_core__Promise_Recover_Impl_.ofSync(tink_streams_RegroupResult.Errored)
                def _hx_local_2():
                    def _hx_local_1(o1):
                        ret = o1.index
                        if (ret == 0):
                            return tink_core__Future_SyncFuture(tink_core__Lazy_LazyConst(o1.params[0]))
                        elif (ret == 1):
                            return f(o1.params[0])
                        else:
                            pass
                    return this1.flatMap(_hx_local_1).gather()
                return _hx_local_2()
            return _hx_AnonObject({'apply': _hx_local_3})
        return _hx_local_4()

    @staticmethod
    def ofAsync(f):
        def _hx_local_3():
            def _hx_local_2(i,_):
                def _hx_local_1():
                    def _hx_local_0(o):
                        return tink_streams_RegroupResult.Converted(tink_streams__Stream_Stream_Impl_.single(o))
                    return f((i[0] if 0 < len(i) else None)).map(_hx_local_0).gather()
                return _hx_local_1()
            return _hx_AnonObject({'apply': _hx_local_2})
        return _hx_local_3()

    @staticmethod
    def ofSync(f):
        def _hx_local_1():
            def _hx_local_0(i,_):
                v = None
                _g = f((i[0] if 0 < len(i) else None))
                v1 = _g.index
                if (v1 == 0):
                    v = tink_streams_RegroupResult.Converted(tink_streams__Stream_Stream_Impl_.single(_g.params[0]))
                elif (v1 == 1):
                    v = tink_streams_RegroupResult.Errored(_g.params[0])
                else:
                    pass
                return tink_core__Future_SyncFuture(tink_core__Lazy_LazyConst(v))
            return _hx_AnonObject({'apply': _hx_local_0})
        return _hx_local_1()

    @staticmethod
    def ofPlain(f):
        def _hx_local_1():
            def _hx_local_0(i,_):
                return tink_core__Future_SyncFuture(tink_core__Lazy_LazyConst(tink_streams_RegroupResult.Converted(tink_streams__Stream_Stream_Impl_.single(f((i[0] if 0 < len(i) else None))))))
            return _hx_AnonObject({'apply': _hx_local_0})
        return _hx_local_1()
tink_streams__Stream_Mapping_Impl_._hx_class = tink_streams__Stream_Mapping_Impl_
_hx_classes["tink.streams._Stream.Mapping_Impl_"] = tink_streams__Stream_Mapping_Impl_


class tink_streams__Stream_Filter_Impl_:
    _hx_class_name = "tink.streams._Stream.Filter_Impl_"
    __slots__ = ()
    _hx_statics = ["_new", "ofNext", "ofAsync", "ofSync", "ofPlain"]

    @staticmethod
    def _new(o):
        return o

    @staticmethod
    def ofNext(n):
        def _hx_local_4():
            def _hx_local_3(i,_):
                def _hx_local_0(matched):
                    return tink_core__Future_SyncFuture(tink_core__Lazy_LazyConst(tink_core_Outcome.Success(tink_streams_RegroupResult.Converted((tink_streams__Stream_Stream_Impl_.single((i[0] if 0 < len(i) else None)) if matched else tink_streams_Empty.inst)))))
                this1 = tink_core__Promise_Promise_Impl_.next(n((i[0] if 0 < len(i) else None)),_hx_local_0)
                f = tink_core__Promise_Recover_Impl_.ofSync(tink_streams_RegroupResult.Errored)
                def _hx_local_2():
                    def _hx_local_1(o):
                        ret = o.index
                        if (ret == 0):
                            return tink_core__Future_SyncFuture(tink_core__Lazy_LazyConst(o.params[0]))
                        elif (ret == 1):
                            return f(o.params[0])
                        else:
                            pass
                    return this1.flatMap(_hx_local_1).gather()
                return _hx_local_2()
            return _hx_AnonObject({'apply': _hx_local_3})
        return _hx_local_4()

    @staticmethod
    def ofAsync(f):
        def _hx_local_3():
            def _hx_local_2(i,_):
                def _hx_local_1():
                    def _hx_local_0(matched):
                        return tink_streams_RegroupResult.Converted((tink_streams__Stream_Stream_Impl_.single((i[0] if 0 < len(i) else None)) if matched else tink_streams_Empty.inst))
                    return f((i[0] if 0 < len(i) else None)).map(_hx_local_0).gather()
                return _hx_local_1()
            return _hx_AnonObject({'apply': _hx_local_2})
        return _hx_local_3()

    @staticmethod
    def ofSync(f):
        def _hx_local_1():
            def _hx_local_0(i,_):
                v = None
                _g = f((i[0] if 0 < len(i) else None))
                v1 = _g.index
                if (v1 == 0):
                    v = tink_streams_RegroupResult.Converted((tink_streams__Stream_Stream_Impl_.single((i[0] if 0 < len(i) else None)) if (_g.params[0]) else tink_streams_Empty.inst))
                elif (v1 == 1):
                    v = tink_streams_RegroupResult.Errored(_g.params[0])
                else:
                    pass
                return tink_core__Future_SyncFuture(tink_core__Lazy_LazyConst(v))
            return _hx_AnonObject({'apply': _hx_local_0})
        return _hx_local_1()

    @staticmethod
    def ofPlain(f):
        def _hx_local_1():
            def _hx_local_0(i,_):
                return tink_core__Future_SyncFuture(tink_core__Lazy_LazyConst(tink_streams_RegroupResult.Converted((tink_streams__Stream_Stream_Impl_.single((i[0] if 0 < len(i) else None)) if (f((i[0] if 0 < len(i) else None))) else tink_streams_Empty.inst))))
            return _hx_AnonObject({'apply': _hx_local_0})
        return _hx_local_1()
tink_streams__Stream_Filter_Impl_._hx_class = tink_streams__Stream_Filter_Impl_
_hx_classes["tink.streams._Stream.Filter_Impl_"] = tink_streams__Stream_Filter_Impl_


class tink_streams_IdealizeStream(tink_streams_IdealStreamBase):
    _hx_class_name = "tink.streams.IdealizeStream"
    __slots__ = ("target", "rescue")
    _hx_fields = ["target", "rescue"]
    _hx_methods = ["get_depleted", "next", "forEach"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = tink_streams_IdealStreamBase


    def __init__(self,target,rescue):
        self.rescue = None
        self.target = None
        super().__init__()
        self.target = target
        self.rescue = rescue

    def get_depleted(self):
        return self.target.get_depleted()

    def next(self):
        _gthis = self
        def _hx_local_1():
            def _hx_local_0(v):
                if (v.index == 1):
                    return _gthis.rescue(v.params[0]).idealize(_gthis.rescue).next()
                else:
                    return tink_core__Future_SyncFuture(tink_core__Lazy_LazyConst(v))
            return self.target.next().flatMap(_hx_local_0).gather()
        return _hx_local_1()

    def forEach(self,handler):
        _gthis = self
        def _hx_local_2():
            def _hx_local_1(cb):
                def _hx_local_0(end):
                    tmp = end.index
                    if (tmp == 0):
                        tmp1 = tink_streams_Conclusion.Halted(end.params[0].idealize(_gthis.rescue))
                        cb(tmp1)
                    elif (tmp == 1):
                        tmp2 = tink_streams_Conclusion.Clogged(end.params[0],end.params[1].idealize(_gthis.rescue))
                        cb(tmp2)
                    elif (tmp == 2):
                        _gthis.rescue(end.params[0]).idealize(_gthis.rescue).forEach(handler).handle(cb)
                    elif (tmp == 3):
                        cb(tink_streams_Conclusion.Depleted)
                    else:
                        pass
                _gthis.target.forEach(handler).handle(_hx_local_0)
            return tink_core__Future_Future_Impl_.make(_hx_local_1)
        return _hx_local_2()

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.target = None
        _hx_o.rescue = None
tink_streams_IdealizeStream._hx_class = tink_streams_IdealizeStream
_hx_classes["tink.streams.IdealizeStream"] = tink_streams_IdealizeStream


class tink_streams_Single(tink_streams_StreamBase):
    _hx_class_name = "tink.streams.Single"
    __slots__ = ("value",)
    _hx_fields = ["value"]
    _hx_methods = ["next", "forEach"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = tink_streams_StreamBase


    def __init__(self,value):
        self.value = None
        super().__init__()
        self.value = value

    def next(self):
        return tink_core__Future_SyncFuture(tink_core__Lazy_LazyConst(tink_streams_Step.Link(self.value.get(),tink_streams_Empty.inst)))

    def forEach(self,handle):
        _gthis = self
        def _hx_local_1():
            def _hx_local_0(step):
                ret = step.index
                if (ret == 0):
                    return tink_streams_Conclusion.Halted(_gthis)
                elif (ret == 1):
                    return tink_streams_Conclusion.Halted(tink_streams_Empty.inst)
                elif (ret == 2):
                    return tink_streams_Conclusion.Depleted
                elif (ret == 3):
                    return tink_streams_Conclusion.Clogged(step.params[0],_gthis)
                else:
                    pass
            return handle(self.value.get()).map(_hx_local_0).gather()
        return _hx_local_1()

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.value = None
tink_streams_Single._hx_class = tink_streams_Single
_hx_classes["tink.streams.Single"] = tink_streams_Single


class tink_streams__Stream_Handler_Impl_:
    _hx_class_name = "tink.streams._Stream.Handler_Impl_"
    __slots__ = ()
    _hx_statics = ["_new", "apply", "ofSafeSync", "ofUnknownSync", "ofSafe", "ofUnknown"]

    @staticmethod
    def _new(f):
        return f

    @staticmethod
    def apply(this1,item):
        return this1(item)

    @staticmethod
    def ofSafeSync(f):
        def _hx_local_1():
            def _hx_local_0(i):
                return tink_core__Future_SyncFuture(tink_core__Lazy_LazyConst(f(i)))
            return _hx_local_0
        return _hx_local_1()

    @staticmethod
    def ofUnknownSync(f):
        def _hx_local_1():
            def _hx_local_0(i):
                return tink_core__Future_SyncFuture(tink_core__Lazy_LazyConst(f(i)))
            return _hx_local_0
        return _hx_local_1()

    @staticmethod
    def ofSafe(f):
        return f

    @staticmethod
    def ofUnknown(f):
        return f
tink_streams__Stream_Handler_Impl_._hx_class = tink_streams__Stream_Handler_Impl_
_hx_classes["tink.streams._Stream.Handler_Impl_"] = tink_streams__Stream_Handler_Impl_


class tink_streams__Stream_Reducer_Impl_:
    _hx_class_name = "tink.streams._Stream.Reducer_Impl_"
    __slots__ = ()
    _hx_statics = ["_new", "apply", "ofSafeSync", "ofUnknownSync", "ofSafe", "ofPlainSync", "ofUnknown", "ofPromiseBased"]

    @staticmethod
    def _new(f):
        return f

    @staticmethod
    def apply(this1,res,item):
        return this1(res,item)

    @staticmethod
    def ofSafeSync(f):
        def _hx_local_1():
            def _hx_local_0(res,cur):
                return tink_core__Future_SyncFuture(tink_core__Lazy_LazyConst(f(res,cur)))
            return _hx_local_0
        return _hx_local_1()

    @staticmethod
    def ofUnknownSync(f):
        def _hx_local_1():
            def _hx_local_0(res,cur):
                return tink_core__Future_SyncFuture(tink_core__Lazy_LazyConst(f(res,cur)))
            return _hx_local_0
        return _hx_local_1()

    @staticmethod
    def ofSafe(f):
        return f

    @staticmethod
    def ofPlainSync(f):
        def _hx_local_1():
            def _hx_local_0(res,cur):
                return tink_core__Future_SyncFuture(tink_core__Lazy_LazyConst(tink_streams_ReductionStep.Progress(f(res,cur))))
            return _hx_local_0
        return _hx_local_1()

    @staticmethod
    def ofUnknown(f):
        return f

    @staticmethod
    def ofPromiseBased(f):
        def _hx_local_3():
            def _hx_local_2(res,cur):
                def _hx_local_1():
                    def _hx_local_0(s):
                        ret = s.index
                        if (ret == 0):
                            return tink_streams_ReductionStep.Progress(s.params[0])
                        elif (ret == 1):
                            return tink_streams_ReductionStep.Crash(s.params[0])
                        else:
                            pass
                    return f(res,cur).map(_hx_local_0).gather()
                return _hx_local_1()
            return _hx_local_2
        return _hx_local_3()
tink_streams__Stream_Reducer_Impl_._hx_class = tink_streams__Stream_Reducer_Impl_
_hx_classes["tink.streams._Stream.Reducer_Impl_"] = tink_streams__Stream_Reducer_Impl_


class tink_streams_FutureStream(tink_streams_StreamBase):
    _hx_class_name = "tink.streams.FutureStream"
    __slots__ = ("f",)
    _hx_fields = ["f"]
    _hx_methods = ["next", "forEach"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = tink_streams_StreamBase


    def __init__(self,f):
        self.f = None
        super().__init__()
        self.f = f

    def next(self):
        def _hx_local_1():
            def _hx_local_0(s):
                return s.next()
            return self.f.flatMap(_hx_local_0).gather()
        return _hx_local_1()

    def forEach(self,handler):
        _gthis = self
        def _hx_local_2():
            def _hx_local_1(cb):
                def _hx_local_0(s):
                    s.forEach(handler).handle(cb)
                _gthis.f.handle(_hx_local_0)
            return tink_core__Future_Future_Impl_.make(_hx_local_1)
        return _hx_local_2()

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.f = None
tink_streams_FutureStream._hx_class = tink_streams_FutureStream
_hx_classes["tink.streams.FutureStream"] = tink_streams_FutureStream


class tink_streams_Generator(tink_streams_StreamBase):
    _hx_class_name = "tink.streams.Generator"
    __slots__ = ("upcoming",)
    _hx_fields = ["upcoming"]
    _hx_methods = ["next", "forEach"]
    _hx_statics = ["stream"]
    _hx_interfaces = []
    _hx_super = tink_streams_StreamBase


    def __init__(self,upcoming):
        self.upcoming = None
        super().__init__()
        self.upcoming = upcoming

    def next(self):
        return self.upcoming

    def forEach(self,handler):
        _gthis = self
        def _hx_local_3():
            def _hx_local_2(cb):
                def _hx_local_1(e):
                    tmp = e.index
                    if (tmp == 0):
                        then = e.params[1]
                        def _hx_local_0(s):
                            tmp1 = s.index
                            if (tmp1 == 0):
                                cb(tink_streams_Conclusion.Halted(_gthis))
                            elif (tmp1 == 1):
                                cb(tink_streams_Conclusion.Halted(then))
                            elif (tmp1 == 2):
                                then.forEach(handler).handle(cb)
                            elif (tmp1 == 3):
                                cb(tink_streams_Conclusion.Clogged(s.params[0],_gthis))
                            else:
                                pass
                        handler(e.params[0]).handle(_hx_local_0)
                    elif (tmp == 1):
                        cb(tink_streams_Conclusion.Failed(e.params[0]))
                    elif (tmp == 2):
                        cb(tink_streams_Conclusion.Depleted)
                    else:
                        pass
                _gthis.upcoming.handle(_hx_local_1)
            return tink_core__Future_Future_Impl_.make(_hx_local_2,True)
        return _hx_local_3()

    @staticmethod
    def stream(step):
        return tink_streams_Generator(tink_core__Future_Future_Impl_.make(step,True))

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.upcoming = None
tink_streams_Generator._hx_class = tink_streams_Generator
_hx_classes["tink.streams.Generator"] = tink_streams_Generator


class tink_streams_BlendStream(tink_streams_Generator):
    _hx_class_name = "tink.streams.BlendStream"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = []
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = tink_streams_Generator


    def __init__(self,a,b):
        first = None
        def _hx_local_2(s):
            def _hx_local_1():
                def _hx_local_0(o):
                    nonlocal first
                    if (first is None):
                        first = s
                    return o
                return s.next().map(_hx_local_0).gather()
            return _hx_local_1()
        wait = _hx_local_2
        n1 = wait(a)
        n2 = wait(b)
        def _hx_local_4(cb):
            def _hx_local_3(o1):
                tmp = o1.index
                if (tmp == 0):
                    tmp1 = tink_streams_Step.Link(o1.params[0],tink_streams_BlendStream(o1.params[1],(b if ((first == a)) else a)))
                    cb(tmp1)
                elif (tmp == 1):
                    cb(tink_streams_Step.Fail(o1.params[0]))
                elif (tmp == 2):
                    ((n2 if ((first == a)) else n1)).handle(cb)
                else:
                    pass
            tink_core__Future_Future_Impl_.first(n1,n2).handle(_hx_local_3)
        super().__init__(tink_core__Future_Future_Impl_.make(_hx_local_4))
tink_streams_BlendStream._hx_class = tink_streams_BlendStream
_hx_classes["tink.streams.BlendStream"] = tink_streams_BlendStream

class tink_streams_Step(Enum):
    __slots__ = ()
    _hx_class_name = "tink.streams.Step"
    _hx_constructs = ["Link", "Fail", "End"]

    @staticmethod
    def Link(value,next):
        return tink_streams_Step("Link", 0, [value,next])

    @staticmethod
    def Fail(e):
        return tink_streams_Step("Fail", 1, [e])
tink_streams_Step.End = tink_streams_Step("End", 2, list())
tink_streams_Step._hx_class = tink_streams_Step
_hx_classes["tink.streams.Step"] = tink_streams_Step


class tink_streams_SignalStream(tink_streams_Generator):
    _hx_class_name = "tink.streams.SignalStream"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = []
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = tink_streams_Generator


    def __init__(self,signal):
        def _hx_local_0(o):
            ret = o.index
            if (ret == 0):
                return tink_streams_Step.Link(o.params[0],tink_streams_SignalStream(signal))
            elif (ret == 1):
                return tink_streams_Step.Fail(o.params[0])
            elif (ret == 2):
                return tink_streams_Step.End
            else:
                pass
        super().__init__(tink_core__Signal_Signal_Impl_.nextTime(signal).map(_hx_local_0).gather())
tink_streams_SignalStream._hx_class = tink_streams_SignalStream
_hx_classes["tink.streams.SignalStream"] = tink_streams_SignalStream

class tink_streams_Yield(Enum):
    __slots__ = ()
    _hx_class_name = "tink.streams.Yield"
    _hx_constructs = ["Data", "Fail", "End"]

    @staticmethod
    def Data(data):
        return tink_streams_Yield("Data", 0, [data])

    @staticmethod
    def Fail(e):
        return tink_streams_Yield("Fail", 1, [e])
tink_streams_Yield.End = tink_streams_Yield("End", 2, list())
tink_streams_Yield._hx_class = tink_streams_Yield
_hx_classes["tink.streams.Yield"] = tink_streams_Yield


class tink_testrunner_Assertion:
    _hx_class_name = "tink.testrunner.Assertion"
    __slots__ = ("holds", "description", "pos")
    _hx_fields = ["holds", "description", "pos"]

    def __init__(self,holds,description,pos = None):
        self.holds = holds
        self.description = description
        self.pos = pos

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.holds = None
        _hx_o.description = None
        _hx_o.pos = None
tink_testrunner_Assertion._hx_class = tink_testrunner_Assertion
_hx_classes["tink.testrunner.Assertion"] = tink_testrunner_Assertion


class tink_testrunner__Assertion_AssertionResult_Impl_:
    _hx_class_name = "tink.testrunner._Assertion.AssertionResult_Impl_"
    __slots__ = ()
    _hx_statics = ["ofBool", "ofOutcome", "toBool", "not", "and_", "or_", "_and", "_or"]

    @staticmethod
    def ofBool(v):
        if v:
            return tink_core_Outcome.Success(tink_core_Noise.Noise)
        else:
            return tink_core_Outcome.Failure(None)

    @staticmethod
    def ofOutcome(v):
        tmp = v.index
        if (tmp == 0):
            return tink_core_Outcome.Success(tink_core_Noise.Noise)
        elif (tmp == 1):
            e = v.params[0]
            return tink_core_Outcome.Failure(((("" + HxOverrides.stringOrNull(e.toString())) + " ") + Std.string(e.data)))
        else:
            pass

    @staticmethod
    def toBool(this1):
        return tink_core_OutcomeTools.isSuccess(this1)

    @staticmethod
    def _hx_not(this1):
        return (not tink_core_OutcomeTools.isSuccess(this1))

    @staticmethod
    def and_(a,b):
        if tink_core_OutcomeTools.isSuccess(a):
            return b
        else:
            return False

    @staticmethod
    def or_(a,b):
        if (not tink_core_OutcomeTools.isSuccess(a)):
            return b
        else:
            return True

    @staticmethod
    def _and(a,b):
        if a:
            return tink_core_OutcomeTools.isSuccess(b)
        else:
            return False

    @staticmethod
    def _or(a,b):
        if (not a):
            return tink_core_OutcomeTools.isSuccess(b)
        else:
            return True
tink_testrunner__Assertion_AssertionResult_Impl_._hx_class = tink_testrunner__Assertion_AssertionResult_Impl_
_hx_classes["tink.testrunner._Assertion.AssertionResult_Impl_"] = tink_testrunner__Assertion_AssertionResult_Impl_


class tink_testrunner__Assertions_Assertions_Impl_:
    _hx_class_name = "tink.testrunner._Assertions.Assertions_Impl_"
    __slots__ = ()
    _hx_statics = ["ofAssertion", "ofArray", "ofPromiseArray", "ofFutureAssertion", "ofFutureAssertions", "ofSurpriseAssertion", "ofOutcomeAssertions", "ofPromiseAssertions", "ofSurpriseAssertions"]

    @staticmethod
    def ofAssertion(o):
        return tink_streams__Stream_Stream_Impl_.ofIterator(python_HaxeIterator([o].__iter__()))

    @staticmethod
    def ofArray(o):
        return tink_streams__Stream_Stream_Impl_.ofIterator(python_HaxeIterator(o.__iter__()))

    @staticmethod
    def ofPromiseArray(o):
        def _hx_local_1():
            def _hx_local_0(o1):
                return tink_streams__Stream_Stream_Impl_.ofIterator(python_HaxeIterator(o1.__iter__()))
            return tink_streams__Stream_Stream_Impl_.promise(tink_core__Promise_Promise_Impl_.next(o,tink_core__Promise_Next_Impl_.ofSafeSync(_hx_local_0)))
        return _hx_local_1()

    @staticmethod
    def ofFutureAssertion(p):
        def _hx_local_1():
            def _hx_local_0(a):
                return tink_core_Outcome.Success(tink_streams__Stream_Stream_Impl_.ofIterator(python_HaxeIterator([a].__iter__())))
            return tink_streams__Stream_Stream_Impl_.promise(p.map(_hx_local_0).gather())
        return _hx_local_1()

    @staticmethod
    def ofFutureAssertions(p):
        return tink_streams__Stream_Stream_Impl_.promise(p.map(tink_core_Outcome.Success).gather())

    @staticmethod
    def ofSurpriseAssertion(p):
        def _hx_local_1():
            def _hx_local_0(o):
                return tink_streams__Stream_Stream_Impl_.ofIterator(python_HaxeIterator([o].__iter__()))
            return tink_streams__Stream_Stream_Impl_.promise(tink_core__Future_Future_Impl_._tryMap(p,_hx_local_0))
        return _hx_local_1()

    @staticmethod
    def ofOutcomeAssertions(o):
        return tink_streams__Stream_Stream_Impl_.promise(tink_core__Future_SyncFuture(tink_core__Lazy_LazyConst(o)))

    @staticmethod
    def ofPromiseAssertions(p):
        return tink_streams__Stream_Stream_Impl_.promise(p)

    @staticmethod
    def ofSurpriseAssertions(p):
        return tink_streams__Stream_Stream_Impl_.promise(p)
tink_testrunner__Assertions_Assertions_Impl_._hx_class = tink_testrunner__Assertions_Assertions_Impl_
_hx_classes["tink.testrunner._Assertions.Assertions_Impl_"] = tink_testrunner__Assertions_Assertions_Impl_


class tink_testrunner__Batch_Batch_Impl_:
    _hx_class_name = "tink.testrunner._Batch.Batch_Impl_"
    __slots__ = ()
    _hx_statics = ["_new", "ofSuites", "ofSuite", "ofCases", "ofCase", "get_suites"]
    suites = None

    @staticmethod
    def _new(suites):
        return suites

    @staticmethod
    def ofSuites(suites):
        return suites

    @staticmethod
    def ofSuite(suite):
        return [suite]

    @staticmethod
    def ofCases(cases,pos = None):
        _g = []
        _g1 = 0
        while (_g1 < len(cases)):
            def _hx_local_1():
                nonlocal _g1
                _hx_local_0 = _g1
                _g1 = (_g1 + 1)
                return _hx_local_0
            c = python_internal_ArrayImpl._get(cases, _hx_local_1())
            _g11 = Type.getClass(c)
            x = (None if ((_g11 is None)) else Type.getClassName(_g11))
            _g.append(x)
        return [tink_testrunner_BasicSuite(_hx_AnonObject({'name': ", ".join([python_Boot.toString1(x1,'') for x1 in _g]), 'pos': pos}),cases,_hx_AnonObject({'fileName': "tink/testrunner/Suite.hx", 'lineNumber': 36, 'className': "tink.testrunner._Suite.Suite_Impl_", 'methodName': "ofCases"}))]

    @staticmethod
    def ofCase(caze,pos = None):
        cases = [caze]
        _g = []
        _g1 = 0
        while (_g1 < len(cases)):
            def _hx_local_1():
                nonlocal _g1
                _hx_local_0 = _g1
                _g1 = (_g1 + 1)
                return _hx_local_0
            c = python_internal_ArrayImpl._get(cases, _hx_local_1())
            _g11 = Type.getClass(c)
            x = (None if ((_g11 is None)) else Type.getClassName(_g11))
            _g.append(x)
        return [tink_testrunner_BasicSuite(_hx_AnonObject({'name': ", ".join([python_Boot.toString1(x1,'') for x1 in _g]), 'pos': pos}),cases,_hx_AnonObject({'fileName': "tink/testrunner/Suite.hx", 'lineNumber': 36, 'className': "tink.testrunner._Suite.Suite_Impl_", 'methodName': "ofCases"}))]

    @staticmethod
    def get_suites(this1):
        return this1
tink_testrunner__Batch_Batch_Impl_._hx_class = tink_testrunner__Batch_Batch_Impl_
_hx_classes["tink.testrunner._Batch.Batch_Impl_"] = tink_testrunner__Batch_Batch_Impl_


class tink_testrunner__Case_Case_Impl_:
    _hx_class_name = "tink.testrunner._Case.Case_Impl_"
    __slots__ = ()
    _hx_statics = ["shouldRun"]

    @staticmethod
    def shouldRun(this1,includeMode):
        if (not this1.exclude):
            if (not ((not includeMode))):
                return this1.include
            else:
                return True
        else:
            return False
tink_testrunner__Case_Case_Impl_._hx_class = tink_testrunner__Case_Case_Impl_
_hx_classes["tink.testrunner._Case.Case_Impl_"] = tink_testrunner__Case_Case_Impl_


class tink_testrunner_CaseObject:
    _hx_class_name = "tink.testrunner.CaseObject"
    __slots__ = ("suite", "info", "timeout", "include", "exclude", "pos")
    _hx_fields = ["suite", "info", "timeout", "include", "exclude", "pos"]
    _hx_methods = ["execute"]
tink_testrunner_CaseObject._hx_class = tink_testrunner_CaseObject
_hx_classes["tink.testrunner.CaseObject"] = tink_testrunner_CaseObject


class tink_testrunner_BasicCase:
    _hx_class_name = "tink.testrunner.BasicCase"
    __slots__ = ("suite", "info", "timeout", "include", "exclude", "pos")
    _hx_fields = ["suite", "info", "timeout", "include", "exclude", "pos"]
    _hx_methods = ["execute"]
    _hx_interfaces = [tink_testrunner_CaseObject]

    def __init__(self,pos = None):
        self.info = None
        self.suite = None
        self.pos = None
        self.exclude = False
        self.include = False
        self.timeout = 5000
        self.info = _hx_AnonObject({'name': Type.getClassName(Type.getClass(self)), 'description': None, 'pos': pos})

    def execute(self):
        return tink_streams__Stream_Stream_Impl_.ofIterator(python_HaxeIterator([].__iter__()))

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.suite = None
        _hx_o.info = None
        _hx_o.timeout = None
        _hx_o.include = None
        _hx_o.exclude = None
        _hx_o.pos = None
tink_testrunner_BasicCase._hx_class = tink_testrunner_BasicCase
_hx_classes["tink.testrunner.BasicCase"] = tink_testrunner_BasicCase


class tink_testrunner_Reporter:
    _hx_class_name = "tink.testrunner.Reporter"
    __slots__ = ()
    _hx_methods = ["report"]
tink_testrunner_Reporter._hx_class = tink_testrunner_Reporter
_hx_classes["tink.testrunner.Reporter"] = tink_testrunner_Reporter

class tink_testrunner_ReportType(Enum):
    __slots__ = ()
    _hx_class_name = "tink.testrunner.ReportType"
    _hx_constructs = ["BatchStart", "SuiteStart", "CaseStart", "Assertion", "CaseFinish", "SuiteFinish", "BatchFinish"]

    @staticmethod
    def SuiteStart(info,hasCasesToRun):
        return tink_testrunner_ReportType("SuiteStart", 1, [info,hasCasesToRun])

    @staticmethod
    def CaseStart(info,shouldRun):
        return tink_testrunner_ReportType("CaseStart", 2, [info,shouldRun])

    @staticmethod
    def Assertion(assertion):
        return tink_testrunner_ReportType("Assertion", 3, [assertion])

    @staticmethod
    def CaseFinish(result):
        return tink_testrunner_ReportType("CaseFinish", 4, [result])

    @staticmethod
    def SuiteFinish(result):
        return tink_testrunner_ReportType("SuiteFinish", 5, [result])

    @staticmethod
    def BatchFinish(result):
        return tink_testrunner_ReportType("BatchFinish", 6, [result])
tink_testrunner_ReportType.BatchStart = tink_testrunner_ReportType("BatchStart", 0, list())
tink_testrunner_ReportType._hx_class = tink_testrunner_ReportType
_hx_classes["tink.testrunner.ReportType"] = tink_testrunner_ReportType


class tink_testrunner_Formatter:
    _hx_class_name = "tink.testrunner.Formatter"
    __slots__ = ()
    _hx_methods = ["success", "error", "warning", "info", "extra", "mute", "normal", "color"]
tink_testrunner_Formatter._hx_class = tink_testrunner_Formatter
_hx_classes["tink.testrunner.Formatter"] = tink_testrunner_Formatter


class tink_testrunner_BasicFormatter:
    _hx_class_name = "tink.testrunner.BasicFormatter"
    __slots__ = ()
    _hx_methods = ["success", "error", "warning", "info", "extra", "mute", "normal", "color"]
    _hx_interfaces = [tink_testrunner_Formatter]

    def __init__(self):
        pass

    def success(self,v):
        return self.color(v,"green")

    def error(self,v):
        return self.color(v,"red")

    def warning(self,v):
        return self.color(v,"yellow")

    def info(self,v):
        return self.color(v,"yellow")

    def extra(self,v):
        return self.color(v,"cyan")

    def mute(self,v):
        return self.color(v,"blue")

    def normal(self,v):
        return self.color(v,"")

    def color(self,v,c):
        return v

    @staticmethod
    def _hx_empty_init(_hx_o):        pass
tink_testrunner_BasicFormatter._hx_class = tink_testrunner_BasicFormatter
_hx_classes["tink.testrunner.BasicFormatter"] = tink_testrunner_BasicFormatter


class tink_testrunner_AnsiFormatter(tink_testrunner_BasicFormatter):
    _hx_class_name = "tink.testrunner.AnsiFormatter"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = ["color"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = tink_testrunner_BasicFormatter


    def __init__(self):
        super().__init__()

    def color(self,v,c):
        _hx_local_0 = len(c)
        if (_hx_local_0 == 4):
            if (c == "blue"):
                return ((HxOverrides.stringOrNull(ANSI.aset([Attribute.Blue])) + ("null" if v is None else v)) + HxOverrides.stringOrNull(ANSI.aset([Attribute.DefaultForeground])))
            elif (c == "cyan"):
                return ((HxOverrides.stringOrNull(ANSI.aset([Attribute.Cyan])) + ("null" if v is None else v)) + HxOverrides.stringOrNull(ANSI.aset([Attribute.DefaultForeground])))
            else:
                return (HxOverrides.stringOrNull(ANSI.aset([Attribute.DefaultForeground])) + ("null" if v is None else v))
        elif (_hx_local_0 == 5):
            if (c == "green"):
                return ((HxOverrides.stringOrNull(ANSI.aset([Attribute.Green])) + ("null" if v is None else v)) + HxOverrides.stringOrNull(ANSI.aset([Attribute.DefaultForeground])))
            else:
                return (HxOverrides.stringOrNull(ANSI.aset([Attribute.DefaultForeground])) + ("null" if v is None else v))
        elif (_hx_local_0 == 7):
            if (c == "magenta"):
                return ((HxOverrides.stringOrNull(ANSI.aset([Attribute.Magenta])) + ("null" if v is None else v)) + HxOverrides.stringOrNull(ANSI.aset([Attribute.DefaultForeground])))
            else:
                return (HxOverrides.stringOrNull(ANSI.aset([Attribute.DefaultForeground])) + ("null" if v is None else v))
        elif (_hx_local_0 == 3):
            if (c == "red"):
                return ((HxOverrides.stringOrNull(ANSI.aset([Attribute.Red])) + ("null" if v is None else v)) + HxOverrides.stringOrNull(ANSI.aset([Attribute.DefaultForeground])))
            else:
                return (HxOverrides.stringOrNull(ANSI.aset([Attribute.DefaultForeground])) + ("null" if v is None else v))
        elif (_hx_local_0 == 6):
            if (c == "yellow"):
                return ((HxOverrides.stringOrNull(ANSI.aset([Attribute.Yellow])) + ("null" if v is None else v)) + HxOverrides.stringOrNull(ANSI.aset([Attribute.DefaultForeground])))
            else:
                return (HxOverrides.stringOrNull(ANSI.aset([Attribute.DefaultForeground])) + ("null" if v is None else v))
        else:
            return (HxOverrides.stringOrNull(ANSI.aset([Attribute.DefaultForeground])) + ("null" if v is None else v))

    @staticmethod
    def _hx_empty_init(_hx_o):        pass
tink_testrunner_AnsiFormatter._hx_class = tink_testrunner_AnsiFormatter
_hx_classes["tink.testrunner.AnsiFormatter"] = tink_testrunner_AnsiFormatter


class tink_testrunner_BasicReporter:
    _hx_class_name = "tink.testrunner.BasicReporter"
    __slots__ = ("noise", "formatter")
    _hx_fields = ["noise", "formatter"]
    _hx_methods = ["report", "println", "indent", "formatError"]
    _hx_interfaces = [tink_testrunner_Reporter]

    def __init__(self,formatter = None):
        self.noise = tink_core__Future_SyncFuture(tink_core__Lazy_LazyConst(tink_core_Noise.Noise))
        self.formatter = (formatter if ((formatter is not None)) else (tink_testrunner_BasicFormatter() if ((Sys.systemName() == "Windows")) else tink_testrunner_AnsiFormatter()))

    def report(self,_hx_type):
        tmp = _hx_type.index
        if (tmp == 0):
            pass
        elif (tmp == 1):
            info = _hx_type.params[0]
            if _hx_type.params[1]:
                self.println(" ")
                m = (HxOverrides.stringOrNull(self.formatter.info(info.name)) + ": ")
                if (Reflect.field(info,"pos") is not None):
                    m = (("null" if m is None else m) + HxOverrides.stringOrNull(self.formatter.extra((((("[" + HxOverrides.stringOrNull(Reflect.field(info,"pos").fileName)) + ":") + Std.string(Reflect.field(info,"pos").lineNumber)) + "]"))))
                self.println(m)
        elif (tmp == 2):
            info1 = _hx_type.params[0]
            if _hx_type.params[1]:
                m1 = (HxOverrides.stringOrNull(self.formatter.info(self.indent(info1.name,2))) + ": ")
                if (info1.pos is not None):
                    m1 = (("null" if m1 is None else m1) + HxOverrides.stringOrNull(self.formatter.extra((((("[" + HxOverrides.stringOrNull(info1.pos.fileName)) + ":") + Std.string(info1.pos.lineNumber)) + "] "))))
                if (info1.description is not None):
                    m1 = (("null" if m1 is None else m1) + HxOverrides.stringOrNull(self.formatter.mute(info1.description)))
                self.println(m1)
        elif (tmp == 3):
            assertion = _hx_type.params[0]
            failure = None
            holds = None
            _g = assertion.holds
            holds1 = _g.index
            if (holds1 == 0):
                holds = self.formatter.success("[OK]")
            elif (holds1 == 1):
                failure = _g.params[0]
                holds = self.formatter.error("[FAIL]")
            else:
                pass
            self.println(self.indent(((((("- " + ("null" if holds is None else holds)) + " ") + HxOverrides.stringOrNull(self.formatter.extra((((("[" + HxOverrides.stringOrNull(assertion.pos.fileName)) + ":") + Std.string(assertion.pos.lineNumber)) + "]")))) + " ") + HxOverrides.stringOrNull(assertion.description)),4))
            if (failure is not None):
                self.println(self.formatter.error(self.indent(failure,8)))
        elif (tmp == 4):
            result = _hx_type.params[0].result
            if (result.index == 1):
                self.println(self.formatter.error(self.indent(("- " + HxOverrides.stringOrNull(self.formatError(result.params[0]))),4)))
        elif (tmp == 5):
            _g1 = _hx_type.params[0].result
            tmp1 = _g1.index
            if (tmp1 == 0):
                pass
            elif (tmp1 == 1):
                self.println(self.formatter.error(self.indent(("Setup Failed: " + HxOverrides.stringOrNull(self.formatError(_g1.params[0]))),2)))
            elif (tmp1 == 2):
                self.println(self.formatter.error(self.indent(("Teardown Failed: " + HxOverrides.stringOrNull(self.formatError(_g1.params[0]))),2)))
            else:
                pass
        elif (tmp == 6):
            summary = tink_testrunner__Runner_BatchResult_Impl_.summary(_hx_type.params[0])
            total = len(summary.assertions)
            failures = 0
            errors = 0
            _g2 = 0
            _g11 = summary.failures
            while (_g2 < len(_g11)):
                def _hx_local_4():
                    nonlocal _g2
                    _hx_local_3 = _g2
                    _g2 = (_g2 + 1)
                    return _hx_local_3
                f = python_internal_ArrayImpl._get(_g11, _hx_local_4())
                if (f.index == 0):
                    failures = (failures + 1)
                else:
                    errors = (errors + 1)
            m_b = python_lib_io_StringIO()
            m_b.write(Std.string(total))
            m_b.write(" Assertion")
            if (total > 1):
                m_b.write("s")
            m_b.write("   ")
            m_b.write(Std.string((total - failures)))
            m_b.write(" Success")
            m_b.write("   ")
            m_b.write(Std.string(failures))
            m_b.write(" Failure")
            if (failures > 1):
                m_b.write("s")
            m_b.write("   ")
            m_b.write(Std.string(errors))
            m_b.write(" Error")
            if (errors > 1):
                m_b.write("s")
            m_b.write("   ")
            m2 = m_b.getvalue()
            self.println(" ")
            self.println((self.formatter.success(m2) if (((failures == 0) and ((errors == 0)))) else self.formatter.error(m2)))
            self.println(" ")
        else:
            pass
        return self.noise

    def println(self,v):
        python_Lib.printString((("" + Std.string(v)) + "\n"))

    def indent(self,v,i = 0):
        if (i is None):
            i = 0
        def _hx_local_0(line):
            return (HxOverrides.stringOrNull(StringTools.lpad(""," ",i)) + ("null" if line is None else line))
        _this = list(map(_hx_local_0,v.split("\n")))
        return "\n".join([python_Boot.toString1(x1,'') for x1 in _this])

    def formatError(self,e):
        _hx_str = e.toString()
        if (e.data is not None):
            _hx_str = (("null" if _hx_str is None else _hx_str) + (("\n" + Std.string(e.data))))
        return _hx_str

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.noise = None
        _hx_o.formatter = None
tink_testrunner_BasicReporter._hx_class = tink_testrunner_BasicReporter
_hx_classes["tink.testrunner.BasicReporter"] = tink_testrunner_BasicReporter


class tink_testrunner_Runner:
    _hx_class_name = "tink.testrunner.Runner"
    __slots__ = ()
    _hx_statics = ["exit", "run", "runSuite", "runCase"]

    @staticmethod
    def exit(result):
        Sys.exit(len(tink_testrunner__Runner_BatchResult_Impl_.summary(result).failures))

    @staticmethod
    def run(batch,reporter = None,timers = None):
        if (reporter is None):
            reporter = tink_testrunner_BasicReporter()
        if (timers is None):
            timers = tink_testrunner_HaxeTimerManager()
        includeMode = False
        _g = 0
        _g1 = batch
        while (_g < len(_g1)):
            def _hx_local_1():
                nonlocal _g
                _hx_local_0 = _g
                _g = (_g + 1)
                return _hx_local_0
            s = python_internal_ArrayImpl._get(_g1, _hx_local_1())
            if includeMode:
                break
            _g2 = 0
            _g11 = s.cases
            while (_g2 < len(_g11)):
                def _hx_local_3():
                    nonlocal _g2
                    _hx_local_2 = _g2
                    _g2 = (_g2 + 1)
                    return _hx_local_2
                c = python_internal_ArrayImpl._get(_g11, _hx_local_3())
                if c.include:
                    includeMode = True
                    break
        def _hx_local_9():
            def _hx_local_8(cb):
                def _hx_local_7(_):
                    _hx_iter = python_HaxeIterator(batch.__iter__())
                    results = []
                    next = None
                    def _hx_local_6():
                        if _hx_iter.hasNext():
                            def _hx_local_4(o):
                                results.append(o)
                                reporter.report(tink_testrunner_ReportType.SuiteFinish(o)).handle(tink_core__Callback_Callback_Impl_.fromNiladic(next))
                            tink_testrunner_Runner.runSuite(_hx_iter.next(),reporter,timers,includeMode).handle(_hx_local_4)
                        else:
                            next1 = reporter.report(tink_testrunner_ReportType.BatchFinish(results))
                            f = cb
                            a1 = results
                            def _hx_local_5():
                                f(a1)
                            next1.handle(tink_core__Callback_Callback_Impl_.fromNiladic(_hx_local_5))
                    next = _hx_local_6
                    next()
                reporter.report(tink_testrunner_ReportType.BatchStart).handle(_hx_local_7)
            return tink_core__Future_Future_Impl_.make(_hx_local_8)
        return _hx_local_9()

    @staticmethod
    def runSuite(suite,reporter,timers,includeMode):
        def _hx_local_8():
            def _hx_local_7(cb):
                hasCases = (len(tink_testrunner__Suite_Suite_Impl_.getCasesToBeRun(suite,includeMode)) > 0)
                def _hx_local_6(_):
                    def _hx_local_0():
                        if hasCases:
                            return suite.setup()
                        else:
                            return tink_core__Promise_Promise_Impl_.NOISE
                    setup = _hx_local_0
                    def _hx_local_1():
                        if hasCases:
                            return suite.teardown()
                        else:
                            return tink_core__Promise_Promise_Impl_.NOISE
                    teardown = _hx_local_1
                    _hx_iter = python_HaxeIterator(suite.cases.__iter__())
                    results = []
                    next = None
                    def _hx_local_4():
                        if _hx_iter.hasNext():
                            caze = _hx_iter.next()
                            def _hx_local_2(r):
                                results.append(r)
                                next()
                            tink_testrunner_Runner.runCase(caze,suite,reporter,timers,tink_testrunner__Case_Case_Impl_.shouldRun(caze,includeMode)).handle(_hx_local_2)
                        else:
                            def _hx_local_3(o):
                                next1 = None
                                next2 = o.index
                                if (next2 == 0):
                                    next1 = tink_testrunner_SuiteResultType.Success(results)
                                elif (next2 == 1):
                                    next1 = tink_testrunner_SuiteResultType.TeardownFailed(o.params[0],results)
                                else:
                                    pass
                                cb(_hx_AnonObject({'info': suite.info, 'result': next1}))
                            teardown().handle(_hx_local_3)
                    next = _hx_local_4
                    def _hx_local_5(o1):
                        tmp = o1.index
                        if (tmp == 0):
                            next()
                        elif (tmp == 1):
                            cb(_hx_AnonObject({'info': suite.info, 'result': tink_testrunner_SuiteResultType.SetupFailed(o1.params[0])}))
                        else:
                            pass
                    setup().handle(_hx_local_5)
                reporter.report(tink_testrunner_ReportType.SuiteStart(suite.info,hasCases)).handle(_hx_local_6)
            return tink_core__Future_Future_Impl_.make(_hx_local_7)
        return _hx_local_8()

    @staticmethod
    def runCase(caze,suite,reporter,timers,shouldRun):
        def _hx_local_15():
            def _hx_local_14(cb):
                if shouldRun:
                    def _hx_local_11(_):
                        def _hx_local_7(_1):
                            assertions = []
                            def _hx_local_6():
                                def _hx_local_4(a):
                                    assertions.append(a)
                                    def _hx_local_3():
                                        def _hx_local_2(_2):
                                            return tink_streams_Handled.Resume
                                        return reporter.report(tink_testrunner_ReportType.Assertion(a)).map(_hx_local_2).gather()
                                    return _hx_local_3()
                                def _hx_local_5(o):
                                    this1 = o.index
                                    if (this1 == 0):
                                        raise _HxException("unreachable")
                                    elif (this1 == 2):
                                        return tink_core_Outcome.Failure(o.params[0])
                                    elif (this1 == 3):
                                        return tink_core_Outcome.Success(assertions)
                                    else:
                                        pass
                                return tink_testrunner_TimeoutHelper.timeout(tink_core__Future_Future_Impl_.next(caze.execute().forEach(tink_streams__Stream_Handler_Impl_.ofSafe(_hx_local_4)),tink_core__Promise_Next_Impl_.ofSafe(_hx_local_5)),caze.timeout,timers,_hx_AnonObject({'fileName': "tink/testrunner/Runner.hx", 'lineNumber': 107, 'className': "tink.testrunner.Runner", 'methodName': "runCase"}))
                            return _hx_local_6()
                        def _hx_local_10(result):
                            def _hx_local_9():
                                def _hx_local_8(_3):
                                    return tink_core__Future_SyncFuture(tink_core__Lazy_LazyConst(tink_core_Outcome.Success(result)))
                                return tink_core__Promise_Promise_Impl_.next(tink_testrunner_TimeoutHelper.timeout(suite.after(),caze.timeout,timers,caze.pos),_hx_local_8)
                            return _hx_local_9()
                        def _hx_local_1(result1):
                            results = None
                            results1 = result1.index
                            if (results1 == 0):
                                results = tink_testrunner_CaseResultType.Succeeded(result1.params[0])
                            elif (results1 == 1):
                                results = tink_testrunner_CaseResultType.Failed(result1.params[0])
                            else:
                                pass
                            results2 = _hx_AnonObject({'info': caze.info, 'result': results})
                            def _hx_local_0(_4):
                                cb(results2)
                            reporter.report(tink_testrunner_ReportType.CaseFinish(results2)).handle(_hx_local_0)
                        tink_core__Promise_Promise_Impl_.next(tink_core__Promise_Promise_Impl_.next(tink_testrunner_TimeoutHelper.timeout(suite.before(),caze.timeout,timers,caze.pos),_hx_local_7),_hx_local_10).handle(_hx_local_1)
                    reporter.report(tink_testrunner_ReportType.CaseStart(caze.info,shouldRun)).handle(_hx_local_11)
                else:
                    def _hx_local_13(_5):
                        results3 = _hx_AnonObject({'info': caze.info, 'result': tink_testrunner_CaseResultType.Excluded})
                        def _hx_local_12(_6):
                            cb(results3)
                        reporter.report(tink_testrunner_ReportType.CaseFinish(results3)).handle(_hx_local_12)
                    reporter.report(tink_testrunner_ReportType.CaseStart(caze.info,shouldRun)).handle(_hx_local_13)
            return tink_core__Future_Future_Impl_.make(_hx_local_14)
        return _hx_local_15()
tink_testrunner_Runner._hx_class = tink_testrunner_Runner
_hx_classes["tink.testrunner.Runner"] = tink_testrunner_Runner


class tink_testrunner_TimeoutHelper:
    _hx_class_name = "tink.testrunner.TimeoutHelper"
    __slots__ = ()
    _hx_statics = ["timeout"]

    @staticmethod
    def timeout(promise,ms,timers,pos = None):
        def _hx_local_3():
            def _hx_local_2(cb):
                done = False
                timer = None
                def _hx_local_0(o):
                    nonlocal done
                    done = True
                    if (timer is not None):
                        timer.stop()
                    cb(o)
                link = promise.handle(_hx_local_0)
                if ((not done) and ((timers is not None))):
                    def _hx_local_1():
                        if (link is not None):
                            link.cancel()
                        cb(tink_core_Outcome.Failure(tink_core_TypedError(None,(("Timed out after " + Std.string(ms)) + " ms"),pos)))
                    timer = timers.schedule(ms,_hx_local_1)
            return tink_core__Future_Future_Impl_.make(_hx_local_2)
        return _hx_local_3()
tink_testrunner_TimeoutHelper._hx_class = tink_testrunner_TimeoutHelper
_hx_classes["tink.testrunner.TimeoutHelper"] = tink_testrunner_TimeoutHelper


class tink_testrunner__Runner_BatchResult_Impl_:
    _hx_class_name = "tink.testrunner._Runner.BatchResult_Impl_"
    __slots__ = ()
    _hx_statics = ["summary"]

    @staticmethod
    def summary(this1):
        ret = _hx_AnonObject({'assertions': [], 'failures': []})
        def _hx_local_4(cases):
            _g = 0
            while (_g < len(cases)):
                def _hx_local_1():
                    nonlocal _g
                    _hx_local_0 = _g
                    _g = (_g + 1)
                    return _hx_local_0
                c = python_internal_ArrayImpl._get(cases, _hx_local_1())
                _g1 = c.result
                handleCases1 = _g1.index
                if (handleCases1 == 0):
                    assertions = _g1.params[0]
                    handleCases2 = (ret.assertions + assertions)
                    ret.assertions = handleCases2
                    def _hx_local_2(a):
                        return tink_testrunner_FailureType.AssertionFailed(a)
                    def _hx_local_3(a1):
                        return (not tink_core_OutcomeTools.isSuccess(a1.holds))
                    handleCases3 = (ret.failures + list(map(_hx_local_2,list(filter(_hx_local_3,assertions)))))
                    ret.failures = handleCases3
                elif (handleCases1 == 1):
                    ret.failures.append(tink_testrunner_FailureType.CaseFailed(_g1.params[0]))
                elif (handleCases1 == 2):
                    pass
                else:
                    pass
        handleCases = _hx_local_4
        _g2 = 0
        while (_g2 < len(this1)):
            def _hx_local_6():
                nonlocal _g2
                _hx_local_5 = _g2
                _g2 = (_g2 + 1)
                return _hx_local_5
            s = python_internal_ArrayImpl._get(this1, _hx_local_6())
            _g3 = s.result
            tmp = _g3.index
            if (tmp == 0):
                handleCases(_g3.params[0])
            elif (tmp == 1):
                ret.failures.append(tink_testrunner_FailureType.SuiteFailed(_g3.params[0]))
            elif (tmp == 2):
                handleCases(_g3.params[1])
                ret.failures.append(tink_testrunner_FailureType.SuiteFailed(_g3.params[0]))
            else:
                pass
        return ret
tink_testrunner__Runner_BatchResult_Impl_._hx_class = tink_testrunner__Runner_BatchResult_Impl_
_hx_classes["tink.testrunner._Runner.BatchResult_Impl_"] = tink_testrunner__Runner_BatchResult_Impl_

class tink_testrunner_SuiteResultType(Enum):
    __slots__ = ()
    _hx_class_name = "tink.testrunner.SuiteResultType"
    _hx_constructs = ["Success", "SetupFailed", "TeardownFailed"]

    @staticmethod
    def Success(cases):
        return tink_testrunner_SuiteResultType("Success", 0, [cases])

    @staticmethod
    def SetupFailed(e):
        return tink_testrunner_SuiteResultType("SetupFailed", 1, [e])

    @staticmethod
    def TeardownFailed(e,cases):
        return tink_testrunner_SuiteResultType("TeardownFailed", 2, [e,cases])
tink_testrunner_SuiteResultType._hx_class = tink_testrunner_SuiteResultType
_hx_classes["tink.testrunner.SuiteResultType"] = tink_testrunner_SuiteResultType

class tink_testrunner_CaseResultType(Enum):
    __slots__ = ()
    _hx_class_name = "tink.testrunner.CaseResultType"
    _hx_constructs = ["Succeeded", "Failed", "Excluded"]

    @staticmethod
    def Succeeded(assertions):
        return tink_testrunner_CaseResultType("Succeeded", 0, [assertions])

    @staticmethod
    def Failed(e):
        return tink_testrunner_CaseResultType("Failed", 1, [e])
tink_testrunner_CaseResultType.Excluded = tink_testrunner_CaseResultType("Excluded", 2, list())
tink_testrunner_CaseResultType._hx_class = tink_testrunner_CaseResultType
_hx_classes["tink.testrunner.CaseResultType"] = tink_testrunner_CaseResultType

class tink_testrunner_FailureType(Enum):
    __slots__ = ()
    _hx_class_name = "tink.testrunner.FailureType"
    _hx_constructs = ["AssertionFailed", "CaseFailed", "SuiteFailed"]

    @staticmethod
    def AssertionFailed(assertion):
        return tink_testrunner_FailureType("AssertionFailed", 0, [assertion])

    @staticmethod
    def CaseFailed(err):
        return tink_testrunner_FailureType("CaseFailed", 1, [err])

    @staticmethod
    def SuiteFailed(err):
        return tink_testrunner_FailureType("SuiteFailed", 2, [err])
tink_testrunner_FailureType._hx_class = tink_testrunner_FailureType
_hx_classes["tink.testrunner.FailureType"] = tink_testrunner_FailureType


class tink_testrunner__Suite_Suite_Impl_:
    _hx_class_name = "tink.testrunner._Suite.Suite_Impl_"
    __slots__ = ()
    _hx_statics = ["ofCases", "ofCase", "getCasesToBeRun"]

    @staticmethod
    def ofCases(cases,pos = None):
        _g = []
        _g1 = 0
        while (_g1 < len(cases)):
            def _hx_local_1():
                nonlocal _g1
                _hx_local_0 = _g1
                _g1 = (_g1 + 1)
                return _hx_local_0
            c = python_internal_ArrayImpl._get(cases, _hx_local_1())
            _g11 = Type.getClass(c)
            x = (None if ((_g11 is None)) else Type.getClassName(_g11))
            _g.append(x)
        return tink_testrunner_BasicSuite(_hx_AnonObject({'name': ", ".join([python_Boot.toString1(x1,'') for x1 in _g]), 'pos': pos}),cases,_hx_AnonObject({'fileName': "tink/testrunner/Suite.hx", 'lineNumber': 36, 'className': "tink.testrunner._Suite.Suite_Impl_", 'methodName': "ofCases"}))

    @staticmethod
    def ofCase(caze,pos = None):
        cases = [caze]
        _g = []
        _g1 = 0
        while (_g1 < len(cases)):
            def _hx_local_1():
                nonlocal _g1
                _hx_local_0 = _g1
                _g1 = (_g1 + 1)
                return _hx_local_0
            c = python_internal_ArrayImpl._get(cases, _hx_local_1())
            _g11 = Type.getClass(c)
            x = (None if ((_g11 is None)) else Type.getClassName(_g11))
            _g.append(x)
        return tink_testrunner_BasicSuite(_hx_AnonObject({'name': ", ".join([python_Boot.toString1(x1,'') for x1 in _g]), 'pos': pos}),cases,_hx_AnonObject({'fileName': "tink/testrunner/Suite.hx", 'lineNumber': 36, 'className': "tink.testrunner._Suite.Suite_Impl_", 'methodName': "ofCases"}))

    @staticmethod
    def getCasesToBeRun(this1,includeMode):
        def _hx_local_1():
            def _hx_local_0(c):
                return tink_testrunner__Case_Case_Impl_.shouldRun(c,includeMode)
            return list(filter(_hx_local_0,this1.cases))
        return _hx_local_1()
tink_testrunner__Suite_Suite_Impl_._hx_class = tink_testrunner__Suite_Suite_Impl_
_hx_classes["tink.testrunner._Suite.Suite_Impl_"] = tink_testrunner__Suite_Suite_Impl_


class tink_testrunner_SuiteObject:
    _hx_class_name = "tink.testrunner.SuiteObject"
    __slots__ = ("info", "cases")
    _hx_fields = ["info", "cases"]
    _hx_methods = ["setup", "before", "after", "teardown"]
tink_testrunner_SuiteObject._hx_class = tink_testrunner_SuiteObject
_hx_classes["tink.testrunner.SuiteObject"] = tink_testrunner_SuiteObject


class tink_testrunner_BasicSuite:
    _hx_class_name = "tink.testrunner.BasicSuite"
    __slots__ = ("info", "cases")
    _hx_fields = ["info", "cases"]
    _hx_methods = ["setup", "before", "after", "teardown"]
    _hx_interfaces = [tink_testrunner_SuiteObject]

    def __init__(self,info,cases,pos = None):
        self.info = info
        self.cases = cases
        if (Reflect.field(info,"pos") is None):
            Reflect.setField(info,"pos",pos)
        _g = 0
        while (_g < len(cases)):
            def _hx_local_1():
                nonlocal _g
                _hx_local_0 = _g
                _g = (_g + 1)
                return _hx_local_0
            c = python_internal_ArrayImpl._get(cases, _hx_local_1())
            c.suite = self

    def setup(self):
        return tink_core__Promise_Promise_Impl_.NOISE

    def before(self):
        return tink_core__Promise_Promise_Impl_.NOISE

    def after(self):
        return tink_core__Promise_Promise_Impl_.NOISE

    def teardown(self):
        return tink_core__Promise_Promise_Impl_.NOISE

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.info = None
        _hx_o.cases = None
tink_testrunner_BasicSuite._hx_class = tink_testrunner_BasicSuite
_hx_classes["tink.testrunner.BasicSuite"] = tink_testrunner_BasicSuite


class tink_testrunner_Timer:
    _hx_class_name = "tink.testrunner.Timer"
    __slots__ = ()
    _hx_methods = ["stop"]
tink_testrunner_Timer._hx_class = tink_testrunner_Timer
_hx_classes["tink.testrunner.Timer"] = tink_testrunner_Timer


class tink_testrunner_TimerManager:
    _hx_class_name = "tink.testrunner.TimerManager"
    __slots__ = ()
    _hx_methods = ["schedule"]
tink_testrunner_TimerManager._hx_class = tink_testrunner_TimerManager
_hx_classes["tink.testrunner.TimerManager"] = tink_testrunner_TimerManager


class tink_testrunner_HaxeTimer:
    _hx_class_name = "tink.testrunner.HaxeTimer"
    __slots__ = ("timer",)
    _hx_fields = ["timer"]
    _hx_methods = ["stop"]
    _hx_interfaces = [tink_testrunner_Timer]

    def __init__(self,ms,f):
        self.timer = haxe_Timer.delay(f,ms)

    def stop(self):
        if (self.timer is not None):
            self.timer.stop()
            self.timer = None

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.timer = None
tink_testrunner_HaxeTimer._hx_class = tink_testrunner_HaxeTimer
_hx_classes["tink.testrunner.HaxeTimer"] = tink_testrunner_HaxeTimer


class tink_testrunner_HaxeTimerManager:
    _hx_class_name = "tink.testrunner.HaxeTimerManager"
    __slots__ = ()
    _hx_methods = ["schedule"]
    _hx_interfaces = [tink_testrunner_TimerManager]

    def __init__(self):
        pass

    def schedule(self,ms,f):
        return tink_testrunner_HaxeTimer(ms,f)

    @staticmethod
    def _hx_empty_init(_hx_o):        pass
tink_testrunner_HaxeTimerManager._hx_class = tink_testrunner_HaxeTimerManager
_hx_classes["tink.testrunner.HaxeTimerManager"] = tink_testrunner_HaxeTimerManager


class tink_unit_Assert:
    _hx_class_name = "tink.unit.Assert"
    __slots__ = ()
    _hx_statics = ["printer", "fail", "stringify"]

    @staticmethod
    def fail(e,pos = None):
        return tink_streams__Stream_Stream_Impl_.ofError(e)

    @staticmethod
    def stringify(v):
        if ((Std._hx_is(v,str) or Std._hx_is(v,Float)) or Std._hx_is(v,Bool)):
            return haxe_format_JsonPrinter.print(v,None,None)
        else:
            return Std.string(v)
tink_unit_Assert._hx_class = tink_unit_Assert
_hx_classes["tink.unit.Assert"] = tink_unit_Assert


class tink_unit__AssertionBuffer_Impl(tink_streams_SignalStream):
    _hx_class_name = "tink.unit._AssertionBuffer.Impl"
    __slots__ = ("trigger",)
    _hx_fields = ["trigger"]
    _hx_methods = ["yield"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = tink_streams_SignalStream


    def __init__(self):
        self.trigger = None
        trigger = tink_core__Signal_Signal_Impl_.trigger()
        super().__init__(trigger)
        self.trigger = trigger

    def _hx_yield(self,data):
        tink_core__Callback_CallbackList_Impl_.invoke(self.trigger.handlers,data)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.trigger = None
tink_unit__AssertionBuffer_Impl._hx_class = tink_unit__AssertionBuffer_Impl
_hx_classes["tink.unit._AssertionBuffer.Impl"] = tink_unit__AssertionBuffer_Impl


class tink_unit__AssertionBuffer_AssertionBuffer_Impl_:
    _hx_class_name = "tink.unit._AssertionBuffer.AssertionBuffer_Impl_"
    __slots__ = ()
    _hx_statics = ["_new", "emit", "fail", "defer", "done", "handle"]

    @staticmethod
    def _new():
        return tink_unit__AssertionBuffer_Impl()

    @staticmethod
    def emit(this1,assertion):
        tink_core__Callback_CallbackList_Impl_.invoke(this1.trigger.handlers,tink_streams_Yield.Data(assertion))

    @staticmethod
    def fail(this1,code = None,reason = None,pos = None):
        if (code is None):
            code = reason.code
        tink_core__Callback_CallbackList_Impl_.invoke(this1.trigger.handlers,tink_streams_Yield.Fail(tink_core_TypedError(code,reason.message,pos)))
        return this1

    @staticmethod
    def defer(this1,f):
        tink_core__Callback_Callback_Impl_.defer(f)
        return this1

    @staticmethod
    def done(this1):
        tink_core__Callback_CallbackList_Impl_.invoke(this1.trigger.handlers,tink_streams_Yield.End)
        return this1

    @staticmethod
    def handle(this1,outcome):
        tmp = outcome.index
        if (tmp == 0):
            tink_core__Callback_CallbackList_Impl_.invoke(this1.trigger.handlers,tink_streams_Yield.End)
        elif (tmp == 1):
            e = outcome.params[0]
            code = e.code
            if (code is None):
                code = e.code
            tink_core__Callback_CallbackList_Impl_.invoke(this1.trigger.handlers,tink_streams_Yield.Fail(tink_core_TypedError(code,e.message,_hx_AnonObject({'fileName': "tink/unit/AssertionBuffer.hx", 'lineNumber': 63, 'className': "tink.unit._AssertionBuffer.AssertionBuffer_Impl_", 'methodName': "handle"}))))
        else:
            pass
tink_unit__AssertionBuffer_AssertionBuffer_Impl_._hx_class = tink_unit__AssertionBuffer_AssertionBuffer_Impl_
_hx_classes["tink.unit._AssertionBuffer.AssertionBuffer_Impl_"] = tink_unit__AssertionBuffer_AssertionBuffer_Impl_


class tink_unit__AssertionBuffer_FailingReason_Impl_:
    _hx_class_name = "tink.unit._AssertionBuffer.FailingReason_Impl_"
    __slots__ = ()
    _hx_statics = ["ofString"]

    @staticmethod
    def ofString(e):
        return tink_core_TypedError(None,e,_hx_AnonObject({'fileName': "tink/unit/AssertionBuffer.hx", 'lineNumber': 72, 'className': "tink.unit._AssertionBuffer.FailingReason_Impl_", 'methodName': "ofString"}))
tink_unit__AssertionBuffer_FailingReason_Impl_._hx_class = tink_unit__AssertionBuffer_FailingReason_Impl_
_hx_classes["tink.unit._AssertionBuffer.FailingReason_Impl_"] = tink_unit__AssertionBuffer_FailingReason_Impl_


class tink_unit_TestBatch:
    _hx_class_name = "tink.unit.TestBatch"
    __slots__ = ()
tink_unit_TestBatch._hx_class = tink_unit_TestBatch
_hx_classes["tink.unit.TestBatch"] = tink_unit_TestBatch


class tink_unit_TestCase:
    _hx_class_name = "tink.unit.TestCase"
    __slots__ = ("suite", "info", "timeout", "include", "exclude", "pos", "test")
    _hx_fields = ["suite", "info", "timeout", "include", "exclude", "pos", "test"]
    _hx_methods = ["execute"]
    _hx_interfaces = [tink_testrunner_CaseObject]

    def __init__(self,info,test,timeout,include,exclude,pos = None):
        self.suite = None
        self.info = info
        self.test = test
        self.timeout = timeout
        self.include = include
        self.exclude = exclude
        self.pos = pos

    def execute(self):
        return self.test()

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.suite = None
        _hx_o.info = None
        _hx_o.timeout = None
        _hx_o.include = None
        _hx_o.exclude = None
        _hx_o.pos = None
        _hx_o.test = None
tink_unit_TestCase._hx_class = tink_unit_TestCase
_hx_classes["tink.unit.TestCase"] = tink_unit_TestCase


class tink_unit_TestSuiteBuilder:
    _hx_class_name = "tink.unit.TestSuiteBuilder"
    __slots__ = ()
tink_unit_TestSuiteBuilder._hx_class = tink_unit_TestSuiteBuilder
_hx_classes["tink.unit.TestSuiteBuilder"] = tink_unit_TestSuiteBuilder


class tink_unit_TestSuiteBase(tink_testrunner_BasicSuite):
    _hx_class_name = "tink.unit.TestSuiteBase"
    __slots__ = ("target",)
    _hx_fields = ["target"]
    _hx_methods = []
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = tink_testrunner_BasicSuite


    def __init__(self,info,cases,pos = None):
        self.target = None
        super().__init__(info,cases,pos)

    @staticmethod
    def _hx_empty_init(_hx_o):
        _hx_o.target = None
tink_unit_TestSuiteBase._hx_class = tink_unit_TestSuiteBase
_hx_classes["tink.unit.TestSuiteBase"] = tink_unit_TestSuiteBase


class tink_unit_TestSuite:
    _hx_class_name = "tink.unit.TestSuite"
    __slots__ = ()
tink_unit_TestSuite._hx_class = tink_unit_TestSuite
_hx_classes["tink.unit.TestSuite"] = tink_unit_TestSuite


class tink_unit_TestSuiteBuilder0(tink_unit_TestSuiteBase):
    _hx_class_name = "tink.unit.TestSuiteBuilder0"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = ["setup", "before", "after", "teardown"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = tink_unit_TestSuiteBase


    def __init__(self,target,name = None):
        def _hx_local_0():
            this1 = tink_unit__AssertionBuffer_Impl()
            return target.test_create(60000,this1)
        tmp = tink_unit_TestCase(_hx_AnonObject({'name': "test_create", 'description': "60000", 'pos': _hx_AnonObject({'lineNumber': 28, 'fileName': "src/Main.hx", 'methodName': "test_create", 'className': "TestStorage"})}),_hx_local_0,30000,False,False,_hx_AnonObject({'lineNumber': 28, 'fileName': "src/Main.hx", 'methodName': "test_create", 'className': "TestStorage"}))
        def _hx_local_1():
            this2 = tink_unit__AssertionBuffer_Impl()
            return target.test_http(4000,9,this2)
        tmp1 = tink_unit_TestCase(_hx_AnonObject({'name': "test_http", 'description': "4000, 9", 'pos': _hx_AnonObject({'lineNumber': 95, 'fileName': "src/Main.hx", 'methodName': "test_http", 'className': "TestStorage"})}),_hx_local_1,30000,False,False,_hx_AnonObject({'lineNumber': 95, 'fileName': "src/Main.hx", 'methodName': "test_http", 'className': "TestStorage"}))
        super().__init__(_hx_AnonObject({'name': ("TestStorage" if ((name is None)) else name), 'pos': _hx_AnonObject({'lineNumber': 23, 'fileName': "src/Main.hx", 'methodName': None, 'className': "TestStorage"})}),[tmp, tmp1],_hx_AnonObject({'fileName': "tink/unit/TestBuilder.hx", 'lineNumber': 129, 'className': "tink.unit.TestSuiteBuilder0", 'methodName': "new"}))
        self.target = target

    def setup(self):
        return tink_core__Promise_Promise_Impl_.NOISE

    def before(self):
        return tink_core__Promise_Promise_Impl_.NOISE

    def after(self):
        return tink_core__Promise_Promise_Impl_.NOISE

    def teardown(self):
        return tink_core__Promise_Promise_Impl_.NOISE

    @staticmethod
    def _hx_empty_init(_hx_o):        pass
tink_unit_TestSuiteBuilder0._hx_class = tink_unit_TestSuiteBuilder0
_hx_classes["tink.unit.TestSuiteBuilder0"] = tink_unit_TestSuiteBuilder0

Math.NEGATIVE_INFINITY = float("-inf")
Math.POSITIVE_INFINITY = float("inf")
Math.NaN = float("nan")
Math.PI = python_lib_Math.pi

def _hx_init_Sys_environ():
    def _hx_local_0():
        Sys.environ = haxe_ds_StringMap()
        env = python_lib_Os.environ
        key = python_HaxeIterator(iter(env.keys()))
        while key.hasNext():
            key1 = key.next()
            _this = Sys.environ
            value = env.get(key1,None)
            _this.h[key1] = value
        return Sys.environ
    return _hx_local_0()
Sys.environ = _hx_init_Sys_environ()
python_Boot.keywords = set(["and", "del", "from", "not", "with", "as", "elif", "global", "or", "yield", "assert", "else", "if", "pass", "None", "break", "except", "import", "raise", "True", "class", "exec", "in", "return", "False", "continue", "finally", "is", "try", "def", "for", "lambda", "while"])
python_Boot.prefixLength = len("_hx_")
ANSI.ESCAPE = "\x1B"
ANSI.BELL = "\x07"
ANSI.CSI = ("\x1B" + "[")
ANSI.attr = Attribute
def _hx_init_ANSI_values():
    def _hx_local_0():
        _g = haxe_ds_EnumValueMap()
        _g.set(Attribute.Off,0)
        _g.set(Attribute.Bold,1)
        _g.set(Attribute.Underline,4)
        _g.set(Attribute.Blink,5)
        _g.set(Attribute.ReverseVideo,7)
        _g.set(Attribute.Concealed,8)
        _g.set(Attribute.BoldOff,22)
        _g.set(Attribute.UnderlineOff,24)
        _g.set(Attribute.BlinkOff,25)
        _g.set(Attribute.NormalVideo,27)
        _g.set(Attribute.ConcealedOff,28)
        _g.set(Attribute.Black,30)
        _g.set(Attribute.Red,31)
        _g.set(Attribute.Green,32)
        _g.set(Attribute.Yellow,33)
        _g.set(Attribute.Blue,34)
        _g.set(Attribute.Magenta,35)
        _g.set(Attribute.Cyan,36)
        _g.set(Attribute.White,37)
        _g.set(Attribute.DefaultForeground,39)
        _g.set(Attribute.BlackBack,40)
        _g.set(Attribute.RedBack,41)
        _g.set(Attribute.GreenBack,42)
        _g.set(Attribute.YellowBack,43)
        _g.set(Attribute.BlueBack,44)
        _g.set(Attribute.MagentaBack,45)
        _g.set(Attribute.CyanBack,46)
        _g.set(Attribute.WhiteBack,47)
        _g.set(Attribute.DefaultBackground,49)
        return _g
    return _hx_local_0()
ANSI.values = _hx_init_ANSI_values()
ANSI.set = Reflect.makeVarArgs(ANSI.aset)
ANSI.available = ANSI.detectSupport()
ANSI.strip = False
ANSI.stripIfUnavailable = True
def _hx_init_ANSI_sequences():
    def _hx_local_0():
        _g = haxe_ds_StringMap()
        _g.h["eraseDisplayToEnd"] = _hx_AnonObject({'val': (("\x1B" + "[") + "J"), 'doc': "Erase from cursor to the end of display."})
        _g.h["eraseDisplayToCursor"] = _hx_AnonObject({'val': (("\x1B" + "[") + "1J"), 'doc': "Erase from the start of diplay to cursor (inclusive)."})
        _g.h["eraseDisplay"] = _hx_AnonObject({'val': (("\x1B" + "[") + "2J"), 'doc': "Erase display and move cursor to the top-left."})
        _g.h["eraseLineToEnd"] = _hx_AnonObject({'val': (("\x1B" + "[") + "K"), 'doc': "Erase from cursor to the end of line."})
        _g.h["eraseLineToCursor"] = _hx_AnonObject({'val': (("\x1B" + "[") + "1K"), 'doc': "Erase from the start of line to cursor (inclusive)."})
        _g.h["eraseLine"] = _hx_AnonObject({'val': (("\x1B" + "[") + "2K"), 'doc': "Erase line."})
        _g.h["eraseChar"] = _hx_AnonObject({'val': (("\x1B" + "[") + "X"), 'doc': "Erase one character."})
        _g.h["eraseChars"] = _hx_AnonObject({'val': (("\x1B" + "[") + "#X"), 'doc': "Erase # characters."})
        _g.h["insertLine"] = _hx_AnonObject({'val': (("\x1B" + "[") + "L"), 'doc': "Insert one blank line."})
        _g.h["insertLines"] = _hx_AnonObject({'val': (("\x1B" + "[") + "#L"), 'doc': "Insert # blank lines."})
        _g.h["deleteLine"] = _hx_AnonObject({'val': (("\x1B" + "[") + "M"), 'doc': "Delete one line."})
        _g.h["deleteLines"] = _hx_AnonObject({'val': (("\x1B" + "[") + "#M"), 'doc': "Delete # lines."})
        _g.h["deleteChar"] = _hx_AnonObject({'val': (("\x1B" + "[") + "P"), 'doc': "Delete one character."})
        _g.h["deleteChars"] = _hx_AnonObject({'val': (("\x1B" + "[") + "#P"), 'doc': "Delete # characters."})
        _g.h["insertChar"] = _hx_AnonObject({'val': (("\x1B" + "[") + "@"), 'doc': "Insert one blank character."})
        _g.h["insertChars"] = _hx_AnonObject({'val': (("\x1B" + "[") + "#@"), 'doc': "Insert # blank characters."})
        _g.h["moveUp"] = _hx_AnonObject({'val': (("\x1B" + "[") + "#A"), 'doc': "Move cursor up # lines."})
        _g.h["moveDown"] = _hx_AnonObject({'val': (("\x1B" + "[") + "#B"), 'doc': "Move cursor down # lines."})
        _g.h["moveRight"] = _hx_AnonObject({'val': (("\x1B" + "[") + "#C"), 'doc': "Move cursor right # characters."})
        _g.h["moveLeft"] = _hx_AnonObject({'val': (("\x1B" + "[") + "#D"), 'doc': "Move cursor left # characters."})
        _g.h["moveDownReset"] = _hx_AnonObject({'val': (("\x1B" + "[") + "#E"), 'doc': "Move cursor down # lines and to first column."})
        _g.h["moveUpReset"] = _hx_AnonObject({'val': (("\x1B" + "[") + "#F"), 'doc': "Move cursor up # lines and to first column."})
        _g.h["setX"] = _hx_AnonObject({'val': (("\x1B" + "[") + "#G"), 'doc': "Move cursor to column #."})
        _g.h["setY"] = _hx_AnonObject({'val': (("\x1B" + "[") + "#d"), 'doc': "Move cursor to line #."})
        _g.h["reset"] = _hx_AnonObject({'val': (("\x1B" + "[") + "H"), 'doc': "Move cursor to top-left."})
        _g.h["resetY"] = _hx_AnonObject({'val': (("\x1B" + "[") + "#H"), 'doc': "Move cursor to line # and first column."})
        _g.h["setXY"] = _hx_AnonObject({'val': (("\x1B" + "[") + "#;#H"), 'doc': "Move cursor to line #, column #.", 'params': [_hx_AnonObject({'index': 1, 'name': "column"}), _hx_AnonObject({'index': 0, 'name': "line"})]})
        _g.h["saveCursor"] = _hx_AnonObject({'val': (("\x1B" + "[") + "s"), 'doc': "Save cursor position."})
        _g.h["loadCursor"] = _hx_AnonObject({'val': (("\x1B" + "[") + "u"), 'doc': "Move cursor to saved position."})
        _g.h["showCursor"] = _hx_AnonObject({'val': (("\x1B" + "[") + "?25h"), 'doc': "Show cursor."})
        _g.h["hideCursor"] = _hx_AnonObject({'val': (("\x1B" + "[") + "?25l"), 'doc': "Hide cursor."})
        return _g
    return _hx_local_0()
ANSI.sequences = _hx_init_ANSI_sequences()
haxe_EntryPoint.pending = list()
haxe_EntryPoint.threadCount = 0
haxe_Serializer.USE_CACHE = False
haxe_Serializer.USE_ENUM_INDEX = False
haxe_Serializer.BASE64 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789%:"
haxe_Serializer.BASE64_CODES = None
haxe_Unserializer.DEFAULT_RESOLVER = haxe__Unserializer_DefaultResolver()
haxe_Unserializer.BASE64 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789%:"
haxe_Unserializer.CODES = None
haxe_zip_InflateImpl.LEN_EXTRA_BITS_TBL = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, -1, -1]
haxe_zip_InflateImpl.LEN_BASE_VAL_TBL = [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258]
haxe_zip_InflateImpl.DIST_EXTRA_BITS_TBL = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, -1, -1]
haxe_zip_InflateImpl.DIST_BASE_VAL_TBL = [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577]
haxe_zip_InflateImpl.CODE_LENGTHS_POS = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]
haxe_zip_InflateImpl.FIXED_HUFFMAN = None
sys_Http.PROXY = None
tink_RunLoop.current = tink_RunLoop()
tink_concurrent__Thread_Thread_Impl_.MAIN = "Fake Main Thread"
tink_core__Callback_Callback_Impl_.depth = 0
tink_core__Callback_Callback_Impl_.MAX_DEPTH = 200
tink_core__Future_NeverFuture.inst = tink_core__Future_NeverFuture()
tink_core__Future_Future_Impl_.NULL = tink_core__Future_SyncFuture(tink_core__Lazy_LazyConst(None))
tink_core__Future_Future_Impl_.NOISE = tink_core__Future_SyncFuture(tink_core__Lazy_LazyConst(tink_core_Noise.Noise))
tink_core__Future_Future_Impl_.NEVER = tink_core__Future_SyncFuture(tink_core__Lazy_LazyConst(tink_core__Future_NeverFuture.inst))
tink_core__Promise_Promise_Impl_.NULL = tink_core__Future_SyncFuture(tink_core__Lazy_LazyConst(tink_core_Outcome.Success(None)))
tink_core__Promise_Promise_Impl_.NOISE = tink_core__Future_SyncFuture(tink_core__Lazy_LazyConst(tink_core_Outcome.Success(tink_core_Noise.Noise)))
tink_core__Promise_Promise_Impl_.NEVER = tink_core__Future_Future_Impl_.NEVER.map(tink_core_Outcome.Success).gather()
tink_runloop__Task_Task_Impl_.NOOP = tink_runloop__Task_Noop()
tink_streams_Empty.inst = tink_streams_Empty()
tink_unit_Assert.printer = haxe_macro_Printer()

Main.main()
haxe_EntryPoint.run()
